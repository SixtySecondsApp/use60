SET statement_timeout = 0;

SET lock_timeout = 0;

SET idle_in_transaction_session_timeout = 0;

SET client_encoding = 'UTF8';

SET standard_conforming_strings = on;

SELECT pg_catalog.set_config('search_path', '', false);

SET check_function_bodies = false;

SET xmloption = content;

SET client_min_messages = warning;

SET row_security = off;

-- Baseline migration generated from existing database, cleaned for portable resets

CREATE SCHEMA IF NOT EXISTS extensions;

CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA extensions;

CREATE EXTENSION IF NOT EXISTS citext WITH SCHEMA extensions;

CREATE SCHEMA IF NOT EXISTS "public";

CREATE SCHEMA IF NOT EXISTS extensions;

CREATE EXTENSION IF NOT EXISTS citext WITH SCHEMA extensions;

ALTER SCHEMA "public" OWNER TO "pg_database_owner";

COMMENT ON SCHEMA "public" IS 'Function volatility fixed: 20250128200000';

CREATE TYPE "public"."activity_priority" AS ENUM (
    'low',
    'medium',
    'high'
);

ALTER TYPE "public"."activity_priority" OWNER TO "postgres";

CREATE TYPE "public"."activity_status" AS ENUM (
    'pending',
    'completed',
    'cancelled',
    'no_show'
);

ALTER TYPE "public"."activity_status" OWNER TO "postgres";

COMMENT ON TYPE "public"."activity_status" IS 'Activity statuses: pending, completed, cancelled, no_show (for tracking no-show meetings)';

CREATE TYPE "public"."activity_type" AS ENUM (
    'outbound',
    'meeting',
    'proposal',
    'sale',
    'fathom_meeting'
);

ALTER TYPE "public"."activity_type" OWNER TO "postgres";

CREATE TYPE "public"."client_status" AS ENUM (
    'active',
    'churned',
    'paused',
    'signed',
    'deposit_paid',
    'notice_given'
);

ALTER TYPE "public"."client_status" OWNER TO "postgres";

CREATE TYPE "public"."meeting_processing_status" AS ENUM (
    'pending',
    'processing',
    'complete',
    'failed'
);

ALTER TYPE "public"."meeting_processing_status" OWNER TO "postgres";

CREATE TYPE "public"."member_role" AS ENUM (
    'member',
    'leader',
    'admin'
);

ALTER TYPE "public"."member_role" OWNER TO "postgres";

CREATE TYPE "public"."waitlist_status" AS ENUM (
    'pending',
    'released',
    'declined',
    'converted'
);

ALTER TYPE "public"."waitlist_status" OWNER TO "postgres";

-- ALTER FUNCTION "public"."accept_next_action_suggestion"("p_suggestion_id" "uuid", "p_task_data" "jsonb") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."accept_next_action_suggestion"("p_suggestion_id" "uuid", "p_task_data" "jsonb") IS 'Accept an AI suggestion and create a task. Validates and maps action_type to valid task_type enum values.';

-- ALTER FUNCTION "public"."accept_org_invitation"("p_token" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."accept_org_invitation"("p_token" "text") IS 'Accepts an organization invitation and creates membership';

CREATE OR REPLACE FUNCTION "public"."add_invited_user_to_admin_org"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_admin_org_id UUID;
  v_admin_id UUID;
BEGIN
  -- Check if user was invited (has admin ID in metadata)
  v_admin_id := (NEW.id::TEXT); -- Will be overridden if we find admin ID in metadata

  -- Try to get admin ID from profile metadata (set during invitation)
  IF NEW.raw_user_meta_data IS NOT NULL AND NEW.raw_user_meta_data->>'invited_by_admin_id' IS NOT NULL THEN
    BEGIN
      v_admin_id := (NEW.raw_user_meta_data->>'invited_by_admin_id')::UUID;
    EXCEPTION WHEN OTHERS THEN
      RAISE WARNING 'Failed to parse invited_by_admin_id for user %: %', NEW.id, SQLERRM;
      RETURN NEW;
    END;
  END IF;

  -- Get the admin's primary organization (owner or admin role)
  SELECT om.org_id INTO v_admin_org_id
  FROM organization_memberships om
  WHERE om.user_id = v_admin_id
    AND om.role IN ('owner', 'admin')
  ORDER BY om.created_at ASC
  LIMIT 1;

  -- If we found an admin organization, add the new user to it
  IF v_admin_org_id IS NOT NULL THEN
    INSERT INTO organization_memberships (org_id, user_id, role, created_at, updated_at)
    VALUES (v_admin_org_id, NEW.id, 'member', NOW(), NOW())
    ON CONFLICT (org_id, user_id) DO NOTHING;

    RAISE NOTICE 'Added invited user % to admin organization %', NEW.id, v_admin_org_id;
  ELSE
    RAISE WARNING 'Could not find admin organization for invited user %', NEW.id;
  END IF;

  RETURN NEW;
EXCEPTION
  WHEN OTHERS THEN
    RAISE WARNING 'add_invited_user_to_admin_org failed for user %: %', NEW.id, SQLERRM;
    RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."add_invited_user_to_admin_org"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."adjust_notification_fatigue"("p_user_id" "uuid", "p_adjustment" integer) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE user_engagement_metrics
  SET
    notification_fatigue_level = GREATEST(0, LEAST(100, COALESCE(notification_fatigue_level, 0) + p_adjustment)),
    updated_at = NOW()
  WHERE user_id = p_user_id;

  -- If no row exists, create one with the adjustment
  IF NOT FOUND THEN
    INSERT INTO user_engagement_metrics (user_id, notification_fatigue_level)
    VALUES (p_user_id, GREATEST(0, LEAST(100, 50 + p_adjustment)));
  END IF;
END;
$$;

-- ALTER FUNCTION "public"."adjust_notification_fatigue"("p_user_id" "uuid", "p_adjustment" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."adjust_notification_fatigue"("p_user_id" "uuid", "p_adjustment" integer) IS 'Adjust user notification fatigue level by given amount';

CREATE OR REPLACE FUNCTION "public"."aggregate_company_meeting_insights"("p_company_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  v_total_meetings INTEGER;
  v_total_contacts INTEGER;
  v_last_meeting_date TIMESTAMPTZ;
  v_avg_sentiment NUMERIC;
  v_sentiment_trend TEXT;
  v_engagement_score INTEGER;
  v_days_since_last INTEGER;
  v_avg_days_between_meetings NUMERIC;
  v_key_topics TEXT[];
BEGIN
  -- Aggregate basic statistics
  SELECT
    COUNT(DISTINCT m.id),
    COUNT(DISTINCT mc.contact_id),
    MAX(m.meeting_start),
    AVG(m.sentiment_score)
  INTO
    v_total_meetings,
    v_total_contacts,
    v_last_meeting_date,
    v_avg_sentiment
  FROM meetings m
  LEFT JOIN meeting_contacts mc ON m.id = mc.meeting_id
  WHERE m.company_id = p_company_id
    AND m.sync_status = 'synced';

  -- Calculate days since last meeting
  IF v_last_meeting_date IS NOT NULL THEN
    v_days_since_last := EXTRACT(DAY FROM (NOW() - v_last_meeting_date));
  END IF;

  -- Calculate average days between meetings
  WITH meeting_gaps AS (
    SELECT
      meeting_start,
      LAG(meeting_start) OVER (ORDER BY meeting_start) AS prev_meeting
    FROM meetings
    WHERE company_id = p_company_id
      AND sync_status = 'synced'
  )
  SELECT AVG(EXTRACT(DAY FROM (meeting_start - prev_meeting)))
  INTO v_avg_days_between_meetings
  FROM meeting_gaps
  WHERE prev_meeting IS NOT NULL;

  -- Calculate sentiment trend
  v_sentiment_trend := calculate_sentiment_trend(p_company_id := p_company_id);

  -- Calculate engagement score (similar to contact but company-level)
  v_engagement_score := calculate_contact_engagement_score(
    v_total_meetings,
    v_avg_sentiment,
    v_days_since_last
  );

  -- Extract key topics
  SELECT ARRAY_AGG(DISTINCT t.label)
  INTO v_key_topics
  FROM meeting_topics t
  JOIN meetings m ON t.meeting_id = m.id
  WHERE m.company_id = p_company_id
  LIMIT 20;

  -- Upsert insights
  INSERT INTO company_meeting_insights (
    company_id,
    total_meetings,
    total_contacts_met,
    last_meeting_date,
    avg_sentiment_score,
    sentiment_trend,
    engagement_score,
    meeting_frequency_days,
    key_topics,
    last_updated_at
  ) VALUES (
    p_company_id,
    v_total_meetings,
    v_total_contacts,
    v_last_meeting_date,
    v_avg_sentiment,
    v_sentiment_trend,
    v_engagement_score,
    v_avg_days_between_meetings,
    v_key_topics,
    NOW()
  )
  ON CONFLICT (company_id) DO UPDATE SET
    total_meetings = EXCLUDED.total_meetings,
    total_contacts_met = EXCLUDED.total_contacts_met,
    last_meeting_date = EXCLUDED.last_meeting_date,
    avg_sentiment_score = EXCLUDED.avg_sentiment_score,
    sentiment_trend = EXCLUDED.sentiment_trend,
    engagement_score = EXCLUDED.engagement_score,
    meeting_frequency_days = EXCLUDED.meeting_frequency_days,
    key_topics = EXCLUDED.key_topics,
    last_updated_at = NOW();

  RAISE NOTICE 'Updated insights for company %: % meetings with % contacts, engagement score: %',
    p_company_id, v_total_meetings, v_total_contacts, v_engagement_score;
END;
$$;

-- ALTER FUNCTION "public"."aggregate_company_meeting_insights"("p_company_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."aggregate_company_meeting_insights"("p_company_id" "uuid") IS 'Aggregates all meeting data for a company into insights table';

CREATE OR REPLACE FUNCTION "public"."aggregate_contact_meeting_insights"("p_contact_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  v_total_meetings INTEGER;
  v_last_meeting_date TIMESTAMPTZ;
  v_avg_sentiment NUMERIC;
  v_avg_talk_time NUMERIC;
  v_sentiment_trend TEXT;
  v_engagement_score INTEGER;
  v_days_since_last INTEGER;
  v_key_topics TEXT[];
BEGIN
  -- Aggregate basic statistics
  SELECT
    COUNT(*),
    MAX(m.meeting_start),
    AVG(m.sentiment_score),
    AVG(m.talk_time_customer_pct)
  INTO
    v_total_meetings,
    v_last_meeting_date,
    v_avg_sentiment,
    v_avg_talk_time
  FROM meetings m
  JOIN meeting_contacts mc ON m.id = mc.meeting_id
  WHERE mc.contact_id = p_contact_id
    AND m.sync_status = 'synced';

  -- Calculate days since last meeting
  IF v_last_meeting_date IS NOT NULL THEN
    v_days_since_last := EXTRACT(DAY FROM (NOW() - v_last_meeting_date));
  END IF;

  -- Calculate sentiment trend
  v_sentiment_trend := calculate_sentiment_trend(p_contact_id := p_contact_id);

  -- Calculate engagement score
  v_engagement_score := calculate_contact_engagement_score(
    v_total_meetings,
    v_avg_sentiment,
    v_days_since_last
  );

  -- Extract key topics (from meeting_topics table if available)
  SELECT ARRAY_AGG(DISTINCT t.label)
  INTO v_key_topics
  FROM meeting_topics t
  JOIN meeting_contacts mc ON t.meeting_id = mc.meeting_id
  WHERE mc.contact_id = p_contact_id
  LIMIT 20; -- Limit to top 20 topics

  -- Upsert insights
  INSERT INTO contact_meeting_insights (
    contact_id,
    total_meetings,
    last_meeting_date,
    avg_sentiment_score,
    sentiment_trend,
    avg_talk_time_customer_pct,
    engagement_score,
    key_topics,
    last_updated_at
  ) VALUES (
    p_contact_id,
    v_total_meetings,
    v_last_meeting_date,
    v_avg_sentiment,
    v_sentiment_trend,
    v_avg_talk_time,
    v_engagement_score,
    v_key_topics,
    NOW()
  )
  ON CONFLICT (contact_id) DO UPDATE SET
    total_meetings = EXCLUDED.total_meetings,
    last_meeting_date = EXCLUDED.last_meeting_date,
    avg_sentiment_score = EXCLUDED.avg_sentiment_score,
    sentiment_trend = EXCLUDED.sentiment_trend,
    avg_talk_time_customer_pct = EXCLUDED.avg_talk_time_customer_pct,
    engagement_score = EXCLUDED.engagement_score,
    key_topics = EXCLUDED.key_topics,
    last_updated_at = NOW();

  RAISE NOTICE 'Updated insights for contact %: % meetings, engagement score: %',
    p_contact_id, v_total_meetings, v_engagement_score;
END;
$$;

-- ALTER FUNCTION "public"."aggregate_contact_meeting_insights"("p_contact_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."aggregate_contact_meeting_insights"("p_contact_id" "uuid") IS 'Aggregates all meeting data for a contact into insights table';

CREATE OR REPLACE FUNCTION "public"."analyze_action_item_with_ai"("p_action_item_id" "uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  edge_function_url TEXT;
  response_body TEXT;
  response_status INTEGER;
  analysis_result JSON;
BEGIN
  -- Get the Edge Function URL from environment
  edge_function_url := current_setting('app.settings.supabase_url', true) || '/functions/v1/analyze-action-item';

  -- Make HTTP request to Edge Function
  SELECT status, body INTO response_status, response_body
  FROM net.http_post(
    url := edge_function_url,
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || current_setting('app.settings.service_role_key', true)
    ),
    body := jsonb_build_object(
      'action_item_id', p_action_item_id
    )::text
  );

  -- Check response status
  IF response_status != 200 THEN
    RAISE WARNING 'AI analysis failed with status %: %', response_status, response_body;
    RETURN NULL;
  END IF;

  -- Parse response
  analysis_result := response_body::json;

  -- Update action item with AI analysis
  UPDATE meeting_action_items
  SET
    ai_task_type = (analysis_result->>'task_type')::TEXT,
    ai_deadline = (analysis_result->>'ideal_deadline')::DATE,
    ai_confidence_score = (analysis_result->>'confidence_score')::NUMERIC,
    ai_reasoning = analysis_result->>'reasoning',
    ai_analyzed_at = NOW()
  WHERE id = p_action_item_id;

  RETURN analysis_result;

EXCEPTION WHEN OTHERS THEN
  RAISE WARNING 'Error in AI analysis: %', SQLERRM;
  RETURN NULL;
END;
$$;

-- ALTER FUNCTION "public"."analyze_action_item_with_ai"("p_action_item_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."analyze_action_item_with_ai"("p_action_item_id" "uuid") IS 'Call Edge Function to analyze action item with Claude Haiku 4.5';

CREATE OR REPLACE FUNCTION "public"."apply_ai_analysis_to_task"("p_action_item_id" "uuid", "p_task_type" "text", "p_ideal_deadline" "date", "p_confidence_score" numeric, "p_reasoning" "text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  v_task_id UUID;
  v_current_notes TEXT;
  v_updated_notes TEXT;
BEGIN
  -- Get task ID
  SELECT task_id INTO v_task_id
  FROM meeting_action_items
  WHERE id = p_action_item_id;

  IF v_task_id IS NULL THEN
    RAISE WARNING 'No task found for action item %', p_action_item_id;
    RETURN false;
  END IF;

  -- Get current notes
  SELECT notes INTO v_current_notes
  FROM tasks
  WHERE id = v_task_id;

  -- Update notes with AI reasoning
  v_updated_notes := REPLACE(
    COALESCE(v_current_notes, ''),
    'Note: AI analysis pending...',
    CONCAT('AI Analysis (Confidence: ', ROUND(p_confidence_score * 100), '%): ', p_reasoning)
  );

  -- Update task with AI-determined values
  UPDATE tasks
  SET
    task_type = p_task_type,
    due_date = p_ideal_deadline::TIMESTAMPTZ,
    notes = v_updated_notes,
    updated_at = NOW()
  WHERE id = v_task_id;

  -- Update action item with AI analysis
  UPDATE meeting_action_items
  SET
    ai_task_type = p_task_type,
    ai_deadline = p_ideal_deadline,
    ai_confidence_score = p_confidence_score,
    ai_reasoning = p_reasoning,
    ai_analyzed_at = NOW()
  WHERE id = p_action_item_id;

  RETURN true;

EXCEPTION WHEN OTHERS THEN
  RAISE WARNING 'Error applying AI analysis: %', SQLERRM;
  RETURN false;
END;
$$;

-- ALTER FUNCTION "public"."apply_ai_analysis_to_task"("p_action_item_id" "uuid", "p_task_type" "text", "p_ideal_deadline" "date", "p_confidence_score" numeric, "p_reasoning" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."apply_ai_analysis_to_task"("p_action_item_id" "uuid", "p_task_type" "text", "p_ideal_deadline" "date", "p_confidence_score" numeric, "p_reasoning" "text") IS 'Apply AI analysis results to existing task';

CREATE OR REPLACE FUNCTION "public"."approve_pipeline_recommendation"("p_recommendation_id" "uuid", "p_reviewed_by" "uuid", "p_notes" "text" DEFAULT NULL::"text") RETURNS boolean
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  v_recommendation RECORD;
  v_rows_affected INTEGER;
BEGIN
  -- Get recommendation
  SELECT *
  INTO v_recommendation
  FROM pipeline_stage_recommendations
  WHERE id = p_recommendation_id
    AND status = 'pending';

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Recommendation not found or already processed';
  END IF;

  -- Update deal stage
  UPDATE deals
  SET
    stage = v_recommendation.recommended_stage,
    updated_at = NOW()
  WHERE id = v_recommendation.deal_id;

  -- FIXED: Correct syntax for GET DIAGNOSTICS
  GET DIAGNOSTICS v_rows_affected = ROW_COUNT;

  IF v_rows_affected > 0 THEN
    -- Mark recommendation as approved
    UPDATE pipeline_stage_recommendations
    SET
      status = 'approved',
      reviewed_at = NOW(),
      reviewed_by = p_reviewed_by,
      review_notes = p_notes
    WHERE id = p_recommendation_id;

    RAISE NOTICE 'Deal % moved from % to %',
      v_recommendation.deal_id,
      v_recommendation.current_stage,
      v_recommendation.recommended_stage;

    RETURN TRUE;
  ELSE
    RAISE EXCEPTION 'Failed to update deal stage';
  END IF;
END;
$$;

-- ALTER FUNCTION "public"."approve_pipeline_recommendation"("p_recommendation_id" "uuid", "p_reviewed_by" "uuid", "p_notes" "text") OWNER TO "postgres";

-- ALTER FUNCTION "public"."audit_trigger_function"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."auto_apply_pipeline_recommendations"() RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  v_recommendation RECORD;
  v_applied_count INTEGER := 0;
BEGIN
  -- Find pending recommendations that meet auto-apply criteria
  FOR v_recommendation IN
    SELECT *
    FROM pipeline_stage_recommendations
    WHERE status = 'pending'
      AND auto_apply_enabled = TRUE
      AND confidence_score >= auto_apply_threshold
      AND expires_at > NOW()
  LOOP
    BEGIN
      -- Update deal stage
      UPDATE deals
      SET
        stage = v_recommendation.recommended_stage,
        updated_at = NOW()
      WHERE id = v_recommendation.deal_id;

      -- Mark as auto-applied
      UPDATE pipeline_stage_recommendations
      SET
        status = 'auto_applied',
        reviewed_at = NOW()
      WHERE id = v_recommendation.id;

      v_applied_count := v_applied_count + 1;

      RAISE NOTICE 'Auto-applied recommendation: % â†’ %',
        v_recommendation.current_stage,
        v_recommendation.recommended_stage;

    EXCEPTION WHEN OTHERS THEN
      RAISE WARNING 'Failed to auto-apply recommendation %: %',
        v_recommendation.id, SQLERRM;
    END;
  END LOOP;

  RETURN v_applied_count;
END;
$$;

-- ALTER FUNCTION "public"."auto_apply_pipeline_recommendations"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."auto_assign_to_sixty_seconds_org"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  sixty_seconds_org_id UUID;
BEGIN
  -- Only process @sixtyseconds.video email addresses
  IF NEW.email LIKE '%@sixtyseconds.video' THEN
    -- Get the Sixty Seconds organization ID
    SELECT id INTO sixty_seconds_org_id
    FROM organizations
    WHERE name = 'Sixty Seconds'
    LIMIT 1;

    -- If organization exists, add the user as an owner
    IF sixty_seconds_org_id IS NOT NULL THEN
      INSERT INTO organization_memberships (org_id, user_id, role)
      VALUES (sixty_seconds_org_id, NEW.id, 'owner')
      ON CONFLICT (org_id, user_id) DO NOTHING;

      RAISE NOTICE 'Auto-assigned user % to Sixty Seconds organization', NEW.email;
    ELSE
      RAISE WARNING 'Sixty Seconds organization not found for user %', NEW.email;
    END IF;
  END IF;

  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  -- Don't fail signup if org assignment fails
  RAISE WARNING 'auto_assign_to_sixty_seconds_org failed for %: %', NEW.email, SQLERRM;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."auto_assign_to_sixty_seconds_org"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."auto_assign_to_sixty_seconds_org"() IS 'Automatically assigns users with @sixtyseconds.video email addresses to the Sixty Seconds organization';

CREATE OR REPLACE FUNCTION "public"."auto_calculate_cost"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.cost_estimate := calculate_ai_cost(
    NEW.provider,
    NEW.model,
    NEW.prompt_tokens,
    NEW.completion_tokens
  );
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."auto_calculate_cost"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."auto_churn_expired_clients"() RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
  DECLARE
      updated_count INTEGER;
  BEGIN
      -- Auto-churn clients whose final billing date has passed
      UPDATE clients
      SET
          status = 'churned',
          churn_date = CURRENT_DATE,
          updated_at = NOW()
      WHERE status = 'notice_given'
        AND final_billing_date IS NOT NULL
        AND final_billing_date < CURRENT_DATE
        AND status != 'churned';

      GET DIAGNOSTICS updated_count = ROW_COUNT;

      IF updated_count > 0 THEN
          RAISE NOTICE 'Auto-churned % clients whose final billing date passed', updated_count;
      END IF;

      RETURN updated_count;
  END;
  $$;

-- ALTER FUNCTION "public"."auto_churn_expired_clients"() OWNER TO "postgres";

-- ALTER FUNCTION "public"."auto_create_org_for_new_user"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."auto_create_org_for_new_user"() IS 'Automatically creates or links user to organization when profile is created. Uses company_name from waitlist if available, normalizes names to prevent duplicates, and reuses similar organization names.';

CREATE OR REPLACE FUNCTION "public"."auto_create_task_from_action_item"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  assignee_user_id UUID;
  meeting_owner_id UUID;
  meeting_title_text TEXT;
  task_priority TEXT;
  task_type_determined TEXT;
  deadline_determined TIMESTAMPTZ;
  new_task_id UUID;
  ai_analysis JSON;
  task_notes TEXT;
BEGIN
  -- Only process if not already synced
  IF NEW.task_id IS NOT NULL OR NEW.synced_to_task = true THEN
    RETURN NEW;
  END IF;

  -- Get meeting details
  SELECT owner_user_id, title INTO meeting_owner_id, meeting_title_text
  FROM meetings
  WHERE id = NEW.meeting_id;

  -- Only process if assignee is internal (sales rep)
  IF NEW.assignee_email IS NOT NULL AND NOT is_internal_assignee(NEW.assignee_email) THEN
    -- External assignee - exclude from sync
    NEW.sync_status := 'excluded';
    NEW.synced_to_task := false;
    RETURN NEW;
  END IF;

  -- Determine assignee
  IF NEW.assignee_email IS NOT NULL THEN
    assignee_user_id := get_user_id_from_email(NEW.assignee_email);
  END IF;

  -- Fallback to meeting owner if no assignee found
  IF assignee_user_id IS NULL THEN
    assignee_user_id := meeting_owner_id;
  END IF;

  -- Final check - must have a valid assignee
  IF assignee_user_id IS NULL THEN
    NEW.sync_status := 'failed';
    NEW.sync_error := 'No valid assignee found (no assignee email and no meeting owner)';
    RETURN NEW;
  END IF;

  -- Map Fathom priority to task priority
  task_priority := COALESCE(LOWER(NEW.priority), 'medium');
  IF task_priority NOT IN ('low', 'medium', 'high', 'urgent') THEN
    task_priority := 'medium';
  END IF;

  -- ========================================================================
  -- AI ANALYSIS: Determine task type and ideal deadline
  -- ========================================================================

  BEGIN
    -- Call AI analysis function (asynchronous, best effort)
    -- We use pg_background or similar for async execution
    -- For now, we'll use a simple approach with error handling

    -- Note: The AI analysis will be called via the Edge Function
    -- For the initial implementation, we'll use inline HTTP call with net.http_post

    DECLARE
      edge_function_url TEXT;
      response_body TEXT;
      response_status INTEGER;
    BEGIN
      -- Construct Edge Function URL
      edge_function_url := current_setting('app.settings.supabase_url', true) || '/functions/v1/analyze-action-item';

      -- Make HTTP request
      SELECT status, body INTO response_status, response_body
      FROM net.http_post(
        url := edge_function_url,
        headers := jsonb_build_object(
          'Content-Type', 'application/json',
          'Authorization', 'Bearer ' || current_setting('app.settings.service_role_key', true)
        ),
        body := jsonb_build_object(
          'action_item_id', NEW.id
        )::text,
        timeout_milliseconds := 5000
      );

      IF response_status = 200 THEN
        ai_analysis := response_body::json;

        -- Use AI-determined task type
        task_type_determined := COALESCE((ai_analysis->>'task_type')::TEXT, 'follow_up');

        -- Use AI-determined deadline
        deadline_determined := COALESCE(
          (ai_analysis->>'ideal_deadline')::TIMESTAMPTZ,
          NEW.deadline_at,
          NOW() + INTERVAL '3 days'
        );

        -- Store AI reasoning in notes
        task_notes := CONCAT(
          'Category: ', COALESCE(NEW.category, 'General'),
          E'\n', 'AI Generated: ', CASE WHEN NEW.ai_generated THEN 'Yes' ELSE 'No' END,
          E'\n', 'AI Analysis (Confidence: ', ROUND((ai_analysis->>'confidence_score')::NUMERIC * 100), '%): ',
          ai_analysis->>'reasoning',
          E'\n', CASE WHEN NEW.playback_url IS NOT NULL THEN CONCAT('Video Playback: ', NEW.playback_url) ELSE '' END
        );

        -- Update action item with AI results
        NEW.ai_task_type := task_type_determined;
        NEW.ai_deadline := (ai_analysis->>'ideal_deadline')::DATE;
        NEW.ai_confidence_score := (ai_analysis->>'confidence_score')::NUMERIC;
        NEW.ai_reasoning := ai_analysis->>'reasoning';
        NEW.ai_analyzed_at := NOW();

      ELSE
        -- AI analysis failed, use fallback logic
        RAISE WARNING 'AI analysis failed with status %, using fallback', response_status;
        task_type_determined := 'follow_up';
        deadline_determined := COALESCE(NEW.deadline_at, NOW() + INTERVAL '3 days');

        task_notes := CONCAT(
          'Category: ', COALESCE(NEW.category, 'General'),
          E'\n', 'AI Generated: ', CASE WHEN NEW.ai_generated THEN 'Yes' ELSE 'No' END,
          E'\n', 'Note: AI analysis unavailable, using default categorization',
          E'\n', CASE WHEN NEW.playback_url IS NOT NULL THEN CONCAT('Video Playback: ', NEW.playback_url) ELSE '' END
        );
      END IF;

    EXCEPTION WHEN OTHERS THEN
      -- Error calling AI - use fallback logic
      RAISE WARNING 'Error calling AI analysis: %, using fallback', SQLERRM;
      task_type_determined := 'follow_up';
      deadline_determined := COALESCE(NEW.deadline_at, NOW() + INTERVAL '3 days');

      task_notes := CONCAT(
        'Category: ', COALESCE(NEW.category, 'General'),
        E'\n', 'AI Generated: ', CASE WHEN NEW.ai_generated THEN 'Yes' ELSE 'No' END,
        E'\n', 'Note: AI analysis error, using default categorization',
        E'\n', CASE WHEN NEW.playback_url IS NOT NULL THEN CONCAT('Video Playback: ', NEW.playback_url) ELSE '' END
      );
    END;

  END;

  -- ========================================================================
  -- CREATE TASK with AI-determined values
  -- ========================================================================

  BEGIN
    -- Create task
    INSERT INTO tasks (
      title,
      description,
      due_date,
      priority,
      status,
      task_type,
      assigned_to,
      created_by,
      meeting_action_item_id,
      notes,
      completed
    ) VALUES (
      NEW.title,
      CONCAT('Action item from meeting: ', COALESCE(meeting_title_text, 'Unknown Meeting')),
      deadline_determined,
      task_priority,
      CASE WHEN NEW.completed THEN 'completed' ELSE 'pending' END,
      task_type_determined,
      assignee_user_id,
      assignee_user_id,
      NEW.id,
      task_notes,
      NEW.completed
    )
    RETURNING id INTO new_task_id;

    -- Update action item with sync status
    NEW.task_id := new_task_id;
    NEW.synced_to_task := true;
    NEW.sync_status := 'synced';
    NEW.synced_at := NOW();
    NEW.sync_error := NULL;

  EXCEPTION WHEN OTHERS THEN
    -- Handle errors gracefully
    NEW.sync_status := 'failed';
    NEW.sync_error := CONCAT('Error creating task: ', SQLERRM);
    NEW.synced_to_task := false;
  END;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."auto_create_task_from_action_item"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."auto_create_task_from_action_item"() IS 'Manual task creation function - called explicitly via create-task-from-action-item edge function. NOT triggered automatically.';

CREATE OR REPLACE FUNCTION "public"."auto_create_task_from_action_item_v2"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  assignee_user_id UUID;
  meeting_owner_id UUID;
  meeting_title_text TEXT;
  task_priority TEXT;
  new_task_id UUID;
BEGIN
  -- Only process if not already synced
  IF NEW.task_id IS NOT NULL OR NEW.synced_to_task = true THEN
    RETURN NEW;
  END IF;

  -- Get meeting details
  SELECT owner_user_id, title INTO meeting_owner_id, meeting_title_text
  FROM meetings
  WHERE id = NEW.meeting_id;

  -- Only process if assignee is internal (sales rep)
  IF NEW.assignee_email IS NOT NULL AND NOT is_internal_assignee(NEW.assignee_email) THEN
    NEW.sync_status := 'excluded';
    NEW.synced_to_task := false;
    RETURN NEW;
  END IF;

  -- Determine assignee
  IF NEW.assignee_email IS NOT NULL THEN
    assignee_user_id := get_user_id_from_email(NEW.assignee_email);
  END IF;

  -- Fallback to meeting owner
  IF assignee_user_id IS NULL THEN
    assignee_user_id := meeting_owner_id;
  END IF;

  -- Validate assignee
  IF assignee_user_id IS NULL THEN
    NEW.sync_status := 'failed';
    NEW.sync_error := 'No valid assignee found';
    RETURN NEW;
  END IF;

  -- Map priority
  task_priority := COALESCE(LOWER(NEW.priority), 'medium');
  IF task_priority NOT IN ('low', 'medium', 'high', 'urgent') THEN
    task_priority := 'medium';
  END IF;

  BEGIN
    -- Create task with default values (AI will enhance later)
    INSERT INTO tasks (
      title,
      description,
      due_date,
      priority,
      status,
      task_type,
      assigned_to,
      created_by,
      meeting_action_item_id,
      notes,
      completed
    ) VALUES (
      NEW.title,
      CONCAT('Action item from meeting: ', COALESCE(meeting_title_text, 'Unknown Meeting')),
      COALESCE(NEW.deadline_at, NOW() + INTERVAL '3 days'), -- Default 3 days, AI will refine
      task_priority,
      CASE WHEN NEW.completed THEN 'completed' ELSE 'pending' END,
      'follow_up', -- Default type, AI will categorize
      assignee_user_id,
      assignee_user_id,
      NEW.id,
      CONCAT(
        'Category: ', COALESCE(NEW.category, 'General'),
        E'\n', 'AI Generated: ', CASE WHEN NEW.ai_generated THEN 'Yes' ELSE 'No' END,
        E'\n', 'Note: AI analysis pending...',
        E'\n', CASE WHEN NEW.playback_url IS NOT NULL THEN CONCAT('Video Playback: ', NEW.playback_url) ELSE '' END
      ),
      NEW.completed
    )
    RETURNING id INTO new_task_id;

    -- Update action item
    NEW.task_id := new_task_id;
    NEW.synced_to_task := true;
    NEW.sync_status := 'synced';
    NEW.synced_at := NOW();
    NEW.sync_error := NULL;

    -- Trigger async AI analysis notification
    -- This will be picked up by a background worker or Edge Function
    PERFORM pg_notify('ai_analysis_needed', json_build_object(
      'action_item_id', NEW.id,
      'task_id', new_task_id
    )::text);

  EXCEPTION WHEN OTHERS THEN
    NEW.sync_status := 'failed';
    NEW.sync_error := CONCAT('Error creating task: ', SQLERRM);
    NEW.synced_to_task := false;
  END;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."auto_create_task_from_action_item_v2"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."auto_create_task_from_action_item_v2"() IS 'Manual task creation function (v2) - called explicitly via create-task-from-action-item edge function. NOT triggered automatically.';

CREATE OR REPLACE FUNCTION "public"."auto_populate_suggestion_user_id"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- If user_id not provided, try to get it from the activity
  IF NEW.user_id IS NULL THEN
    NEW.user_id := get_user_id_from_activity(NEW.activity_id, NEW.activity_type);
  END IF;

  -- Validate user_id exists
  IF NEW.user_id IS NULL THEN
    RAISE EXCEPTION 'Cannot determine user_id for suggestion';
  END IF;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."auto_populate_suggestion_user_id"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."auto_process_activity"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  v_stage_name TEXT;
  v_stage_id UUID;
  v_existing_deal_id UUID;
  v_new_deal_id UUID;
  v_contact_id UUID;
  v_company_id UUID;
BEGIN
  -- Only process if activity has a contact identifier
  IF NEW.contact_identifier IS NULL OR NEW.contact_identifier = '' THEN
    RETURN NEW;
  END IF;

  -- Only process for specific activity types that should create/update deals
  IF NEW.type NOT IN ('meeting', 'proposal', 'sale') THEN
    RETURN NEW;
  END IF;

  -- Try to find existing contact
  IF NEW.contact_identifier_type = 'email' THEN
    SELECT id, company_id INTO v_contact_id, v_company_id
    FROM contacts 
    WHERE email = LOWER(TRIM(NEW.contact_identifier))
    LIMIT 1;
  ELSIF NEW.contact_identifier_type = 'phone' THEN
    SELECT id, company_id INTO v_contact_id, v_company_id
    FROM contacts 
    WHERE phone = NEW.contact_identifier
    LIMIT 1;
  END IF;

  -- If no contact found, create one
  IF v_contact_id IS NULL AND NEW.contact_identifier_type = 'email' THEN
    -- Try to find or create company first
    IF NEW.client_name IS NOT NULL AND NEW.client_name != '' THEN
      SELECT id INTO v_company_id
      FROM companies 
      WHERE LOWER(name) = LOWER(TRIM(NEW.client_name))
      LIMIT 1;
      
      IF v_company_id IS NULL THEN
        INSERT INTO companies (name, owner_id)
        VALUES (NEW.client_name, NEW.user_id)
        ON CONFLICT (name) DO NOTHING
        RETURNING id INTO v_company_id;
      END IF;
    END IF;

    -- Create contact
    INSERT INTO contacts (
      email,
      first_name,
      company_id,
      owner_id
    ) VALUES (
      LOWER(TRIM(NEW.contact_identifier)),
      COALESCE(NEW.client_name, 'Unknown'),
      v_company_id,
      NEW.user_id
    )
    ON CONFLICT (email) DO UPDATE
    SET company_id = COALESCE(contacts.company_id, EXCLUDED.company_id)
    RETURNING id INTO v_contact_id;
  END IF;

  -- Determine the appropriate stage based on activity type
  CASE NEW.type
    WHEN 'meeting' THEN
      v_stage_name := 'SQL';
    WHEN 'proposal' THEN
      v_stage_name := 'Opportunity';
    WHEN 'sale' THEN
      v_stage_name := 'Signed';
    ELSE
      v_stage_name := 'SQL';
  END CASE;

  -- Get the stage ID
  SELECT id INTO v_stage_id
  FROM deal_stages
  WHERE name = v_stage_name
  LIMIT 1;

  IF v_stage_id IS NULL THEN
    RAISE WARNING 'Stage % not found in deal_stages table', v_stage_name;
    RETURN NEW;
  END IF;

  -- Find existing deal for this contact and owner by email
  SELECT d.id INTO v_existing_deal_id
  FROM deals d
  WHERE d.contact_email = NEW.contact_identifier
    AND d.owner_id = NEW.user_id
    AND d.status = 'active'
  ORDER BY d.updated_at DESC
  LIMIT 1;

  -- If no deal found by email, try by contact_id (only if column exists)
  IF v_existing_deal_id IS NULL AND v_contact_id IS NOT NULL THEN
    BEGIN
      SELECT d.id INTO v_existing_deal_id
      FROM deals d
      WHERE d.primary_contact_id = v_contact_id
        AND d.owner_id = NEW.user_id
        AND d.status = 'active'
      ORDER BY d.updated_at DESC
      LIMIT 1;
    EXCEPTION
      WHEN undefined_column THEN
        -- Column doesn't exist, skip this check
        NULL;
    END;
  END IF;

  IF v_existing_deal_id IS NOT NULL THEN
    -- Update existing deal
    NEW.deal_id := v_existing_deal_id;
    
    -- Update deal stage if activity suggests progression
    IF NEW.type = 'proposal' THEN
      UPDATE deals 
      SET stage_id = (SELECT id FROM deal_stages WHERE name = 'Opportunity' LIMIT 1),
          updated_at = NOW()
      WHERE id = v_existing_deal_id
        AND stage_id IN (SELECT id FROM deal_stages WHERE name IN ('SQL', 'Lead'));
    ELSIF NEW.type = 'sale' THEN
      UPDATE deals 
      SET stage_id = (SELECT id FROM deal_stages WHERE name = 'Signed' LIMIT 1),
          updated_at = NOW(),
          value = COALESCE(NEW.amount, value)
      WHERE id = v_existing_deal_id;
    END IF;
  ELSE
    -- Create new deal
    INSERT INTO deals (
      name,
      company,
      contact_email,
      value,
      stage_id,
      owner_id,
      status,
      expected_close_date
    ) VALUES (
      COALESCE(NEW.client_name, 'Unknown') || ' - ' || 
        CASE NEW.type 
          WHEN 'meeting' THEN 'Meeting'
          WHEN 'proposal' THEN 'Proposal'
          WHEN 'sale' THEN 'Sale'
          ELSE NEW.type
        END,
      NEW.client_name,
      NEW.contact_identifier,
      COALESCE(NEW.amount, 0),
      v_stage_id,
      NEW.user_id,
      'active',
      NOW() + INTERVAL '30 days'
    )
    RETURNING id INTO v_new_deal_id;
    
    -- Update activity with new deal_id
    NEW.deal_id := v_new_deal_id;
    
    -- Try to update deal with contact and company (if columns exist)
    BEGIN
      UPDATE deals 
      SET primary_contact_id = v_contact_id, 
          company_id = v_company_id
      WHERE id = v_new_deal_id;
    EXCEPTION
      WHEN undefined_column THEN
        -- Columns don't exist, skip update
        NULL;
    END;
  END IF;

  -- Mark activity as processed
  NEW.is_processed := true;
  NEW.auto_matched := true;

  RETURN NEW;
EXCEPTION
  WHEN OTHERS THEN
    -- Log error but don't fail the insert
    RAISE WARNING 'Error in auto_process_activity: %', SQLERRM;
    RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."auto_process_activity"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."auto_process_activity"() IS 'Automatically processes activities to create or update deals based on contact information';

CREATE OR REPLACE FUNCTION "public"."auto_reset_stuck_fathom_sync"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- If a sync has been running for more than 30 minutes, reset it
  IF NEW.sync_status = 'syncing'
     AND NEW.last_sync_started_at < NOW() - INTERVAL '30 minutes' THEN
    NEW.sync_status := 'idle';
    NEW.error_message := 'Auto-reset from stuck syncing state (exceeded 30 minute timeout)';
    NEW.last_sync_completed_at := NOW();
  END IF;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."auto_reset_stuck_fathom_sync"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."auto_reset_stuck_fathom_sync"() IS 'Automatically resets fathom sync status if stuck in syncing state for more than 30 minutes';

-- ALTER FUNCTION "public"."auto_verify_email_for_access_code_user"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."auto_verify_email_for_access_code_user"() IS 'Auto-verifies email for users who signed up with valid access codes (linked to waitlist entry).';

CREATE OR REPLACE FUNCTION "public"."award_email_invite_points"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
  BEGIN
    -- Only award points when status changes to 'sent'
    IF NEW.invite_status = 'sent' AND (OLD.invite_status IS NULL OR OLD.invite_status
  != 'sent') THEN
      UPDATE meetings_waitlist
      SET referral_count = referral_count + 1
      WHERE id = NEW.waitlist_entry_id;
    END IF;

    RETURN NEW;
  END;
  $$;

-- ALTER FUNCTION "public"."award_email_invite_points"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."award_email_invite_points"() IS 'Awards 1 referral point (5 
 -- positions) when email invite is marked as sent';

CREATE OR REPLACE FUNCTION "public"."backfill_next_actions_for_meetings"("p_limit" integer DEFAULT 10, "p_min_date" timestamp with time zone DEFAULT ("now"() - '7 days'::interval)) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  meeting_record RECORD;
  processed_count INTEGER := 0;
  queued_count INTEGER := 0;
  skipped_count INTEGER := 0;
BEGIN
  -- Loop through recent meetings without suggestions
  FOR meeting_record IN
    SELECT id, owner_user_id, title, transcript_text, summary
    FROM meetings
    WHERE meeting_start >= p_min_date
      AND (next_actions_generated_at IS NULL OR next_actions_count = 0)
      AND (transcript_text IS NOT NULL OR summary IS NOT NULL)
    ORDER BY meeting_start DESC
    LIMIT p_limit
  LOOP
    processed_count := processed_count + 1;

    BEGIN
      -- Queue suggestion generation
      PERFORM call_suggest_next_actions_async(
        meeting_record.id,
        'meeting',
        meeting_record.owner_user_id
      );

      queued_count := queued_count + 1;

    EXCEPTION WHEN OTHERS THEN
      skipped_count := skipped_count + 1;
      RAISE WARNING 'Failed to queue suggestions for meeting %: %',
        meeting_record.id, SQLERRM;
    END;

  END LOOP;

  RETURN json_build_object(
    'processed', processed_count,
    'queued', queued_count,
    'skipped', skipped_count,
    'limit', p_limit
  );
END;
$$;

-- ALTER FUNCTION "public"."backfill_next_actions_for_meetings"("p_limit" integer, "p_min_date" timestamp with time zone) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."backfill_next_actions_for_meetings"("p_limit" integer, "p_min_date" timestamp with time zone) IS 'Batch process recent meetings to generate missing suggestions (for backfilling)';

CREATE OR REPLACE FUNCTION "public"."bulk_grant_waitlist_access"("p_entry_ids" "uuid"[], "p_admin_user_id" "uuid", "p_admin_notes" "text" DEFAULT NULL::"text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  granted_count INTEGER := 0;
  failed_count INTEGER := 0;
  result_details JSON;
  entry RECORD;
  error_messages TEXT[] := ARRAY[]::TEXT[];
BEGIN
  -- Validate admin permissions
  IF NOT EXISTS (
    SELECT 1 FROM profiles
    WHERE id = p_admin_user_id AND is_admin = true
  ) THEN
    RAISE EXCEPTION 'User % does not have admin permissions', p_admin_user_id;
  END IF;

  -- Limit to 50 entries maximum for safety
  IF array_length(p_entry_ids, 1) > 50 THEN
    RAISE EXCEPTION 'Cannot grant access to more than 50 users at once';
  END IF;

  -- Process each entry
  FOR entry IN
    SELECT id, email, name, status
    FROM meetings_waitlist
    WHERE id = ANY(p_entry_ids)
  LOOP
    BEGIN
      -- Validate entry is in 'pending' status
      IF entry.status != 'pending' THEN
        failed_count := failed_count + 1;
        error_messages := array_append(
          error_messages,
          json_build_object(
            'entry_id', entry.id,
            'email', entry.email,
            'error', 'Entry status is not pending: ' || entry.status
          )::TEXT
        );
        CONTINUE;
      END IF;

      -- Update waitlist entry to 'released'
      UPDATE meetings_waitlist
      SET
        status = 'released',
        access_granted_by = p_admin_user_id,
        admin_notes = p_admin_notes,
        magic_link_sent_at = now(),
        magic_link_expires_at = now() + INTERVAL '7 days',
        updated_at = now()
      WHERE id = entry.id;

      granted_count := granted_count + 1;

    EXCEPTION WHEN OTHERS THEN
      failed_count := failed_count + 1;
      error_messages := array_append(
        error_messages,
        json_build_object(
          'entry_id', entry.id,
          'email', entry.email,
          'error', SQLERRM
        )::TEXT
      );
    END;
  END LOOP;

  -- Build result
  result_details := json_build_object(
    'success', granted_count > 0,
    'granted', granted_count,
    'failed', failed_count,
    'total', array_length(p_entry_ids, 1),
    'errors', error_messages
  );

  RETURN result_details;
END;
$$;

-- ALTER FUNCTION "public"."bulk_grant_waitlist_access"("p_entry_ids" "uuid"[], "p_admin_user_id" "uuid", "p_admin_notes" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."bulk_grant_waitlist_access"("p_entry_ids" "uuid"[], "p_admin_user_id" "uuid", "p_admin_notes" "text") IS 'Grant access to multiple waitlist entries (max 50 at once)';

CREATE OR REPLACE FUNCTION "public"."calculate_activity_points"("activity_type" "public"."activity_type", "amount" numeric DEFAULT NULL::numeric) RETURNS integer
    LANGUAGE "plpgsql" IMMUTABLE
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN CASE activity_type
    WHEN 'outbound' THEN 1
    WHEN 'meeting' THEN 5
    WHEN 'proposal' THEN 10
    WHEN 'sale' THEN 20
    ELSE 0
  END;
END;
$$;

-- ALTER FUNCTION "public"."calculate_activity_points"("activity_type" "public"."activity_type", "amount" numeric) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."calculate_activity_trend"("user_id" "uuid", "activity_type" "public"."activity_type", "start_date" timestamp with time zone, "end_date" timestamp with time zone) RETURNS numeric
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO ''
    AS $$
DECLARE
  current_count integer;
  previous_count integer;
  interval_days integer;
BEGIN
  -- Get interval in days
  interval_days := EXTRACT(DAY FROM (end_date - start_date));
  
  -- Get current period count
  SELECT COUNT(*) INTO current_count
  FROM activities
  WHERE activities.user_id = calculate_activity_trend.user_id
  AND activities.type = calculate_activity_trend.activity_type
  AND date BETWEEN start_date AND end_date;

  -- Get previous period count
  SELECT COUNT(*) INTO previous_count
  FROM activities
  WHERE activities.user_id = calculate_activity_trend.user_id
  AND activities.type = calculate_activity_trend.activity_type
  AND date BETWEEN (start_date - (interval_days || ' days')::interval) AND start_date;

  -- Calculate trend percentage
  IF previous_count = 0 THEN
    RETURN 0;
  END IF;

  RETURN ROUND(((current_count - previous_count)::numeric / previous_count * 100), 1);
END;
$$;

-- ALTER FUNCTION "public"."calculate_activity_trend"("user_id" "uuid", "activity_type" "public"."activity_type", "start_date" timestamp with time zone, "end_date" timestamp with time zone) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."calculate_ai_cost"("p_provider" character varying, "p_model" character varying, "p_prompt_tokens" integer, "p_completion_tokens" integer) RETURNS numeric
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  v_cost DECIMAL(10, 6) := 0;
BEGIN
  -- Basic cost calculation (in USD)
  -- These are example rates and should be updated based on actual provider pricing
  IF p_provider = 'openai' THEN
    IF p_model LIKE 'gpt-4%' THEN
      v_cost := (p_prompt_tokens * 0.00003) + (p_completion_tokens * 0.00006);
    ELSIF p_model LIKE 'gpt-3.5%' THEN
      v_cost := (p_prompt_tokens * 0.0000005) + (p_completion_tokens * 0.0000015);
    END IF;
  ELSIF p_provider = 'anthropic' THEN
    IF p_model LIKE 'claude-3-opus%' THEN
      v_cost := (p_prompt_tokens * 0.000015) + (p_completion_tokens * 0.000075);
    ELSIF p_model LIKE 'claude-3-sonnet%' THEN
      v_cost := (p_prompt_tokens * 0.000003) + (p_completion_tokens * 0.000015);
    ELSIF p_model LIKE 'claude-3-haiku%' THEN
      v_cost := (p_prompt_tokens * 0.00000025) + (p_completion_tokens * 0.00000125);
    END IF;
  END IF;
  
  RETURN v_cost;
END;
$$;

-- ALTER FUNCTION "public"."calculate_ai_cost"("p_provider" character varying, "p_model" character varying, "p_prompt_tokens" integer, "p_completion_tokens" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."calculate_churn_rate"("p_start_date" "date", "p_end_date" "date", "p_currency" "text" DEFAULT NULL::"text") RETURNS TABLE("period_start" "date", "period_end" "date", "subscriber_churn_rate" numeric, "mrr_churn_rate" numeric, "subscribers_canceled" integer, "mrr_lost_cents" bigint, "active_subscriptions_start" integer, "mrr_start_cents" bigint, "currency" "text")
    LANGUAGE "plpgsql" STABLE
    AS $$
BEGIN
  RETURN QUERY
  WITH period_start_subs AS (
    -- Active subscriptions at start of period
    SELECT
      COUNT(*) as count,
      COALESCE(SUM(normalized_mrr_cents), 0) as mrr,
      currency
    FROM subscription_facts_view
    WHERE is_active = true
      AND started_at <= p_start_date
      AND (canceled_at IS NULL OR canceled_at > p_start_date)
      AND (p_currency IS NULL OR currency = p_currency)
    GROUP BY currency
  ),
  period_cancellations AS (
    -- Subscriptions canceled during period
    SELECT
      COUNT(*) as count,
      COALESCE(SUM(normalized_mrr_cents), 0) as mrr_lost,
      currency
    FROM subscription_facts_view
    WHERE canceled_at BETWEEN p_start_date AND p_end_date
      AND (p_currency IS NULL OR currency = p_currency)
    GROUP BY currency
  )
  SELECT
    p_start_date as period_start,
    p_end_date as period_end,
    CASE
      WHEN pss.count > 0 THEN (pc.count::NUMERIC / pss.count::NUMERIC * 100)
      ELSE 0
    END as subscriber_churn_rate,
    CASE
      WHEN pss.mrr > 0 THEN (pc.mrr_lost::NUMERIC / pss.mrr::NUMERIC * 100)
      ELSE 0
    END as mrr_churn_rate,
    COALESCE(pc.count, 0)::INTEGER as subscribers_canceled,
    COALESCE(pc.mrr_lost, 0) as mrr_lost_cents,
    COALESCE(pss.count, 0)::INTEGER as active_subscriptions_start,
    COALESCE(pss.mrr, 0) as mrr_start_cents,
    COALESCE(pss.currency, pc.currency) as currency
  FROM period_start_subs pss
  FULL OUTER JOIN period_cancellations pc ON pss.currency = pc.currency;
END;
$$;

-- ALTER FUNCTION "public"."calculate_churn_rate"("p_start_date" "date", "p_end_date" "date", "p_currency" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."calculate_churn_rate"("p_start_date" "date", "p_end_date" "date", "p_currency" "text") IS 'Calculate subscriber and MRR churn rate for a period';

CREATE OR REPLACE FUNCTION "public"."calculate_close_plan_progress"("p_deal_id" "uuid") RETURNS TABLE("completed" integer, "total" integer, "overdue" integer, "progress_pct" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_completed INTEGER;
  v_total INTEGER;
  v_overdue INTEGER;
BEGIN
  SELECT
    COUNT(*) FILTER (WHERE status = 'completed'),
    COUNT(*) FILTER (WHERE status != 'skipped'),
    COUNT(*) FILTER (WHERE status NOT IN ('completed', 'skipped') AND due_date < CURRENT_DATE)
  INTO v_completed, v_total, v_overdue
  FROM deal_close_plan_items
  WHERE deal_id = p_deal_id;

  RETURN QUERY SELECT
    v_completed,
    GREATEST(v_total, 1),  -- Avoid division by zero
    v_overdue,
    CASE WHEN v_total > 0
      THEN ((v_completed * 100) / v_total)::INTEGER
      ELSE 0
    END;
END;
$$;

-- ALTER FUNCTION "public"."calculate_close_plan_progress"("p_deal_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."calculate_contact_engagement_score"("p_total_meetings" integer, "p_avg_sentiment" numeric, "p_days_since_last_meeting" integer) RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  v_score INTEGER := 0;
  v_meeting_score INTEGER;
  v_sentiment_score INTEGER;
  v_recency_score INTEGER;
BEGIN
  -- Meeting frequency score (0-40 points)
  v_meeting_score := LEAST(p_total_meetings * 5, 40);

  -- Sentiment score (0-30 points)
  -- Map sentiment from -1/+1 to 0-30
  IF p_avg_sentiment IS NOT NULL THEN
    v_sentiment_score := GREATEST(0, ROUND((p_avg_sentiment + 1) * 15));
  ELSE
    v_sentiment_score := 15; -- Neutral default
  END IF;

  -- Recency score (0-30 points)
  -- More recent = higher score
  IF p_days_since_last_meeting IS NULL THEN
    v_recency_score := 0;
  ELSIF p_days_since_last_meeting <= 7 THEN
    v_recency_score := 30;
  ELSIF p_days_since_last_meeting <= 14 THEN
    v_recency_score := 25;
  ELSIF p_days_since_last_meeting <= 30 THEN
    v_recency_score := 20;
  ELSIF p_days_since_last_meeting <= 60 THEN
    v_recency_score := 10;
  ELSE
    v_recency_score := 5;
  END IF;

  v_score := v_meeting_score + v_sentiment_score + v_recency_score;

  RETURN LEAST(v_score, 100);
END;
$$;

-- ALTER FUNCTION "public"."calculate_contact_engagement_score"("p_total_meetings" integer, "p_avg_sentiment" numeric, "p_days_since_last_meeting" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."calculate_contact_engagement_score"("p_total_meetings" integer, "p_avg_sentiment" numeric, "p_days_since_last_meeting" integer) IS 'Calculates engagement score (0-100) based on meetings, sentiment, and recency';

CREATE OR REPLACE FUNCTION "public"."calculate_deal_annual_value"("p_one_off_revenue" numeric, "p_monthly_mrr" numeric) RETURNS numeric
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN COALESCE(p_one_off_revenue, 0) + (COALESCE(p_monthly_mrr, 0) * 12);
END;
$$;

-- ALTER FUNCTION "public"."calculate_deal_annual_value"("p_one_off_revenue" numeric, "p_monthly_mrr" numeric) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."calculate_deal_clarity_score"("p_deal_id" "uuid") RETURNS TABLE("clarity_score" integer, "next_step_score" integer, "economic_buyer_score" integer, "champion_score" integer, "success_metric_score" integer, "risks_score" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_next_step RECORD;
  v_eb RECORD;
  v_champion RECORD;
  v_success RECORD;
  v_risks RECORD;
  v_ns_score INTEGER := 0;
  v_eb_score INTEGER := 0;
  v_ch_score INTEGER := 0;
  v_sm_score INTEGER := 0;
  v_rk_score INTEGER := 0;
BEGIN
  -- Next step (30 points max)
  SELECT value, next_step_date INTO v_next_step
  FROM deal_truth_fields
  WHERE deal_id = p_deal_id AND field_key = 'next_step';

  IF v_next_step.value IS NOT NULL AND v_next_step.value != '' THEN
    IF v_next_step.next_step_date IS NOT NULL THEN
      v_ns_score := 30;  -- Has next step with date
    ELSE
      v_ns_score := 15;  -- Has next step but no date
    END IF;
  END IF;

  -- Economic buyer (25 points max)
  SELECT value, confidence, contact_id INTO v_eb
  FROM deal_truth_fields
  WHERE deal_id = p_deal_id AND field_key = 'economic_buyer';

  IF v_eb.contact_id IS NOT NULL THEN
    v_eb_score := 25;  -- Known and linked
  ELSIF v_eb.value IS NOT NULL AND v_eb.value != '' THEN
    IF v_eb.confidence >= 0.8 THEN
      v_eb_score := 20;  -- High confidence
    ELSIF v_eb.confidence >= 0.5 THEN
      v_eb_score := 12;  -- Medium confidence
    ELSE
      v_eb_score := 5;   -- Low confidence
    END IF;
  END IF;

  -- Champion (20 points max)
  SELECT value, champion_strength, contact_id INTO v_champion
  FROM deal_truth_fields
  WHERE deal_id = p_deal_id AND field_key = 'champion';

  IF v_champion.contact_id IS NOT NULL THEN
    IF v_champion.champion_strength = 'strong' THEN
      v_ch_score := 20;
    ELSIF v_champion.champion_strength = 'moderate' THEN
      v_ch_score := 15;
    ELSIF v_champion.champion_strength = 'weak' THEN
      v_ch_score := 10;
    ELSE
      v_ch_score := 8;  -- Known but strength unknown
    END IF;
  ELSIF v_champion.value IS NOT NULL AND v_champion.value != '' THEN
    v_ch_score := 5;  -- Name mentioned but not linked
  END IF;

  -- Success metric (15 points max)
  SELECT value, confidence INTO v_success
  FROM deal_truth_fields
  WHERE deal_id = p_deal_id AND field_key = 'success_metric';

  IF v_success.value IS NOT NULL AND v_success.value != '' THEN
    IF v_success.confidence >= 0.7 THEN
      v_sm_score := 15;
    ELSIF v_success.confidence >= 0.4 THEN
      v_sm_score := 10;
    ELSE
      v_sm_score := 5;
    END IF;
  END IF;

  -- Risks documented (10 points max)
  SELECT value INTO v_risks
  FROM deal_truth_fields
  WHERE deal_id = p_deal_id AND field_key = 'top_risks';

  IF v_risks.value IS NOT NULL AND v_risks.value != '' THEN
    v_rk_score := 10;
  END IF;

  RETURN QUERY SELECT
    (v_ns_score + v_eb_score + v_ch_score + v_sm_score + v_rk_score)::INTEGER,
    v_ns_score,
    v_eb_score,
    v_ch_score,
    v_sm_score,
    v_rk_score;
END;
$$;

-- ALTER FUNCTION "public"."calculate_deal_clarity_score"("p_deal_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."calculate_deal_clarity_score"("p_deal_id" "uuid") IS 'Calculates clarity score (0-100) based on truth field completeness';

CREATE OR REPLACE FUNCTION "public"."calculate_deal_momentum_score"("p_deal_id" "uuid") RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_health_score INTEGER;
  v_risk_score INTEGER;
  v_clarity_result RECORD;
  v_plan_result RECORD;
  v_momentum INTEGER;
  v_overdue_penalty INTEGER;
BEGIN
  -- Get health score
  SELECT overall_health_score INTO v_health_score
  FROM deal_health_scores
  WHERE deal_id = p_deal_id;

  v_health_score := COALESCE(v_health_score, 50);  -- Default to 50 if not calculated

  -- Get risk score (inverted: high risk = low score)
  SELECT risk_score INTO v_risk_score
  FROM deal_risk_aggregates
  WHERE deal_id = p_deal_id;

  v_risk_score := 100 - COALESCE(v_risk_score, 50);  -- Invert risk score

  -- Get clarity score
  SELECT * INTO v_clarity_result
  FROM calculate_deal_clarity_score(p_deal_id);

  -- Get close plan progress
  SELECT * INTO v_plan_result
  FROM calculate_close_plan_progress(p_deal_id);

  -- Calculate overdue penalty (5 points per overdue milestone, max 20)
  v_overdue_penalty := LEAST(COALESCE(v_plan_result.overdue, 0) * 5, 20);

  -- Calculate momentum: health(55%) + risk(25%) + clarity(20%) - overdue penalty
  v_momentum := (
    (COALESCE(v_clarity_result.clarity_score, 0) * 0.55) +
    (v_risk_score * 0.25) +
    (v_health_score * 0.20)
  )::INTEGER - v_overdue_penalty;

  -- Clamp to 0-100
  v_momentum := GREATEST(0, LEAST(100, v_momentum));

  RETURN v_momentum;
END;
$$;

-- ALTER FUNCTION "public"."calculate_deal_momentum_score"("p_deal_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."calculate_deal_momentum_score"("p_deal_id" "uuid") IS 'Combines health (55%) + inverse_risk (25%) + clarity (20%) - overdue penalty';

CREATE OR REPLACE FUNCTION "public"."calculate_deal_risk_aggregate"("p_deal_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_org_id UUID;
  v_active_count INTEGER;
  v_critical_count INTEGER;
  v_high_count INTEGER;
  v_medium_count INTEGER;
  v_low_count INTEGER;
  v_signal_breakdown JSONB;
  v_risk_score INTEGER;
  v_risk_level TEXT;
  v_sentiment_trend TEXT;
  v_avg_sentiment NUMERIC;
  v_days_since_meeting INTEGER;
  v_last_forward_movement TIMESTAMPTZ;
  v_risk_summary TEXT;
BEGIN
  -- Get org_id from deal
  SELECT d.org_id INTO v_org_id FROM deals d WHERE d.id = p_deal_id;

  -- Count active signals by severity
  SELECT
    COUNT(*) FILTER (WHERE NOT is_resolved AND NOT auto_dismissed),
    COUNT(*) FILTER (WHERE severity = 'critical' AND NOT is_resolved AND NOT auto_dismissed),
    COUNT(*) FILTER (WHERE severity = 'high' AND NOT is_resolved AND NOT auto_dismissed),
    COUNT(*) FILTER (WHERE severity = 'medium' AND NOT is_resolved AND NOT auto_dismissed),
    COUNT(*) FILTER (WHERE severity = 'low' AND NOT is_resolved AND NOT auto_dismissed)
  INTO v_active_count, v_critical_count, v_high_count, v_medium_count, v_low_count
  FROM deal_risk_signals
  WHERE deal_id = p_deal_id;

  -- Signal breakdown by type
  SELECT jsonb_object_agg(signal_type, cnt)
  INTO v_signal_breakdown
  FROM (
    SELECT signal_type, COUNT(*) as cnt
    FROM deal_risk_signals
    WHERE deal_id = p_deal_id AND NOT is_resolved AND NOT auto_dismissed
    GROUP BY signal_type
  ) t;

  -- Calculate risk score (weighted)
  v_risk_score := LEAST(100, (
    v_critical_count * 30 +
    v_high_count * 20 +
    v_medium_count * 10 +
    v_low_count * 5
  ));

  -- Determine risk level
  v_risk_level := CASE
    WHEN v_critical_count > 0 OR v_risk_score >= 80 THEN 'critical'
    WHEN v_high_count >= 2 OR v_risk_score >= 50 THEN 'high'
    WHEN v_high_count >= 1 OR v_medium_count >= 2 OR v_risk_score >= 25 THEN 'medium'
    ELSE 'low'
  END;

  -- Get sentiment data from recent meetings
  SELECT
    AVG(m.sentiment_score),
    CASE
      WHEN AVG(m.sentiment_score) FILTER (WHERE m.start_time > NOW() - interval '14 days') >
           AVG(m.sentiment_score) FILTER (WHERE m.start_time <= NOW() - interval '14 days') THEN 'improving'
      WHEN AVG(m.sentiment_score) FILTER (WHERE m.start_time > NOW() - interval '14 days') <
           AVG(m.sentiment_score) FILTER (WHERE m.start_time <= NOW() - interval '14 days') THEN 'declining'
      ELSE 'stable'
    END
  INTO v_avg_sentiment, v_sentiment_trend
  FROM meetings m
  WHERE m.company_id = (SELECT company_id FROM deals WHERE id = p_deal_id)
    AND m.start_time > NOW() - interval '90 days';

  -- Days since last meeting
  SELECT EXTRACT(DAY FROM NOW() - MAX(m.start_time))::INTEGER
  INTO v_days_since_meeting
  FROM meetings m
  WHERE m.company_id = (SELECT company_id FROM deals WHERE id = p_deal_id);

  -- Get last forward movement
  SELECT MAX(mss.created_at)
  INTO v_last_forward_movement
  FROM meeting_structured_summaries mss
  INNER JOIN meetings m ON mss.meeting_id = m.id
  WHERE m.company_id = (SELECT company_id FROM deals WHERE id = p_deal_id)
    AND (mss.outcome_signals->>'forward_movement')::boolean = true;

  -- Generate summary
  v_risk_summary := CASE
    WHEN v_risk_level = 'critical' THEN 'Critical risk: ' || v_critical_count || ' critical signal(s) detected'
    WHEN v_risk_level = 'high' THEN 'High risk: ' || v_high_count || ' high priority signal(s) require attention'
    WHEN v_risk_level = 'medium' THEN 'Moderate risk: Monitor ' || v_active_count || ' active signal(s)'
    ELSE 'Low risk: Deal is progressing normally'
  END;

  -- Upsert aggregate
  INSERT INTO deal_risk_aggregates (
    deal_id, org_id, overall_risk_level, risk_score,
    active_signals_count, critical_signals_count, high_signals_count,
    medium_signals_count, low_signals_count, signal_breakdown,
    sentiment_trend, avg_sentiment_last_3_meetings,
    days_since_last_meeting, last_forward_movement_at,
    days_without_forward_movement, risk_summary, last_calculated_at
  )
  VALUES (
    p_deal_id, v_org_id, v_risk_level, v_risk_score,
    v_active_count, v_critical_count, v_high_count,
    v_medium_count, v_low_count, COALESCE(v_signal_breakdown, '{}'::jsonb),
    COALESCE(v_sentiment_trend, 'unknown'), v_avg_sentiment,
    v_days_since_meeting, v_last_forward_movement,
    CASE WHEN v_last_forward_movement IS NOT NULL
      THEN EXTRACT(DAY FROM NOW() - v_last_forward_movement)::INTEGER
      ELSE NULL
    END,
    v_risk_summary, NOW()
  )
  ON CONFLICT (deal_id) DO UPDATE SET
    overall_risk_level = EXCLUDED.overall_risk_level,
    risk_score = EXCLUDED.risk_score,
    active_signals_count = EXCLUDED.active_signals_count,
    critical_signals_count = EXCLUDED.critical_signals_count,
    high_signals_count = EXCLUDED.high_signals_count,
    medium_signals_count = EXCLUDED.medium_signals_count,
    low_signals_count = EXCLUDED.low_signals_count,
    signal_breakdown = EXCLUDED.signal_breakdown,
    sentiment_trend = EXCLUDED.sentiment_trend,
    avg_sentiment_last_3_meetings = EXCLUDED.avg_sentiment_last_3_meetings,
    days_since_last_meeting = EXCLUDED.days_since_last_meeting,
    last_forward_movement_at = EXCLUDED.last_forward_movement_at,
    days_without_forward_movement = EXCLUDED.days_without_forward_movement,
    risk_summary = EXCLUDED.risk_summary,
    last_calculated_at = NOW(),
    updated_at = NOW();
END;
$$;

-- ALTER FUNCTION "public"."calculate_deal_risk_aggregate"("p_deal_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."calculate_deal_risk_aggregate"("p_deal_id" "uuid") IS 'Recalculates the risk aggregate for a deal based on current signals';

CREATE OR REPLACE FUNCTION "public"."calculate_deal_total_value"("p_one_off_revenue" numeric, "p_monthly_mrr" numeric) RETURNS numeric
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN COALESCE(p_one_off_revenue, 0) + (COALESCE(p_monthly_mrr, 0) * 3);
END;
$$;

-- ALTER FUNCTION "public"."calculate_deal_total_value"("p_one_off_revenue" numeric, "p_monthly_mrr" numeric) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."calculate_effective_position"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  NEW.effective_position := GREATEST(1, NEW.signup_position - (NEW.referral_count * 5));
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."calculate_effective_position"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."calculate_meeting_content_costs"("p_meeting_id" "uuid") RETURNS TABLE("topics_cost_cents" integer, "content_cost_cents" integer, "total_cost_cents" integer, "total_tokens" integer)
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO ''
    AS $$
BEGIN
  -- RLS policies automatically filter results by ownership

  RETURN QUERY
  SELECT
    COALESCE(SUM(mct.cost_cents), 0)::INTEGER as topics_cost_cents,
    COALESCE(SUM(mgc.cost_cents), 0)::INTEGER as content_cost_cents,
    COALESCE(SUM(mct.cost_cents), 0)::INTEGER + COALESCE(SUM(mgc.cost_cents), 0)::INTEGER as total_cost_cents,
    COALESCE(SUM(mct.tokens_used), 0)::INTEGER + COALESCE(SUM(mgc.tokens_used), 0)::INTEGER as total_tokens
  FROM meetings m
  LEFT JOIN meeting_content_topics mct ON mct.meeting_id = m.id AND mct.deleted_at IS NULL
  LEFT JOIN meeting_generated_content mgc ON mgc.meeting_id = m.id AND mgc.deleted_at IS NULL
  WHERE m.id = p_meeting_id
  GROUP BY m.id;
END;
$$;

-- ALTER FUNCTION "public"."calculate_meeting_content_costs"("p_meeting_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."calculate_normalized_monthly_amount"("p_amount_cents" integer, "p_interval" "text", "p_interval_count" integer DEFAULT 1) RETURNS integer
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
BEGIN
  IF p_amount_cents IS NULL THEN
    RETURN NULL;
  END IF;
  
  -- Normalize to monthly
  CASE p_interval
    WHEN 'month' THEN
      RETURN p_amount_cents / p_interval_count;
    WHEN 'year' THEN
      RETURN p_amount_cents / (p_interval_count * 12);
    ELSE
      -- Default to monthly if unknown
      RETURN p_amount_cents;
  END CASE;
END;
$$;

-- ALTER FUNCTION "public"."calculate_normalized_monthly_amount"("p_amount_cents" integer, "p_interval" "text", "p_interval_count" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."calculate_normalized_monthly_amount"("p_amount_cents" integer, "p_interval" "text", "p_interval_count" integer) IS 'Normalizes subscription amount to monthly recurring revenue';

CREATE OR REPLACE FUNCTION "public"."calculate_realized_ltv"("p_cohort_start" "date" DEFAULT NULL::"date", "p_cohort_end" "date" DEFAULT NULL::"date", "p_currency" "text" DEFAULT NULL::"text") RETURNS TABLE("org_id" "uuid", "cohort_month" "date", "total_paid_cents" bigint, "subscription_months" integer, "avg_monthly_revenue_cents" integer, "currency" "text")
    LANGUAGE "plpgsql" STABLE
    AS $$
BEGIN
  RETURN QUERY
  WITH org_payments AS (
    SELECT
      bh.org_id,
      SUM(bh.amount) as total_paid,
      COUNT(DISTINCT DATE_TRUNC('month', bh.created_at)) as months_active,
      bh.currency
    FROM billing_history bh
    WHERE bh.status = 'paid'
      AND bh.event_type = 'payment'
      AND (p_currency IS NULL OR bh.currency = p_currency)
    GROUP BY bh.org_id, bh.currency
  ),
  org_cohorts AS (
    SELECT
      os.org_id,
      DATE_TRUNC('month', os.started_at)::DATE as cohort_month,
      os.currency
    FROM organization_subscriptions os
    WHERE (p_cohort_start IS NULL OR DATE_TRUNC('month', os.started_at)::DATE >= p_cohort_start)
      AND (p_cohort_end IS NULL OR DATE_TRUNC('month', os.started_at)::DATE <= p_cohort_end)
      AND (p_currency IS NULL OR os.currency = p_currency)
  )
  SELECT
    oc.org_id,
    oc.cohort_month,
    COALESCE(op.total_paid, 0) as total_paid_cents,
    COALESCE(op.months_active, 0)::INTEGER as subscription_months,
    CASE
      WHEN op.months_active > 0 THEN (op.total_paid / op.months_active)::INTEGER
      ELSE 0
    END as avg_monthly_revenue_cents,
    COALESCE(oc.currency, op.currency) as currency
  FROM org_cohorts oc
  LEFT JOIN org_payments op ON oc.org_id = op.org_id AND oc.currency = op.currency
  ORDER BY oc.cohort_month, oc.org_id;
END;
$$;

-- ALTER FUNCTION "public"."calculate_realized_ltv"("p_cohort_start" "date", "p_cohort_end" "date", "p_currency" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."calculate_realized_ltv"("p_cohort_start" "date", "p_cohort_end" "date", "p_currency" "text") IS 'Calculate realized lifetime value (based on actual payments)';

CREATE OR REPLACE FUNCTION "public"."calculate_seat_overage"("p_subscription_id" "uuid") RETURNS TABLE("active_seats" integer, "included_seats" integer, "overage_seats" integer, "overage_amount_cents" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  v_included_seats INTEGER;
  v_per_seat_price INTEGER;
  v_active_count INTEGER;
  v_org_id UUID;
BEGIN
  -- Get plan details and org_id
  SELECT sp.included_seats, sp.per_seat_price, os.org_id
  INTO v_included_seats, v_per_seat_price, v_org_id
  FROM organization_subscriptions os
  JOIN subscription_plans sp ON sp.id = os.plan_id
  WHERE os.id = p_subscription_id;

  -- Count active org members
  SELECT COUNT(*)::INTEGER
  INTO v_active_count
  FROM organization_memberships om
  WHERE om.org_id = v_org_id;

  RETURN QUERY
  SELECT
    v_active_count as active_seats,
    COALESCE(v_included_seats, 1) as included_seats,
    GREATEST(0, v_active_count - COALESCE(v_included_seats, 1)) as overage_seats,
    GREATEST(0, v_active_count - COALESCE(v_included_seats, 1)) * COALESCE(v_per_seat_price, 0) as overage_amount_cents;
END;
$$;

-- ALTER FUNCTION "public"."calculate_seat_overage"("p_subscription_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."calculate_seat_overage"("p_subscription_id" "uuid") IS 'Calculates seat overage and cost for a subscription';

CREATE OR REPLACE FUNCTION "public"."calculate_sentiment_trend"("p_company_id" "uuid", "p_contact_id" "uuid" DEFAULT NULL::"uuid") RETURNS numeric
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO ''
    AS $$
DECLARE
  v_avg_recent NUMERIC;
  v_avg_older NUMERIC;
BEGIN
  -- Get average sentiment from 3 most recent meetings (without ORDER BY in aggregate)
  SELECT AVG(sentiment_score) INTO v_avg_recent
  FROM (
    SELECT sentiment_score
    FROM meetings m
    WHERE m.company_id = p_company_id
      AND m.sentiment_score IS NOT NULL
      AND (p_contact_id IS NULL OR EXISTS (
        SELECT 1 FROM meeting_contacts mc
        WHERE mc.meeting_id = m.id AND mc.contact_id = p_contact_id
      ))
    ORDER BY m.meeting_start DESC
    LIMIT 3
  ) recent_meetings;

  -- Get average sentiment from 3 meetings before that (without ORDER BY in aggregate)
  SELECT AVG(sentiment_score) INTO v_avg_older
  FROM (
    SELECT sentiment_score
    FROM meetings m
    WHERE m.company_id = p_company_id
      AND m.sentiment_score IS NOT NULL
      AND (p_contact_id IS NULL OR EXISTS (
        SELECT 1 FROM meeting_contacts mc
        WHERE mc.meeting_id = m.id AND mc.contact_id = p_contact_id
      ))
    ORDER BY m.meeting_start DESC
    OFFSET 3
    LIMIT 3
  ) older_meetings;

  -- Return trend (positive = improving, negative = declining)
  IF v_avg_recent IS NULL OR v_avg_older IS NULL THEN
    RETURN 0; -- Not enough data
  END IF;

  RETURN v_avg_recent - v_avg_older;
END;
$$;

-- ALTER FUNCTION "public"."calculate_sentiment_trend"("p_company_id" "uuid", "p_contact_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."calculate_sentiment_trend"("p_company_id" "uuid", "p_contact_id" "uuid") IS 'Calculate sentiment trend by comparing recent vs older meetings';

CREATE OR REPLACE FUNCTION "public"."calculate_split_amount"("p_deal_id" "uuid", "p_percentage" numeric) RETURNS numeric
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  deal_value DECIMAL(12,2);
BEGIN
  SELECT value INTO deal_value FROM deals WHERE id = p_deal_id;
  RETURN COALESCE(deal_value, 0) * (p_percentage / 100);
END;
$$;

-- ALTER FUNCTION "public"."calculate_split_amount"("p_deal_id" "uuid", "p_percentage" numeric) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."calculate_token_cost"("p_provider" "text", "p_model" "text", "p_input_tokens" integer, "p_output_tokens" integer) RETURNS numeric
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  v_input_cost DECIMAL(10, 4);
  v_output_cost DECIMAL(10, 4);
  v_total_cost DECIMAL(10, 6);
BEGIN
  SELECT input_cost_per_million, output_cost_per_million
  INTO v_input_cost, v_output_cost
  FROM get_current_cost_rate(p_provider, p_model);

  IF v_input_cost IS NULL OR v_output_cost IS NULL THEN
    RETURN 0;
  END IF;

  v_total_cost := (p_input_tokens::DECIMAL / 1000000) * v_input_cost +
                  (p_output_tokens::DECIMAL / 1000000) * v_output_cost;

  RETURN v_total_cost;
END;
$$;

-- ALTER FUNCTION "public"."calculate_token_cost"("p_provider" "text", "p_model" "text", "p_input_tokens" integer, "p_output_tokens" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."calculate_topic_relevance_score"("p_frequency_score" numeric, "p_recency_score" numeric) RETURNS numeric
    LANGUAGE "plpgsql" IMMUTABLE
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Weighted combination: 40% frequency, 60% recency
  RETURN (p_frequency_score * 0.4) + (p_recency_score * 0.6);
END;
$$;

-- ALTER FUNCTION "public"."calculate_topic_relevance_score"("p_frequency_score" numeric, "p_recency_score" numeric) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."calculate_total_points"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Calculate total points
  -- Points = (referral_count * 5) + (linkedin ? 50 : 0) + (twitter ? 50 : 0)
  NEW.total_points := (COALESCE(NEW.referral_count, 0) * 5) +
                      (CASE WHEN NEW.linkedin_boost_claimed THEN 50 ELSE 0 END) +
                      (CASE WHEN NEW.twitter_boost_claimed THEN 50 ELSE 0 END);

  -- Recalculate effective position based on total points
  -- Formula: effective_position = MAX(1, signup_position - total_points)
  NEW.effective_position := GREATEST(1, NEW.signup_position - NEW.total_points);

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."calculate_total_points"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."calculate_trial_conversion_rate"("p_start_date" "date", "p_end_date" "date") RETURNS TABLE("period_start" "date", "period_end" "date", "trials_started" integer, "trials_converted" integer, "conversion_rate" numeric, "avg_trial_days" numeric)
    LANGUAGE "plpgsql" STABLE
    AS $$
BEGIN
  RETURN QUERY
  WITH trials AS (
    SELECT
      os.id,
      os.trial_start_at,
      os.trial_ends_at,
      os.status,
      CASE
        WHEN os.status = 'active' AND os.trial_ends_at IS NOT NULL THEN true
        ELSE false
      END as converted,
      EXTRACT(DAY FROM (os.trial_ends_at - os.trial_start_at)) as trial_days
    FROM organization_subscriptions os
    WHERE os.trial_start_at BETWEEN p_start_date AND p_end_date
      AND os.trial_start_at IS NOT NULL
  )
  SELECT
    p_start_date as period_start,
    p_end_date as period_end,
    COUNT(*)::INTEGER as trials_started,
    COUNT(*) FILTER (WHERE converted)::INTEGER as trials_converted,
    CASE
      WHEN COUNT(*) > 0 THEN (COUNT(*) FILTER (WHERE converted)::NUMERIC / COUNT(*)::NUMERIC * 100)
      ELSE 0
    END as conversion_rate,
    AVG(trial_days) as avg_trial_days
  FROM trials;
END;
$$;

-- ALTER FUNCTION "public"."calculate_trial_conversion_rate"("p_start_date" "date", "p_end_date" "date") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."calculate_trial_conversion_rate"("p_start_date" "date", "p_end_date" "date") IS 'Calculate trial conversion rate and average trial duration';

CREATE OR REPLACE FUNCTION "public"."calculate_waitlist_onboarding_completion"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Count completed steps
  NEW.completed_steps := (
    CASE WHEN NEW.account_created_at IS NOT NULL THEN 1 ELSE 0 END +
    CASE WHEN NEW.profile_completed_at IS NOT NULL THEN 1 ELSE 0 END +
    CASE WHEN NEW.first_meeting_synced_at IS NOT NULL THEN 1 ELSE 0 END +
    CASE WHEN NEW.meeting_intelligence_used_at IS NOT NULL THEN 1 ELSE 0 END +
    CASE WHEN NEW.crm_integrated_at IS NOT NULL THEN 1 ELSE 0 END +
    CASE WHEN NEW.team_invited_at IS NOT NULL THEN 1 ELSE 0 END
  );

  -- Calculate percentage
  NEW.completion_percentage := ROUND((NEW.completed_steps::FLOAT / NEW.total_steps::FLOAT) * 100);

  -- Update timestamp
  NEW.updated_at := now();

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."calculate_waitlist_onboarding_completion"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."calculate_waitlist_points"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  points INTEGER := 0;
BEGIN
  -- Base points from referrals (50 points per referral)
  points := points + (COALESCE(NEW.referral_count, 0) * 50);

  -- LinkedIn boost (50 points - matches UI "+50" badge)
  IF COALESCE(NEW.linkedin_boost_claimed, false) THEN
    points := points + 50;
  END IF;

  -- Twitter boost (50 points - matches UI "+50" badge)
  IF COALESCE(NEW.twitter_boost_claimed, false) THEN
    points := points + 50;
  END IF;

  -- LinkedIn share (25 points)
  IF COALESCE(NEW.linkedin_share_claimed, false) THEN
    points := points + 25;
  END IF;

  NEW.total_points := points;

  -- Also recalculate effective_position based on points
  -- Formula: MAX(1, signup_position - floor(total_points / 10))
  -- This means every 10 points = 1 spot forward
  IF NEW.signup_position IS NOT NULL THEN
    NEW.effective_position := GREATEST(1, NEW.signup_position - FLOOR(points / 10));
  END IF;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."calculate_waitlist_points"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."calculate_waitlist_points"() IS 'Calculates total gamification points: 50 per referral, 50 for social boosts (matches UI), 25 for shares. Position moves forward 1 spot per 10 points.';

CREATE OR REPLACE FUNCTION "public"."calculate_win_rate"("user_id" "uuid", "start_date" timestamp with time zone, "end_date" timestamp with time zone) RETURNS numeric
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  total_proposals numeric;
  won_deals numeric;
BEGIN
  SELECT COUNT(*) INTO total_proposals
  FROM activities
  WHERE activities.user_id = calculate_win_rate.user_id
  AND type = 'proposal'
  AND date BETWEEN start_date AND end_date;

  SELECT COUNT(*) INTO won_deals
  FROM activities
  WHERE activities.user_id = calculate_win_rate.user_id
  AND type = 'sale'
  AND date BETWEEN start_date AND end_date;

  IF total_proposals = 0 THEN
    RETURN 0;
  END IF;

  RETURN ROUND((won_deals / total_proposals) * 100, 2);
END;
$$;

-- ALTER FUNCTION "public"."calculate_win_rate"("user_id" "uuid", "start_date" timestamp with time zone, "end_date" timestamp with time zone) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."calculate_workflow_coverage"("p_checklist_results" "jsonb") RETURNS TABLE("total_items" integer, "covered_items" integer, "required_items" integer, "required_covered" integer, "coverage_score" numeric, "required_coverage_score" numeric, "missing_required" "text"[])
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_total INTEGER := 0;
  v_covered INTEGER := 0;
  v_required INTEGER := 0;
  v_required_covered INTEGER := 0;
  v_missing TEXT[] := '{}';
  v_item JSONB;
BEGIN
  -- Loop through checklist results
  FOR v_item IN SELECT * FROM jsonb_array_elements(p_checklist_results)
  LOOP
    v_total := v_total + 1;

    IF (v_item->>'covered')::boolean THEN
      v_covered := v_covered + 1;
    END IF;

    IF (v_item->>'required')::boolean THEN
      v_required := v_required + 1;
      IF (v_item->>'covered')::boolean THEN
        v_required_covered := v_required_covered + 1;
      ELSE
        v_missing := array_append(v_missing, v_item->>'label');
      END IF;
    END IF;
  END LOOP;

  total_items := v_total;
  covered_items := v_covered;
  required_items := v_required;
  required_covered := v_required_covered;
  coverage_score := CASE WHEN v_total > 0 THEN (v_covered::NUMERIC / v_total) * 100 ELSE 0 END;
  required_coverage_score := CASE WHEN v_required > 0 THEN (v_required_covered::NUMERIC / v_required) * 100 ELSE 100 END;
  missing_required := v_missing;

  RETURN NEXT;
END;
$$;

-- ALTER FUNCTION "public"."calculate_workflow_coverage"("p_checklist_results" "jsonb") OWNER TO "postgres";

-- ALTER FUNCTION "public"."call_auto_join_scheduler"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."call_auto_join_scheduler"() IS 'Calls the auto-join-scheduler edge function to deploy bots to upcoming meetings.
--Scheduled to run every 15 minutes via pg_cron.

--SETUP REQUIRED:
-- Add service_role_key to vault: Dashboard > Settings > Vault > New Secret
--   Name: service_role_key
--   Value: <your project service role key>
--
-- See: supabase/functions/auto-join-scheduler/index.ts

CREATE OR REPLACE FUNCTION "public"."call_suggest_next_actions_async"("p_activity_id" "uuid", "p_activity_type" "text", "p_user_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
     DECLARE
       edge_function_url TEXT;
       request_id BIGINT;
     BEGIN
       edge_function_url := get_system_config('supabase_url') || '/functions/v1/suggest-next-actions';

       SELECT net.http_post(
         url := edge_function_url,
         body := jsonb_build_object(
           'activityId', p_activity_id,
           'activityType', p_activity_type,
           'userId', p_user_id,
           'forceRegenerate', false
         ),
         params := '{}'::jsonb,
         headers := jsonb_build_object(
           'Content-Type', 'application/json',
           'Authorization', 'Bearer ' || get_system_config('service_role_key')
         ),
         timeout_milliseconds := 5000
       ) INTO request_id;

       RAISE NOTICE 'Queued next-action suggestion: activity=% type=% request_id=%',
         p_activity_id, p_activity_type, request_id;

     EXCEPTION WHEN OTHERS THEN
       RAISE WARNING 'Failed to queue next-action suggestion: %', SQLERRM;
     END;
     $$;

-- ALTER FUNCTION "public"."call_suggest_next_actions_async"("p_activity_id" "uuid", "p_activity_type" "text", "p_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."call_suggest_next_actions_async"("p_activity_id" "uuid", "p_activity_type" "text", "p_user_id" "uuid") IS 'Async suggestion generation for triggers. Fire and forget pattern.';

-- ALTER FUNCTION "public"."can_access_org_data"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."can_access_org_data"("p_org_id" "uuid") IS 'Checks if current user can READ data from the specified organization';

-- ALTER FUNCTION "public"."can_admin_org"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."can_admin_org"("p_org_id" "uuid") IS 'Checks if current user has admin rights in the organization (owner or admin)';

-- ALTER FUNCTION "public"."can_user_access_meeting_action_item"("p_action_item_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."can_user_access_meeting_action_item"("p_action_item_id" "uuid", "p_user_id" "uuid") IS 'Check if a user has access to a specific meeting action item';

-- ALTER FUNCTION "public"."can_write_to_org"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."can_write_to_org"("p_org_id" "uuid") IS 'Checks if current user can WRITE to the specified organization (owner, admin, or member)';

CREATE OR REPLACE FUNCTION "public"."cancel_stale_notifications"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_count INTEGER;
BEGIN
  WITH cancelled AS (
    UPDATE notification_queue
    SET status = 'cancelled'
    WHERE status IN ('pending', 'processing')
      AND (
        send_deadline < NOW()
        OR (status = 'processing' AND last_attempt_at < NOW() - INTERVAL '10 minutes')
        OR created_at < NOW() - INTERVAL '24 hours'
      )
    RETURNING 1
  )
  SELECT COUNT(*) INTO v_count FROM cancelled;

  RETURN v_count;
END;
$$;

-- ALTER FUNCTION "public"."cancel_stale_notifications"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."cancel_stale_notifications"() IS 'Cancel notifications that have passed their deadline';

-- ALTER FUNCTION "public"."check_cron_failures_and_notify"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."check_meeting_limits"("p_org_id" "uuid") RETURNS TABLE("is_free_tier" boolean, "max_meetings_per_month" integer, "new_meetings_used" integer, "historical_meetings" integer, "total_meetings" integer, "meetings_remaining" integer, "can_sync_new" boolean, "historical_cutoff_date" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_plan_is_free BOOLEAN := true;
  v_max_meetings INTEGER := 15;
  v_onboarding_completed TIMESTAMPTZ;
BEGIN
  -- Get plan info
  SELECT 
    COALESCE(sp.is_free_tier, true),
    COALESCE(os.custom_max_meetings, sp.max_meetings_per_month, 15)
  INTO v_plan_is_free, v_max_meetings
  FROM organization_subscriptions os
  JOIN subscription_plans sp ON sp.id = os.plan_id
  WHERE os.org_id = p_org_id
  AND os.status IN ('active', 'trialing');
  
  -- Get onboarding completion time
  SELECT o.onboarding_completed_at INTO v_onboarding_completed
  FROM organizations o
  WHERE o.id = p_org_id;
  
  RETURN QUERY
  SELECT
    v_plan_is_free as is_free_tier,
    v_max_meetings as max_meetings_per_month,
    -- Count new meetings (not historical imports, after onboarding)
    COALESCE((
      SELECT COUNT(*)::INTEGER 
      FROM meetings m 
      WHERE m.org_id = p_org_id 
      AND m.is_historical_import = false
    ), 0) as new_meetings_used,
    -- Count historical imports
    COALESCE((
      SELECT COUNT(*)::INTEGER 
      FROM meetings m 
      WHERE m.org_id = p_org_id 
      AND m.is_historical_import = true
    ), 0) as historical_meetings,
    -- Total meetings
    COALESCE((
      SELECT COUNT(*)::INTEGER 
      FROM meetings m 
      WHERE m.org_id = p_org_id
    ), 0) as total_meetings,
    -- Remaining (only matters for free tier)
    CASE 
      WHEN v_plan_is_free THEN 
        GREATEST(0, v_max_meetings - COALESCE((
          SELECT COUNT(*)::INTEGER 
          FROM meetings m 
          WHERE m.org_id = p_org_id 
          AND m.is_historical_import = false
        ), 0))
      ELSE -1 -- Unlimited
    END as meetings_remaining,
    -- Can sync new meetings?
    CASE 
      WHEN v_plan_is_free THEN 
        COALESCE((
          SELECT COUNT(*)::INTEGER 
          FROM meetings m 
          WHERE m.org_id = p_org_id 
          AND m.is_historical_import = false
        ), 0) < v_max_meetings
      ELSE true
    END as can_sync_new,
    -- Historical cutoff (30 days ago for free tier)
    CASE 
      WHEN v_plan_is_free THEN NOW() - INTERVAL '30 days'
      ELSE NULL -- No limit for paid
    END as historical_cutoff_date;
END;
$$;

-- ALTER FUNCTION "public"."check_meeting_limits"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."check_meeting_limits"("p_org_id" "uuid") IS 'Check meeting limits for an organization - returns usage and remaining quota';

CREATE OR REPLACE FUNCTION "public"."check_notification_floods"("p_alert_threshold" "text" DEFAULT 'MEDIUM'::"text") RETURNS json
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  flood_result JSON;
  critical_count INTEGER;
  high_count INTEGER;
  medium_count INTEGER;
  low_count INTEGER;
  total_affected_users INTEGER;
  flood_details JSONB;
BEGIN
  -- Count alerts by level
  SELECT
    COUNT(*) FILTER (WHERE alert_level = 'CRITICAL'),
    COUNT(*) FILTER (WHERE alert_level = 'HIGH'),
    COUNT(*) FILTER (WHERE alert_level = 'MEDIUM'),
    COUNT(*) FILTER (WHERE alert_level = 'LOW'),
    COUNT(*)
  INTO
    critical_count,
    high_count,
    medium_count,
    low_count,
    total_affected_users
  FROM notification_flood_alerts
  WHERE alert_level != 'NORMAL';

  -- Get detailed flood information
  SELECT jsonb_agg(flood_data)
  INTO flood_details
  FROM (
    SELECT jsonb_build_object(
      'user_id', user_id,
      'user_email', user_email,
      'alert_level', alert_level,
      'total_notifications', total_notifications,
      'unread_notifications', unread_notifications,
      'error_notifications', error_notifications,
      'last_hour', last_hour,
      'last_24_hours', last_24_hours,
      'alert_reason', alert_reason,
      'recommended_action', recommended_action
    ) as flood_data
    FROM notification_flood_alerts
    WHERE
      CASE p_alert_threshold
        WHEN 'CRITICAL' THEN alert_level = 'CRITICAL'
        WHEN 'HIGH' THEN alert_level IN ('CRITICAL', 'HIGH')
        WHEN 'MEDIUM' THEN alert_level IN ('CRITICAL', 'HIGH', 'MEDIUM')
        WHEN 'LOW' THEN alert_level IN ('CRITICAL', 'HIGH', 'MEDIUM', 'LOW')
        ELSE FALSE
      END
    ORDER BY
      CASE alert_level
        WHEN 'CRITICAL' THEN 1
        WHEN 'HIGH' THEN 2
        WHEN 'MEDIUM' THEN 3
        WHEN 'LOW' THEN 4
      END,
      last_24_hours DESC
  ) ordered_floods;

  -- Build result
  flood_result := json_build_object(
    'has_floods', (critical_count > 0 OR high_count > 0 OR medium_count > 0 OR low_count > 0),
    'flood_detected', critical_count > 0,
    'timestamp', NOW(),
    'summary', json_build_object(
      'critical_alerts', critical_count,
      'high_alerts', high_count,
      'medium_alerts', medium_count,
      'low_alerts', low_count,
      'total_affected_users', total_affected_users
    ),
    'severity', CASE
      WHEN critical_count > 0 THEN 'CRITICAL'
      WHEN high_count > 0 THEN 'HIGH'
      WHEN medium_count > 0 THEN 'MEDIUM'
      WHEN low_count > 0 THEN 'LOW'
      ELSE 'NORMAL'
    END,
    'requires_immediate_action', (critical_count > 0),
    'flood_details', COALESCE(flood_details, '[]'::jsonb),
    'recommended_actions', CASE
      WHEN critical_count > 0 THEN jsonb_build_array(
        'URGENT: Review notification_flood_alerts view immediately',
        'Investigate users with CRITICAL alert levels',
        'Check notification_type_breakdown for problematic notification types',
        'Consider emergency cleanup if flood is ongoing',
        'Review recent_notification_activity for patterns'
      )
      WHEN high_count > 0 THEN jsonb_build_array(
        'Review notification_flood_alerts for HIGH severity users',
        'Investigate notification patterns and sources',
        'Verify rate limiting is functioning correctly',
        'Monitor notification_rate_limit_status'
      )
      WHEN medium_count > 0 THEN jsonb_build_array(
        'Monitor users with MEDIUM alert levels',
        'Review notification_type_breakdown for common patterns',
        'Check if rate limits need adjustment'
      )
      WHEN low_count > 0 THEN jsonb_build_array(
        'Review users with LOW alert levels',
        'Monitor trends over time'
      )
      ELSE jsonb_build_array('No action needed - notification levels normal')
    END
  );

  RETURN flood_result;
END;
$$;

-- ALTER FUNCTION "public"."check_notification_floods"("p_alert_threshold" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."check_notification_floods"("p_alert_threshold" "text") IS 'Programmatically detect notification floods and return actionable alerts. Parameters: p_alert_threshold (CRITICAL|HIGH|MEDIUM|LOW) - minimum alert level to include in details. Returns: JSON with flood status, severity, affected users, and recommended actions.';

CREATE OR REPLACE FUNCTION "public"."check_rate_limit"("key_hash_val" "text") RETURNS TABLE("allowed" boolean, "current_usage" integer, "limit_value" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  api_key_record RECORD;
  usage_count INTEGER := 0;
BEGIN
  -- Get API key info
  SELECT INTO api_key_record
    ak.rate_limit,
    ak.is_active,
    ak.usage_count
  FROM api_keys ak
  WHERE ak.key_hash = key_hash_val;
  
  IF NOT FOUND OR NOT api_key_record.is_active THEN
    RETURN QUERY SELECT FALSE, 0, 0;
    RETURN;
  END IF;
  
  -- For testing purposes, always allow requests (permissive rate limiting)
  usage_count := COALESCE(api_key_record.usage_count, 0);
  
  -- Always return allowed = TRUE for testing
  RETURN QUERY SELECT TRUE, usage_count, api_key_record.rate_limit;
  
END $$;

-- ALTER FUNCTION "public"."check_rate_limit"("key_hash_val" "text") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."check_recording_quota"("p_org_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_usage recording_usage;
  v_period_start DATE;
BEGIN
  v_period_start := date_trunc('month', CURRENT_DATE)::DATE;

  SELECT * INTO v_usage
  FROM recording_usage
  WHERE org_id = p_org_id AND period_start = v_period_start;

  -- No usage record = under limit
  IF NOT FOUND THEN
    RETURN TRUE;
  END IF;

  -- Check against limit
  RETURN v_usage.recordings_count < v_usage.recordings_limit;
END;
$$;

-- ALTER FUNCTION "public"."check_recording_quota"("p_org_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."check_sentry_bridge_rate_limit"("p_org_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_config sentry_bridge_config;
  v_hourly_count INTEGER;
  v_daily_count INTEGER;
  v_allowed BOOLEAN := true;
  v_reason TEXT;
BEGIN
  SELECT * INTO v_config FROM sentry_bridge_config WHERE org_id = p_org_id;

  IF v_config IS NULL THEN
    RETURN jsonb_build_object('allowed', false, 'reason', 'No config found');
  END IF;

  -- Check circuit breaker
  IF v_config.circuit_breaker_tripped_at IS NOT NULL
     AND v_config.circuit_breaker_tripped_at + (v_config.circuit_breaker_cooldown_minutes * interval '1 minute') > now() THEN
    RETURN jsonb_build_object('allowed', false, 'reason', 'Circuit breaker tripped');
  END IF;

  -- Count tickets created in last hour
  SELECT COUNT(*) INTO v_hourly_count
  FROM sentry_bridge_queue
  WHERE org_id = p_org_id
    AND status = 'completed'
    AND processed_at > now() - interval '1 hour';

  IF v_hourly_count >= v_config.max_tickets_per_hour THEN
    RETURN jsonb_build_object('allowed', false, 'reason', 'Hourly rate limit exceeded', 'count', v_hourly_count);
  END IF;

  -- Count tickets created today
  SELECT COUNT(*) INTO v_daily_count
  FROM sentry_bridge_queue
  WHERE org_id = p_org_id
    AND status = 'completed'
    AND processed_at > date_trunc('day', now());

  IF v_daily_count >= v_config.max_tickets_per_day THEN
    RETURN jsonb_build_object('allowed', false, 'reason', 'Daily rate limit exceeded', 'count', v_daily_count);
  END IF;

  RETURN jsonb_build_object(
    'allowed', true,
    'hourly_count', v_hourly_count,
    'daily_count', v_daily_count
  );
END;
$$;

-- ALTER FUNCTION "public"."check_sentry_bridge_rate_limit"("p_org_id" "uuid") OWNER TO "postgres";

-- ALTER FUNCTION "public"."check_user_exists_by_email"("p_email" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."check_user_exists_by_email"("p_email" "text") IS 'Check if a user account already exists for the given email address (case-insensitive)';

CREATE OR REPLACE FUNCTION "public"."claim_notification_for_processing"("p_queue_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_updated INTEGER;
BEGIN
  UPDATE notification_queue
  SET
    status = 'processing',
    last_attempt_at = NOW(),
    attempts = attempts + 1
  WHERE id = p_queue_id
    AND status = 'pending'
  RETURNING 1 INTO v_updated;

  RETURN v_updated = 1;
END;
$$;

-- ALTER FUNCTION "public"."claim_notification_for_processing"("p_queue_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."claim_notification_for_processing"("p_queue_id" "uuid") IS 'Atomically claim a notification for sending';

CREATE OR REPLACE FUNCTION "public"."claim_waitlist_boost"("p_entry_id" "uuid", "p_platform" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_entry RECORD;
  v_new_total_points INTEGER;
  v_new_effective_position INTEGER;
  v_already_claimed BOOLEAN;
BEGIN
  -- Validate platform
  IF p_platform NOT IN ('twitter', 'linkedin', 'email') THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Invalid platform. Must be twitter, linkedin, or email.'
    );
  END IF;

  -- Fetch the entry with row lock to prevent race conditions
  SELECT
    id,
    signup_position,
    effective_position,
    total_points,
    referral_count,
    twitter_boost_claimed,
    linkedin_boost_claimed,
    email_boost_claimed
  INTO v_entry
  FROM meetings_waitlist
  WHERE id = p_entry_id
  FOR UPDATE;

  -- Check if entry exists
  IF v_entry.id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Entry not found'
    );
  END IF;

  -- Check if boost already claimed
  IF p_platform = 'twitter' THEN
    v_already_claimed := COALESCE(v_entry.twitter_boost_claimed, false);
  ELSIF p_platform = 'linkedin' THEN
    v_already_claimed := COALESCE(v_entry.linkedin_boost_claimed, false);
  ELSE
    v_already_claimed := COALESCE(v_entry.email_boost_claimed, false);
  END IF;

  IF v_already_claimed THEN
    RETURN json_build_object(
      'success', true,
      'boosted', false,
      'message', 'Boost already claimed',
      'entry', json_build_object(
        'total_points', v_entry.total_points,
        'effective_position', v_entry.effective_position,
        'twitter_boost_claimed', COALESCE(v_entry.twitter_boost_claimed, false),
        'linkedin_boost_claimed', COALESCE(v_entry.linkedin_boost_claimed, false),
        'email_boost_claimed', COALESCE(v_entry.email_boost_claimed, false)
      )
    );
  END IF;

  -- Calculate new total points
  -- Formula: (referrals * 5) + (twitter_boost ? 50 : 0) + (linkedin_boost ? 50 : 0) + (email_boost ? 50 : 0)
  v_new_total_points := COALESCE(v_entry.referral_count, 0) * 5;

  -- Add existing boosts
  IF COALESCE(v_entry.twitter_boost_claimed, false) THEN
    v_new_total_points := v_new_total_points + 50;
  END IF;
  IF COALESCE(v_entry.linkedin_boost_claimed, false) THEN
    v_new_total_points := v_new_total_points + 50;
  END IF;
  IF COALESCE(v_entry.email_boost_claimed, false) THEN
    v_new_total_points := v_new_total_points + 50;
  END IF;

  -- Add the NEW boost being claimed
  v_new_total_points := v_new_total_points + 50;

  -- Calculate new effective position
  -- Formula: MAX(1, signup_position - total_points)
  v_new_effective_position := GREATEST(1, COALESCE(v_entry.signup_position, v_entry.effective_position, 1) - v_new_total_points);

  -- Update the entry based on platform
  IF p_platform = 'twitter' THEN
    UPDATE meetings_waitlist
    SET
      twitter_boost_claimed = true,
      twitter_first_share_at = NOW(),
      total_points = v_new_total_points,
      effective_position = v_new_effective_position,
      updated_at = NOW()
    WHERE id = p_entry_id;
  ELSIF p_platform = 'linkedin' THEN
    UPDATE meetings_waitlist
    SET
      linkedin_boost_claimed = true,
      linkedin_first_share_at = NOW(),
      total_points = v_new_total_points,
      effective_position = v_new_effective_position,
      updated_at = NOW()
    WHERE id = p_entry_id;
  ELSE
    UPDATE meetings_waitlist
    SET
      email_boost_claimed = true,
      email_first_share_at = NOW(),
      total_points = v_new_total_points,
      effective_position = v_new_effective_position,
      updated_at = NOW()
    WHERE id = p_entry_id;
  END IF;

  -- Return success with updated values
  RETURN json_build_object(
    'success', true,
    'boosted', true,
    'entry', json_build_object(
      'total_points', v_new_total_points,
      'effective_position', v_new_effective_position,
      'twitter_boost_claimed', CASE WHEN p_platform = 'twitter' THEN true ELSE COALESCE(v_entry.twitter_boost_claimed, false) END,
      'linkedin_boost_claimed', CASE WHEN p_platform = 'linkedin' THEN true ELSE COALESCE(v_entry.linkedin_boost_claimed, false) END,
      'email_boost_claimed', CASE WHEN p_platform = 'email' THEN true ELSE COALESCE(v_entry.email_boost_claimed, false) END,
      'referral_count', COALESCE(v_entry.referral_count, 0)
    )
  );
END;
$$;

-- ALTER FUNCTION "public"."claim_waitlist_boost"("p_entry_id" "uuid", "p_platform" "text") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."clean_activity_fields"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
  BEGIN
    -- For non-outbound activities, clear outbound_type if set
    IF NEW.type IS NOT NULL AND NEW.type != 'outbound' THEN
      NEW.outbound_type := NULL;
    END IF;

    -- For non-meeting activities, clear meeting-specific flags  
    IF NEW.type IS NOT NULL AND NEW.type != 'meeting' THEN
      NEW.is_rebooking := FALSE;
      NEW.is_self_generated := FALSE;
    END IF;

    -- For non-proposal activities, clear proposal_date
    IF NEW.type IS NOT NULL AND NEW.type != 'proposal' THEN
      NEW.proposal_date := NULL;
    END IF;

    -- For non-sale activities, clear sale_date
    IF NEW.type IS NOT NULL AND NEW.type != 'sale' THEN
      NEW.sale_date := NULL;
    END IF;

    RETURN NEW;
  END;
  $$;

-- ALTER FUNCTION "public"."clean_activity_fields"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."cleanup_expired_calendar_channels"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  expired_count INTEGER;
BEGIN
  -- Mark expired channels as inactive
  UPDATE google_calendar_channels
  SET is_active = false,
      updated_at = NOW()
  WHERE is_active = true
    AND expiration_time < NOW();

  GET DIAGNOSTICS expired_count = ROW_COUNT;

  RETURN expired_count;
END;
$$;

-- ALTER FUNCTION "public"."cleanup_expired_calendar_channels"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."cleanup_expired_calendar_channels"() IS 'Marks expired Google Calendar webhook channels as inactive';

CREATE OR REPLACE FUNCTION "public"."cleanup_expired_fathom_oauth_states"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
  BEGIN
    DELETE FROM fathom_oauth_states
    WHERE expires_at < NOW();
  END;
  $$;

-- ALTER FUNCTION "public"."cleanup_expired_fathom_oauth_states"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."cleanup_expired_google_oauth_states"() RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  DELETE FROM google_oauth_states
  WHERE expires_at < NOW();
END;
$$;

-- ALTER FUNCTION "public"."cleanup_expired_google_oauth_states"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."cleanup_expired_google_tokens"() RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  UPDATE google_integrations
  SET is_active = false
  WHERE expires_at < NOW() AND is_active = true;
END;
$$;

-- ALTER FUNCTION "public"."cleanup_expired_google_tokens"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."cleanup_expired_hubspot_oauth_states"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  DELETE FROM public.hubspot_oauth_states
  WHERE expires_at < now();
END;
$$;

-- ALTER FUNCTION "public"."cleanup_expired_hubspot_oauth_states"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."cleanup_expired_justcall_oauth_states"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  DELETE FROM justcall_oauth_states
  WHERE expires_at < NOW();
END;
$$;

-- ALTER FUNCTION "public"."cleanup_expired_justcall_oauth_states"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."cleanup_expired_skill_outputs"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM skill_output_storage
  WHERE expires_at IS NOT NULL
    AND expires_at < now();

  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$;

-- ALTER FUNCTION "public"."cleanup_expired_skill_outputs"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."cleanup_expired_skill_outputs"() IS 'Cleans up skill outputs that have passed their TTL. Run periodically via CRON.';

CREATE OR REPLACE FUNCTION "public"."cleanup_notification_rate_limits"() RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- Delete records older than 24 hours
  DELETE FROM notification_rate_limits
  WHERE created_at < NOW() - INTERVAL '24 hours';

  GET DIAGNOSTICS deleted_count = ROW_COUNT;

  RAISE NOTICE 'Cleaned up % old notification rate limit records', deleted_count;

  RETURN deleted_count;
END;
$$;

-- ALTER FUNCTION "public"."cleanup_notification_rate_limits"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."cleanup_notification_rate_limits"() IS 'Remove rate limit records older than 24 hours. Should be called periodically (e.g., daily cron job).';

CREATE OR REPLACE FUNCTION "public"."cleanup_old_api_monitor_snapshots"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  DELETE FROM api_monitor_snapshots
  WHERE snapshot_time < NOW() - INTERVAL '7 days';
  
  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$;

-- ALTER FUNCTION "public"."cleanup_old_api_monitor_snapshots"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."cleanup_old_api_monitor_snapshots"() IS 'Deletes snapshots older than 7 days. Called by cron daily.';

CREATE OR REPLACE FUNCTION "public"."cleanup_old_cron_logs"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Delete logs older than 30 days
  DELETE FROM cron_job_logs
  WHERE created_at < NOW() - INTERVAL '30 days';

  RAISE NOTICE 'Cleaned up cron logs older than 30 days';
END;
$$;

-- ALTER FUNCTION "public"."cleanup_old_cron_logs"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."cleanup_old_cron_logs"() IS 'Removes cron job logs older than 30 days';

CREATE OR REPLACE FUNCTION "public"."cleanup_old_notifications"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
     BEGIN
       DELETE FROM public.notifications
       WHERE id IN (
         SELECT id FROM (
           SELECT id, ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY created_at DESC) as rn
           FROM public.notifications
           WHERE read = TRUE
         ) ranked
         WHERE rn > 100
       );
     END;
     $$;

-- ALTER FUNCTION "public"."cleanup_old_notifications"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."cleanup_old_rate_limits"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  DELETE FROM public.rate_limit
  WHERE created_at < NOW() - INTERVAL '24 hours';
END;
$$;

-- ALTER FUNCTION "public"."cleanup_old_rate_limits"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."cleanup_old_relationship_health_history"("days_to_keep_hourly" integer DEFAULT 7) RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  deleted_count INTEGER;
BEGIN
  -- Delete all but one snapshot per day for data older than days_to_keep_hourly
  WITH snapshots_to_keep AS (
    SELECT DISTINCT ON (relationship_health_id, snapshot_at::DATE) id
    FROM relationship_health_history
    WHERE snapshot_at < NOW() - (days_to_keep_hourly || ' days')::INTERVAL
    ORDER BY relationship_health_id, snapshot_at::DATE, snapshot_at DESC
  )
  DELETE FROM relationship_health_history
  WHERE snapshot_at < NOW() - (days_to_keep_hourly || ' days')::INTERVAL
    AND id NOT IN (SELECT id FROM snapshots_to_keep);

  GET DIAGNOSTICS deleted_count = ROW_COUNT;
  RETURN deleted_count;
END;
$$;

-- ALTER FUNCTION "public"."cleanup_old_relationship_health_history"("days_to_keep_hourly" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."cleanup_old_relationship_health_history"("days_to_keep_hourly" integer) IS 'Consolidates old snapshots to one per day to save space';

CREATE OR REPLACE FUNCTION "public"."clear_audit_context"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Clear all audit context variables
  PERFORM set_config('app.original_user_id', '', false);
  PERFORM set_config('app.impersonated_user_id', '', false);
  PERFORM set_config('app.is_impersonating', 'false', false);
END;
$$;

-- ALTER FUNCTION "public"."clear_audit_context"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."complete_sentry_bridge_item"("item_id" "uuid", "dev_hub_task_id" "text", "mapping_id" "uuid" DEFAULT NULL::"uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  UPDATE sentry_bridge_queue
  SET
    status = 'completed',
    processed_at = now(),
    locked_by = NULL,
    locked_at = NULL
  WHERE id = item_id;
END;
$$;

-- ALTER FUNCTION "public"."complete_sentry_bridge_item"("item_id" "uuid", "dev_hub_task_id" "text", "mapping_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."complete_transcript_retry_job"("p_meeting_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE fathom_transcript_retry_jobs
  SET
    status = 'completed',
    completed_at = NOW(),
    updated_at = NOW()
  WHERE meeting_id = p_meeting_id
    AND status IN ('pending', 'processing');
END;
$$;

-- ALTER FUNCTION "public"."complete_transcript_retry_job"("p_meeting_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."complete_transcript_retry_job"("p_meeting_id" "uuid") IS 'Mark retry job as completed when transcript is successfully fetched';

CREATE OR REPLACE FUNCTION "public"."compute_improvement_deltas"("p_improvement_id" "uuid") RETURNS TABLE("actual_delta_requests_per_day" integer, "actual_delta_error_rate" numeric, "actual_delta_requests_per_user_per_day" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_improvement api_monitor_improvements%ROWTYPE;
  v_before_total INTEGER;
  v_after_total INTEGER;
  v_before_error_rate NUMERIC(5, 2);
  v_after_error_rate NUMERIC(5, 2);
  v_before_avg_per_user NUMERIC(10, 2);
  v_after_avg_per_user NUMERIC(10, 2);
  v_days_before INTEGER;
  v_days_after INTEGER;
BEGIN
  -- Get improvement record
  SELECT * INTO v_improvement
  FROM api_monitor_improvements
  WHERE id = p_improvement_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Improvement not found: %', p_improvement_id;
  END IF;
  
  -- Calculate days in each window
  v_days_before := EXTRACT(EPOCH FROM (v_improvement.before_window_end - v_improvement.before_window_start)) / 86400;
  v_days_after := EXTRACT(EPOCH FROM (v_improvement.after_window_end - v_improvement.after_window_start)) / 86400;
  
  -- Get before totals (from daily rollups where user_id IS NULL = total)
  SELECT 
    COALESCE(SUM(total_requests), 0)::INTEGER,
    COALESCE(AVG(error_rate), 0)::NUMERIC(5, 2),
    COALESCE(AVG(total_requests), 0)::NUMERIC(10, 2)
  INTO v_before_total, v_before_error_rate, v_before_avg_per_user
  FROM api_monitor_rollups_daily
  WHERE date >= v_improvement.before_window_start::DATE
    AND date <= v_improvement.before_window_end::DATE
    AND user_id IS NULL;
  
  -- Get after totals
  SELECT 
    COALESCE(SUM(total_requests), 0)::INTEGER,
    COALESCE(AVG(error_rate), 0)::NUMERIC(5, 2),
    COALESCE(AVG(total_requests), 0)::NUMERIC(10, 2)
  INTO v_after_total, v_after_error_rate, v_after_avg_per_user
  FROM api_monitor_rollups_daily
  WHERE date >= v_improvement.after_window_start::DATE
    AND date <= v_improvement.after_window_end::DATE
    AND user_id IS NULL;
  
  -- Calculate per-user averages (from user-specific rollups)
  SELECT COALESCE(AVG(total_requests), 0)::NUMERIC(10, 2)
  INTO v_before_avg_per_user
  FROM api_monitor_rollups_daily
  WHERE date >= v_improvement.before_window_start::DATE
    AND date <= v_improvement.before_window_end::DATE
    AND user_id IS NOT NULL;
  
  SELECT COALESCE(AVG(total_requests), 0)::NUMERIC(10, 2)
  INTO v_after_avg_per_user
  FROM api_monitor_rollups_daily
  WHERE date >= v_improvement.after_window_start::DATE
    AND date <= v_improvement.after_window_end::DATE
    AND user_id IS NOT NULL;
  
  -- Normalize to per-day
  IF v_days_before > 0 THEN
    v_before_total := (v_before_total::NUMERIC / v_days_before)::INTEGER;
    v_before_avg_per_user := v_before_avg_per_user / v_days_before;
  END IF;
  
  IF v_days_after > 0 THEN
    v_after_total := (v_after_total::NUMERIC / v_days_after)::INTEGER;
    v_after_avg_per_user := v_after_avg_per_user / v_days_after;
  END IF;
  
  -- Return deltas
  RETURN QUERY SELECT
    (v_after_total - v_before_total)::INTEGER,
    (v_after_error_rate - v_before_error_rate)::NUMERIC(5, 2),
    (v_after_avg_per_user - v_before_avg_per_user)::NUMERIC(10, 2);
END;
$$;

-- ALTER FUNCTION "public"."compute_improvement_deltas"("p_improvement_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."compute_improvement_deltas"("p_improvement_id" "uuid") IS 'Computes actual deltas for an improvement by comparing rollups before/after shipped_at.';

-- ALTER FUNCTION "public"."create_api_key"("key_name" "text", "user_uuid" "uuid", "permissions_json" "jsonb", "rate_limit_val" integer, "expires_days" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."create_clerk_user_mapping"("p_clerk_user_id" "text", "p_supabase_user_id" "uuid", "p_email" "text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  INSERT INTO clerk_user_mappings (clerk_user_id, supabase_user_id, email)
  VALUES (p_clerk_user_id, p_supabase_user_id, p_email)
  ON CONFLICT (clerk_user_id) DO UPDATE SET
    supabase_user_id = EXCLUDED.supabase_user_id,
    email = EXCLUDED.email,
    updated_at = NOW();

  RETURN TRUE;
EXCEPTION WHEN OTHERS THEN
  RETURN FALSE;
END;
$$;

-- ALTER FUNCTION "public"."create_clerk_user_mapping"("p_clerk_user_id" "text", "p_supabase_user_id" "uuid", "p_email" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."create_clerk_user_mapping"("p_clerk_user_id" "text", "p_supabase_user_id" "uuid", "p_email" "text") IS 'Creates or updates a mapping between a Clerk user ID and Supabase profile UUID';

CREATE OR REPLACE FUNCTION "public"."create_client_from_won_deal"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
  BEGIN
      IF NEW.status = 'won' AND (OLD.status IS NULL OR OLD.status != 'won') THEN
          -- Check if client already exists for this deal
          IF NOT EXISTS (SELECT 1 FROM clients WHERE deal_id = NEW.id) THEN
              INSERT INTO clients (
                  id,
                  company_name,
                  contact_name,
                  contact_email,
                  subscription_amount,
                  status,
                  deal_id,
                  owner_id,
                  subscription_start_date,
                  created_at,
                  updated_at
              ) VALUES (
                  gen_random_uuid(),
                  NEW.company,
                  NEW.contact_name,
                  NEW.contact_email,
                  COALESCE(NEW.monthly_mrr, 0),
                  'active'::client_status,
                  NEW.id,
                  NEW.owner_id,
                  COALESCE(NEW.expected_close_date, NEW.stage_changed_at, NOW()),
                  NOW(),
                  NOW()
              );
          END IF;
      END IF;
      RETURN NEW;
  END;
  $$;

-- ALTER FUNCTION "public"."create_client_from_won_deal"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."create_default_email_categorization_settings"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  INSERT INTO org_email_categorization_settings (org_id, is_enabled, label_mode)
  VALUES (NEW.id, true, 'mode_a_internal_only')
  ON CONFLICT (org_id) DO NOTHING;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."create_default_email_categorization_settings"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."create_default_org_proposal_workflows"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  -- Insert default workflows
  INSERT INTO org_proposal_workflows (org_id, name, description, include_goals, include_sow, include_html, include_email, include_markdown, display_order, is_default)
  VALUES
    (NEW.id, 'Full Proposal', 'Complete proposal with goals, SOW, and presentation', true, true, true, false, false, 1, true),
    (NEW.id, 'Quick Follow-up Email', 'Fast post-meeting follow-up email', false, false, false, true, false, 2, false),
    (NEW.id, 'Client Summary', 'Clean markdown summary document', true, false, false, false, true, 3, false);
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."create_default_org_proposal_workflows"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."create_default_recording_rules"("p_org_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  -- Only create if no rules exist
  IF NOT EXISTS (SELECT 1 FROM recording_rules WHERE org_id = p_org_id) THEN
    -- Default rule: Record all external meetings with 2+ attendees
    INSERT INTO recording_rules (
      org_id,
      name,
      is_active,
      priority,
      domain_mode,
      min_attendee_count,
      title_keywords_exclude
    ) VALUES (
      p_org_id,
      'Record external meetings',
      true,
      100,
      'external_only',
      2,
      ARRAY['internal', '1:1', 'standup', 'stand-up', 'sync']
    );
  END IF;
END;
$$;

-- ALTER FUNCTION "public"."create_default_recording_rules"("p_org_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."create_hitl_approval"("p_org_id" "uuid", "p_user_id" "uuid", "p_resource_type" "text", "p_resource_id" "text", "p_resource_name" "text", "p_slack_team_id" "text", "p_slack_channel_id" "text", "p_slack_message_ts" "text", "p_original_content" "jsonb", "p_callback_type" "text" DEFAULT NULL::"text", "p_callback_target" "text" DEFAULT NULL::"text", "p_callback_metadata" "jsonb" DEFAULT '{}'::"jsonb", "p_expires_hours" integer DEFAULT 24, "p_created_by" "uuid" DEFAULT NULL::"uuid", "p_slack_thread_ts" "text" DEFAULT NULL::"text", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_approval_id UUID;
BEGIN
  INSERT INTO hitl_pending_approvals (
    org_id, user_id, created_by, resource_type, resource_id, resource_name,
    slack_team_id, slack_channel_id, slack_message_ts, slack_thread_ts,
    original_content, callback_type, callback_target, callback_metadata,
    expires_at, metadata
  ) VALUES (
    p_org_id, p_user_id, p_created_by, p_resource_type, p_resource_id, p_resource_name,
    p_slack_team_id, p_slack_channel_id, p_slack_message_ts, p_slack_thread_ts,
    p_original_content, p_callback_type, p_callback_target, p_callback_metadata,
    now() + (p_expires_hours || ' hours')::INTERVAL, p_metadata
  )
  RETURNING id INTO v_approval_id;

  RETURN v_approval_id;
END;
$$;

-- ALTER FUNCTION "public"."create_hitl_approval"("p_org_id" "uuid", "p_user_id" "uuid", "p_resource_type" "text", "p_resource_id" "text", "p_resource_name" "text", "p_slack_team_id" "text", "p_slack_channel_id" "text", "p_slack_message_ts" "text", "p_original_content" "jsonb", "p_callback_type" "text", "p_callback_target" "text", "p_callback_metadata" "jsonb", "p_expires_hours" integer, "p_created_by" "uuid", "p_slack_thread_ts" "text", "p_metadata" "jsonb") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."create_onboarding_progress_for_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Create onboarding progress record for new user
  INSERT INTO public.user_onboarding_progress (user_id, onboarding_step)
  VALUES (NEW.id, 'welcome')
  ON CONFLICT (user_id) DO NOTHING;

  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  -- Log error but don't fail the profile creation
  RAISE WARNING 'create_onboarding_progress_for_new_user failed for %: %', NEW.id, SQLERRM;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."create_onboarding_progress_for_new_user"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."create_org_admin_notification"("p_org_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_action_url" "text" DEFAULT NULL::"text", "p_action_text" "text" DEFAULT NULL::"text", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS SETOF "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  v_user_id UUID;
  v_notification_id UUID;
BEGIN
  -- Create notification for all org owners and admins
  FOR v_user_id IN
    SELECT om.user_id
    FROM organization_memberships om
    WHERE om.org_id = p_org_id
    AND om.role IN ('owner', 'admin')
  LOOP
    INSERT INTO user_notifications (user_id, org_id, type, title, message, action_url, action_text, metadata)
    VALUES (v_user_id, p_org_id, p_type, p_title, p_message, p_action_url, p_action_text, p_metadata)
    RETURNING id INTO v_notification_id;

    RETURN NEXT v_notification_id;
  END LOOP;
  RETURN;
END;
$$;

-- ALTER FUNCTION "public"."create_org_admin_notification"("p_org_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_action_url" "text", "p_action_text" "text", "p_metadata" "jsonb") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."create_org_admin_notification"("p_org_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_action_url" "text", "p_action_text" "text", "p_metadata" "jsonb") IS 'Creates notifications for org owners and admins';

CREATE OR REPLACE FUNCTION "public"."create_org_for_new_user"("p_user_id" "uuid", "p_org_name" "text", "p_user_email" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_org_id UUID;
  v_clean_name TEXT;
BEGIN
  -- Clean and validate org name
  v_clean_name := TRIM(p_org_name);
  IF v_clean_name IS NULL OR LENGTH(v_clean_name) < 1 THEN
    -- Default to email domain or 'My Organization'
    IF p_user_email IS NOT NULL AND p_user_email LIKE '%@%' THEN
      v_clean_name := INITCAP(SPLIT_PART(p_user_email, '@', 2));
    ELSE
      v_clean_name := 'My Organization';
    END IF;
  END IF;

  -- Create the organization
  INSERT INTO organizations (name, created_by, is_active)
  VALUES (v_clean_name, p_user_id, true)
  RETURNING id INTO v_org_id;

  -- Add user as owner
  INSERT INTO organization_memberships (org_id, user_id, role)
  VALUES (v_org_id, p_user_id, 'owner');

  RETURN v_org_id;
END;
$$;

-- ALTER FUNCTION "public"."create_org_for_new_user"("p_user_id" "uuid", "p_org_name" "text", "p_user_email" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."create_org_for_new_user"("p_user_id" "uuid", "p_org_name" "text", "p_user_email" "text") IS 'Creates a new organization for a user during signup';

CREATE OR REPLACE FUNCTION "public"."create_profile_for_clerk_user"("p_clerk_user_id" "text", "p_email" "text", "p_full_name" "text" DEFAULT NULL::"text", "p_first_name" "text" DEFAULT NULL::"text", "p_last_name" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  v_profile_id UUID;
  v_display_name TEXT;
BEGIN
  -- Generate a new UUID for the profile
  v_profile_id := gen_random_uuid();

  -- Determine display name
  v_display_name := COALESCE(
    p_full_name,
    NULLIF(TRIM(COALESCE(p_first_name, '') || ' ' || COALESCE(p_last_name, '')), ''),
    split_part(p_email, '@', 1)
  );

  -- Create the profile
  INSERT INTO profiles (
    id,
    email,
    full_name,
    clerk_user_id,
    auth_provider,
    created_at,
    updated_at
  ) VALUES (
    v_profile_id,
    p_email,
    v_display_name,
    p_clerk_user_id,
    'clerk',
    NOW(),
    NOW()
  );

  -- Create the mapping
  PERFORM create_clerk_user_mapping(p_clerk_user_id, v_profile_id, p_email);

  RETURN v_profile_id;
END;
$$;

-- ALTER FUNCTION "public"."create_profile_for_clerk_user"("p_clerk_user_id" "text", "p_email" "text", "p_full_name" "text", "p_first_name" "text", "p_last_name" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."create_profile_for_clerk_user"("p_clerk_user_id" "text", "p_email" "text", "p_full_name" "text", "p_first_name" "text", "p_last_name" "text") IS 'Creates a new profile for a Clerk user and adds the mapping';

CREATE OR REPLACE FUNCTION "public"."create_relationship_health_snapshot"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  previous_snapshot RECORD;
  changes JSONB;
BEGIN
  -- Get previous snapshot
  SELECT * INTO previous_snapshot
  FROM relationship_health_history
  WHERE relationship_health_id = NEW.id
  ORDER BY snapshot_at DESC
  LIMIT 1;

  -- Calculate changes
  IF previous_snapshot IS NOT NULL THEN
    changes := jsonb_build_object(
      'overall_health_score_delta', NEW.overall_health_score - previous_snapshot.overall_health_score,
      'status_changed', NEW.health_status <> previous_snapshot.health_status,
      'ghost_risk_changed', NEW.is_ghost_risk <> previous_snapshot.is_ghost_risk,
      'previous_status', previous_snapshot.health_status,
      'new_status', NEW.health_status
    );
  ELSE
    changes := jsonb_build_object(
      'initial_snapshot', true,
      'status', NEW.health_status
    );
  END IF;

  -- Determine snapshot reason
  DECLARE
    reason TEXT;
  BEGIN
    IF previous_snapshot IS NULL THEN
      reason := 'scheduled';
    ELSIF ABS(NEW.overall_health_score - previous_snapshot.overall_health_score) >= 15 THEN
      reason := 'major_change';
    ELSIF NEW.is_ghost_risk = TRUE AND previous_snapshot.is_ghost_risk = FALSE THEN
      reason := 'ghost_detected';
    ELSIF NEW.is_ghost_risk = FALSE AND previous_snapshot.is_ghost_risk = TRUE THEN
      reason := 'recovery';
    ELSE
      reason := 'scheduled';
    END IF;

    -- Insert snapshot
    INSERT INTO relationship_health_history (
      relationship_health_id,
      user_id,
      overall_health_score,
      health_status,
      communication_frequency_score,
      response_behavior_score,
      engagement_quality_score,
      sentiment_score,
      meeting_pattern_score,
      is_ghost_risk,
      ghost_probability_percent,
      snapshot_at,
      snapshot_reason,
      changes_from_previous
    ) VALUES (
      NEW.id,
      NEW.user_id,
      NEW.overall_health_score,
      NEW.health_status,
      NEW.communication_frequency_score,
      NEW.response_behavior_score,
      NEW.engagement_quality_score,
      NEW.sentiment_score,
      NEW.meeting_pattern_score,
      NEW.is_ghost_risk,
      NEW.ghost_probability_percent,
      NOW(),
      reason,
      changes
    );
  END;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."create_relationship_health_snapshot"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."create_relationship_health_snapshot"() IS 'Auto-creates history snapshots when relationship health scores are updated';

CREATE OR REPLACE FUNCTION "public"."create_smart_tasks"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Only create tasks if the activity has a deal_id
  IF NEW.deal_id IS NULL THEN
    RETURN NEW;
  END IF;

  INSERT INTO tasks (
    title,
    description,
    due_date,
    task_type,
    priority,
    assigned_to,
    deal_id,
    created_by,
    status,
    clerk_org_id
  )
  SELECT
    stt.task_title,
    COALESCE(stt.task_description, '') ||
      E'\n\nAuto-generated from ' || NEW.type || ' activity on ' || TO_CHAR(NEW.created_at, 'YYYY-MM-DD'),
    (NEW.created_at::DATE + stt.days_after_trigger),
    stt.task_type,
    stt.priority,
    NEW.user_id,
    NEW.deal_id,
    NEW.user_id,
    'pending',
    NEW.clerk_org_id
  FROM smart_task_templates stt
  WHERE stt.trigger_activity_type = NEW.type
    AND stt.is_active = true
    -- Allow global templates (NULL/empty clerk_org_id) + org-specific overrides
    AND (
      COALESCE(stt.clerk_org_id, '') = ''
      OR (NEW.clerk_org_id IS NOT NULL AND stt.clerk_org_id = NEW.clerk_org_id)
    );

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."create_smart_tasks"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."create_smart_tasks"() IS 'Creates follow-up tasks from smart_task_templates after activities insert. Uses clerk_org_id when available; allows global templates (NULL/empty clerk_org_id) and org-specific overrides.';

CREATE OR REPLACE FUNCTION "public"."create_task_creation_notification"("p_user_id" "uuid", "p_meeting_id" "uuid", "p_meeting_title" "text", "p_task_count" integer, "p_task_ids" "uuid"[]) RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  v_notification_id UUID;
  v_title TEXT;
  v_message TEXT;
BEGIN
  -- Build notification title and message
  v_title := p_task_count || ' task' || (CASE WHEN p_task_count > 1 THEN 's' ELSE '' END) || ' created';
  v_message := 'AI generated ' || p_task_count || ' task' || (CASE WHEN p_task_count > 1 THEN 's' ELSE '' END) ||
               ' from meeting: ' || p_meeting_title;

  -- Insert notification
  INSERT INTO task_notifications (
    user_id,
    meeting_id,
    notification_type,
    title,
    message,
    task_count,
    metadata,
    read,
    created_at
  ) VALUES (
    p_user_id,
    p_meeting_id,
    'tasks_created',
    v_title,
    v_message,
    p_task_count,
    jsonb_build_object(
      'task_ids', p_task_ids,
      'meeting_title', p_meeting_title,
      'source', 'ai_auto_creation'
    ),
    false,
    NOW()
  )
  RETURNING id INTO v_notification_id;

  RETURN v_notification_id;
END;
$$;

-- ALTER FUNCTION "public"."create_task_creation_notification"("p_user_id" "uuid", "p_meeting_id" "uuid", "p_meeting_title" "text", "p_task_count" integer, "p_task_ids" "uuid"[]) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."create_task_creation_notification"("p_user_id" "uuid", "p_meeting_id" "uuid", "p_meeting_title" "text", "p_task_count" integer, "p_task_ids" "uuid"[]) IS 'Creates notification when tasks are auto-created from AI suggestions';

CREATE OR REPLACE FUNCTION "public"."create_task_notification"("p_user_id" "uuid", "p_task_id" "uuid", "p_title" "text", "p_message" "text", "p_type" "text", "p_action_url" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  notification_id UUID;
  can_create BOOLEAN;
  notification_type_key TEXT;
BEGIN
  -- Build notification type key for rate limiting
  -- Format: "type_category" (e.g., "error_task", "warning_task", "info_task")
  notification_type_key := CONCAT(p_type, '_task');

  -- Check rate limits before creating notification
  -- Default limits: 10 per hour, 50 per day
  can_create := should_create_notification(
    p_user_id,
    notification_type_key,
    10,  -- max per hour
    50   -- max per day
  );

  -- If rate limit exceeded, log and return NULL
  IF NOT can_create THEN
    RAISE NOTICE 'Rate limit exceeded for user % notification type %. Notification not created: "%"',
      p_user_id, notification_type_key, p_title;
    RETURN NULL;
  END IF;

  -- Rate limit OK, create notification
  INSERT INTO notifications (
    user_id,
    title,
    message,
    type,
    category,
    entity_type,
    entity_id,
    action_url,
    read,
    created_at
  ) VALUES (
    p_user_id,
    p_title,
    p_message,
    p_type,
    'task',
    'task',
    p_task_id,
    COALESCE(p_action_url, CONCAT('/crm/tasks?task_id=', p_task_id)),
    FALSE,
    NOW()
  )
  RETURNING id INTO notification_id;

  RETURN notification_id;
END;
$$;

-- ALTER FUNCTION "public"."create_task_notification"("p_user_id" "uuid", "p_task_id" "uuid", "p_title" "text", "p_message" "text", "p_type" "text", "p_action_url" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."create_task_notification"("p_user_id" "uuid", "p_task_id" "uuid", "p_title" "text", "p_message" "text", "p_type" "text", "p_action_url" "text") IS 'Helper function to create task-related notifications. RATE LIMITED: Max 10 per hour, 50 per day per user per notification type. Returns notification ID on success, NULL if rate limit exceeded.';

CREATE OR REPLACE FUNCTION "public"."create_waitlist_email_invite"("p_entry_id" "uuid", "p_email" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $_$
DECLARE
  v_entry RECORD;
  v_existing_invite RECORD;
  v_new_invite_id UUID;
  v_email_lower TEXT;
BEGIN
  -- Normalize email
  v_email_lower := LOWER(TRIM(p_email));

  -- Validate email format (basic check)
  IF v_email_lower !~ '^[^@\s]+@[^@\s]+\.[^@\s]+$' THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Invalid email format'
    );
  END IF;

  -- Check if entry exists
  SELECT id, referral_count, total_points, signup_position, effective_position
  INTO v_entry
  FROM meetings_waitlist
  WHERE id = p_entry_id;

  IF v_entry.id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Entry not found'
    );
  END IF;

  -- Check if email already invited by this entry
  SELECT id INTO v_existing_invite
  FROM waitlist_email_invites
  WHERE waitlist_entry_id = p_entry_id
    AND email = v_email_lower;

  IF v_existing_invite.id IS NOT NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'This email has already been invited'
    );
  END IF;

  -- Create the invite record
  INSERT INTO waitlist_email_invites (
    waitlist_entry_id,
    email,
    invite_status
  ) VALUES (
    p_entry_id,
    v_email_lower,
    'sent'
  )
  RETURNING id INTO v_new_invite_id;

  -- Award points for the invite (5 points per email)
  UPDATE meetings_waitlist
  SET
    referral_count = COALESCE(referral_count, 0) + 1,
    total_points = COALESCE(total_points, 0) + 5,
    effective_position = GREATEST(1, COALESCE(signup_position, effective_position, 1) - (COALESCE(total_points, 0) + 5)),
    updated_at = NOW()
  WHERE id = p_entry_id;

  -- Return success with updated values
  RETURN json_build_object(
    'success', true,
    'invite_id', v_new_invite_id,
    'email', v_email_lower,
    'entry', json_build_object(
      'total_points', COALESCE(v_entry.total_points, 0) + 5,
      'effective_position', GREATEST(1, COALESCE(v_entry.signup_position, v_entry.effective_position, 1) - (COALESCE(v_entry.total_points, 0) + 5)),
      'referral_count', COALESCE(v_entry.referral_count, 0) + 1
    )
  );
END;
$_$;

-- ALTER FUNCTION "public"."create_waitlist_email_invite"("p_entry_id" "uuid", "p_email" "text") OWNER TO "postgres";

-- ALTER FUNCTION "public"."current_user_id"() OWNER TO "postgres";

-- ALTER FUNCTION "public"."current_user_orgs"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."current_user_orgs"("p_user_id" "uuid") RETURNS TABLE("org_id" "uuid")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT om.org_id
  FROM organization_memberships om
  WHERE om.user_id = p_user_id;
END;
$$;

-- ALTER FUNCTION "public"."current_user_orgs"("p_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."current_user_orgs"("p_user_id" "uuid") IS 'Returns all organization IDs for a given user';

CREATE OR REPLACE FUNCTION "public"."custom_auth_uid"() RETURNS "uuid"
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO ''
    AS $_$
DECLARE
  clerk_uuid UUID;
  jwt_sub TEXT;
BEGIN
  -- Strategy 1: Try Clerk (if clerk_user_id in JWT sub)
  clerk_uuid := get_user_uuid_from_clerk();
  IF clerk_uuid IS NOT NULL THEN
    RETURN clerk_uuid;
  END IF;

  -- Strategy 2: Try Supabase Auth (original behavior)
  BEGIN
    jwt_sub := current_setting('request.jwt.claims', true)::json->>'sub';

    -- If JWT sub is UUID format, it's Supabase Auth
    IF jwt_sub IS NOT NULL AND jwt_sub ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' THEN
      RETURN jwt_sub::uuid;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      NULL;
  END;

  -- No valid auth found
  RETURN NULL;
END;
$_$;

-- ALTER FUNCTION "public"."custom_auth_uid"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."custom_auth_uid"() IS 'Returns user UUID - supports both Clerk and Supabase Auth';

SET default_tablespace = '';

SET default_table_access_method = "heap";

CREATE TABLE IF NOT EXISTS "public"."sentry_bridge_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "webhook_event_id" "uuid" NOT NULL,
    "sentry_issue_id" "text" NOT NULL,
    "sentry_event_id" "text" NOT NULL,
    "event_type" "text" NOT NULL,
    "target_dev_hub_project_id" "text" NOT NULL,
    "target_owner_user_id" "uuid",
    "target_priority" "text" DEFAULT 'medium'::"text" NOT NULL,
    "routing_rule_id" "uuid",
    "ticket_payload" "jsonb" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "attempt_count" integer DEFAULT 0 NOT NULL,
    "max_attempts" integer DEFAULT 3 NOT NULL,
    "next_attempt_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "last_error" "text",
    "locked_by" "text",
    "locked_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "processed_at" timestamp with time zone,
    CONSTRAINT "sentry_bridge_queue_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text", 'dlq'::"text"])))
);

-- ALTER TABLE "public"."sentry_bridge_queue" OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."dequeue_sentry_bridge_item"("batch_size" integer DEFAULT 1, "lock_duration_seconds" integer DEFAULT 300) RETURNS SETOF "public"."sentry_bridge_queue"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_worker_id TEXT;
BEGIN
  -- Generate a unique worker ID for this batch
  v_worker_id := 'worker-' || gen_random_uuid()::text;

  RETURN QUERY
  UPDATE sentry_bridge_queue
  SET
    status = 'processing',
    locked_by = v_worker_id,
    locked_at = now(),
    attempt_count = attempt_count + 1
  WHERE id IN (
    SELECT id FROM sentry_bridge_queue
    WHERE status = 'pending'
      AND next_attempt_at <= now()
    ORDER BY created_at ASC
    LIMIT batch_size
    FOR UPDATE SKIP LOCKED
  )
  RETURNING *;
END;
$$;

-- ALTER FUNCTION "public"."dequeue_sentry_bridge_item"("batch_size" integer, "lock_duration_seconds" integer) OWNER TO "postgres";

-- ALTER FUNCTION "public"."dismiss_next_action_suggestion"("p_suggestion_id" "uuid", "p_feedback" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."dismiss_next_action_suggestion"("p_suggestion_id" "uuid", "p_feedback" "text") IS 'Dismiss an AI suggestion with optional feedback';

CREATE OR REPLACE FUNCTION "public"."enqueue_hubspot_contact_outbound"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_org_id uuid;
BEGIN
  IF NEW.clerk_org_id IS NULL THEN
    RETURN NEW;
  END IF;

  SELECT i.org_id
    INTO v_org_id
  FROM public.hubspot_org_integrations i
  WHERE i.clerk_org_id = NEW.clerk_org_id
    AND i.is_active = true
    AND i.is_connected = true
  LIMIT 1;

  IF v_org_id IS NULL THEN
    RETURN NEW;
  END IF;

  INSERT INTO public.hubspot_sync_queue (
    org_id, clerk_org_id, job_type, priority, run_after, attempts, max_attempts, payload, dedupe_key
  )
  VALUES (
    v_org_id, NEW.clerk_org_id, 'sync_contact', 20, now(), 0, 10,
    jsonb_build_object('sixty_contact_id', NEW.id, 'source', 'db_trigger'),
    'contact_out:' || NEW.id
  )
  ON CONFLICT (org_id, dedupe_key) DO UPDATE SET
    run_after = EXCLUDED.run_after,
    payload = EXCLUDED.payload,
    attempts = 0,
    last_error = NULL,
    updated_at = now();

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."enqueue_hubspot_contact_outbound"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."enqueue_hubspot_deal_outbound"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_org_id uuid;
BEGIN
  IF NEW.clerk_org_id IS NULL THEN
    RETURN NEW;
  END IF;

  SELECT i.org_id
    INTO v_org_id
  FROM public.hubspot_org_integrations i
  WHERE i.clerk_org_id = NEW.clerk_org_id
    AND i.is_active = true
    AND i.is_connected = true
  LIMIT 1;

  IF v_org_id IS NULL THEN
    RETURN NEW;
  END IF;

  INSERT INTO public.hubspot_sync_queue (
    org_id, clerk_org_id, job_type, priority, run_after, attempts, max_attempts, payload, dedupe_key
  )
  VALUES (
    v_org_id, NEW.clerk_org_id, 'sync_deal', 20, now(), 0, 10,
    jsonb_build_object('sixty_deal_id', NEW.id, 'source', 'db_trigger'),
    'deal_out:' || NEW.id
  )
  ON CONFLICT (org_id, dedupe_key) DO UPDATE SET
    run_after = EXCLUDED.run_after,
    payload = EXCLUDED.payload,
    attempts = 0,
    last_error = NULL,
    updated_at = now();

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."enqueue_hubspot_deal_outbound"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."enqueue_hubspot_meeting_note"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  has_hubspot boolean;
BEGIN
  -- Only when we have an org context
  IF NEW.org_id IS NULL THEN
    RETURN NEW;
  END IF;

  -- Only enqueue when summary becomes available/changes
  IF (NEW.summary IS NULL OR btrim(NEW.summary) = '') THEN
    RETURN NEW;
  END IF;

  IF TG_OP = 'UPDATE' THEN
    IF (OLD.summary IS NOT DISTINCT FROM NEW.summary)
       AND (OLD.next_actions_generated_at IS NOT DISTINCT FROM NEW.next_actions_generated_at)
       AND (OLD.next_steps_oneliner IS NOT DISTINCT FROM NEW.next_steps_oneliner) THEN
      RETURN NEW;
    END IF;
  END IF;

  SELECT EXISTS(
    SELECT 1
    FROM public.hubspot_org_integrations i
    WHERE i.org_id = NEW.org_id
      AND i.is_active = true
      AND i.is_connected = true
  ) INTO has_hubspot;

  IF NOT has_hubspot THEN
    RETURN NEW;
  END IF;

  -- Enqueue writeback job (idempotent via dedupe_key)
  INSERT INTO public.hubspot_sync_queue (
    org_id,
    clerk_org_id,
    job_type,
    priority,
    run_after,
    attempts,
    max_attempts,
    payload,
    dedupe_key
  )
  VALUES (
    NEW.org_id,
    NEW.clerk_org_id,
    'push_note',
    50,
    now(),
    0,
    10,
    jsonb_build_object('meeting_id', NEW.id),
    'meeting_note:' || NEW.id
  )
  ON CONFLICT (org_id, dedupe_key) DO UPDATE SET
    run_after = EXCLUDED.run_after,
    payload = EXCLUDED.payload,
    attempts = 0,
    last_error = NULL,
    updated_at = now();

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."enqueue_hubspot_meeting_note"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."enqueue_hubspot_proposal_quote"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_org_id uuid;
  v_clerk_org_id text;
BEGIN
  IF NEW.meeting_id IS NULL THEN
    RETURN NEW;
  END IF;

  SELECT m.org_id, m.clerk_org_id
    INTO v_org_id, v_clerk_org_id
  FROM public.meetings m
  WHERE m.id = NEW.meeting_id
  LIMIT 1;

  IF v_org_id IS NULL THEN
    RETURN NEW;
  END IF;

  -- Ensure HubSpot integration exists for org
  IF NOT EXISTS (
    SELECT 1 FROM public.hubspot_org_integrations i
    WHERE i.org_id = v_org_id AND i.is_active = true AND i.is_connected = true
  ) THEN
    RETURN NEW;
  END IF;

  INSERT INTO public.hubspot_sync_queue (
    org_id, clerk_org_id, job_type, priority, run_after, attempts, max_attempts, payload, dedupe_key
  )
  VALUES (
    v_org_id, v_clerk_org_id, 'sync_quote', 30, now(), 0, 10,
    jsonb_build_object('sixty_proposal_id', NEW.id, 'source', 'db_trigger'),
    'proposal_quote:' || NEW.id
  )
  ON CONFLICT (org_id, dedupe_key) DO UPDATE SET
    run_after = EXCLUDED.run_after,
    payload = EXCLUDED.payload,
    attempts = 0,
    last_error = NULL,
    updated_at = now();

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."enqueue_hubspot_proposal_quote"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."enqueue_hubspot_task_outbound"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_org_id uuid;
BEGIN
  IF NEW.clerk_org_id IS NULL THEN
    RETURN NEW;
  END IF;

  SELECT i.org_id
    INTO v_org_id
  FROM public.hubspot_org_integrations i
  WHERE i.clerk_org_id = NEW.clerk_org_id
    AND i.is_active = true
    AND i.is_connected = true
  LIMIT 1;

  IF v_org_id IS NULL THEN
    RETURN NEW;
  END IF;

  INSERT INTO public.hubspot_sync_queue (
    org_id, clerk_org_id, job_type, priority, run_after, attempts, max_attempts, payload, dedupe_key
  )
  VALUES (
    v_org_id, NEW.clerk_org_id, 'sync_task', 20, now(), 0, 10,
    jsonb_build_object('sixty_task_id', NEW.id, 'source', 'db_trigger'),
    'task_out:' || NEW.id
  )
  ON CONFLICT (org_id, dedupe_key) DO UPDATE SET
    run_after = EXCLUDED.run_after,
    payload = EXCLUDED.payload,
    attempts = 0,
    last_error = NULL,
    updated_at = now();

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."enqueue_hubspot_task_outbound"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."enqueue_transcript_retry"("p_meeting_id" "uuid", "p_user_id" "uuid", "p_recording_id" "text", "p_initial_attempt_count" integer DEFAULT 1) RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_job_id UUID;
  v_next_retry_at TIMESTAMPTZ;
  v_existing_job_id UUID;
BEGIN
  -- Calculate next retry time (5 minutes from now)
  v_next_retry_at := NOW() + INTERVAL '5 minutes';

  -- Check if there's already a pending or processing job for this meeting
  SELECT id INTO v_existing_job_id
  FROM fathom_transcript_retry_jobs
  WHERE meeting_id = p_meeting_id
    AND status IN ('pending', 'processing')
  LIMIT 1;

  IF v_existing_job_id IS NOT NULL THEN
    -- Update existing job
    UPDATE fathom_transcript_retry_jobs
    SET
      attempt_count = GREATEST(attempt_count, p_initial_attempt_count),
      next_retry_at = v_next_retry_at,
      updated_at = NOW(),
      recording_id = p_recording_id
    WHERE id = v_existing_job_id
    RETURNING id INTO v_job_id;
  ELSE
    -- Insert new job
    INSERT INTO fathom_transcript_retry_jobs (
      meeting_id,
      user_id,
      recording_id,
      attempt_count,
      max_attempts,
      next_retry_at,
      status,
      updated_at
    )
    VALUES (
      p_meeting_id,
      p_user_id,
      p_recording_id,
      p_initial_attempt_count,
      5,
      v_next_retry_at,
      'pending',
      NOW()
    )
    RETURNING id INTO v_job_id;
  END IF;

  RETURN v_job_id;
END;
$$;

-- ALTER FUNCTION "public"."enqueue_transcript_retry"("p_meeting_id" "uuid", "p_user_id" "uuid", "p_recording_id" "text", "p_initial_attempt_count" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."enqueue_transcript_retry"("p_meeting_id" "uuid", "p_user_id" "uuid", "p_recording_id" "text", "p_initial_attempt_count" integer) IS 'Idempotently enqueue a transcript retry job for a meeting';

CREATE OR REPLACE FUNCTION "public"."ensure_task_sync_status"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- If sync_status is not set or is 'local_only', set it to 'pending_sync'
  IF NEW.sync_status IS NULL OR NEW.sync_status = 'local_only' THEN
    NEW.sync_status = 'pending_sync';
  END IF;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."ensure_task_sync_status"() OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."user_automation_rules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "rule_name" "text" NOT NULL,
    "rule_description" "text",
    "canvas_data" "jsonb",
    "trigger_type" "text" NOT NULL,
    "trigger_conditions" "jsonb" DEFAULT '{}'::"jsonb",
    "action_type" "text" NOT NULL,
    "action_config" "jsonb" DEFAULT '{}'::"jsonb",
    "template_id" "text",
    "is_active" boolean DEFAULT false,
    "priority_level" integer DEFAULT 1,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "execution_order" integer DEFAULT 0,
    "execution_count" integer DEFAULT 0,
    "success_count" integer DEFAULT 0,
    "failure_count" integer DEFAULT 0,
    "last_execution_at" timestamp with time zone,
    "last_execution_status" character varying(50),
    "last_error_message" "text",
    "avg_execution_time_ms" integer,
    "success_rate" numeric(5,2) GENERATED ALWAYS AS (
CASE
    WHEN ("execution_count" = 0) THEN (0)::numeric
    ELSE "round"(((("success_count")::numeric / ("execution_count")::numeric) * (100)::numeric), 2)
END) STORED,
    "clerk_org_id" "text",
    "ai_agent_configs" "jsonb" DEFAULT '[]'::"jsonb",
    CONSTRAINT "user_automation_rules_action_type_check" CHECK (("action_type" = ANY (ARRAY['create_deal'::"text", 'update_deal_stage'::"text", 'create_task'::"text", 'create_activity'::"text", 'send_notification'::"text", 'webhook_process'::"text", 'update_field'::"text"]))),
    CONSTRAINT "user_automation_rules_trigger_type_check" CHECK (("trigger_type" = ANY (ARRAY['activity_created'::"text", 'stage_changed'::"text", 'deal_created'::"text", 'task_completed'::"text", 'webhook'::"text", 'manual'::"text"])))
);

-- ALTER TABLE "public"."user_automation_rules" OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."execute_automation_action"("rule" "public"."user_automation_rules", "trigger_data" "jsonb", "user_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  result JSONB := '{}';
BEGIN
  -- Simple implementation that just returns success
  -- The actual implementation would handle different action types
  result := jsonb_build_object(
    'success', true,
    'action_type', rule.action_type,
    'message', 'Action executed successfully'
  );
  
  RETURN result;
END;
$$;

-- ALTER FUNCTION "public"."execute_automation_action"("rule" "public"."user_automation_rules", "trigger_data" "jsonb", "user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."execute_unified_automation_rules"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  rule_record user_automation_rules%ROWTYPE;
  execution_result JSONB;
  trigger_data JSONB;
  start_time TIMESTAMP;
  execution_time_ms INTEGER;
BEGIN
  start_time := clock_timestamp();
  
  -- Only process activity creation triggers for now
  IF TG_TABLE_NAME = 'activities' AND TG_OP = 'INSERT' THEN
    -- Build trigger data
    trigger_data := jsonb_build_object(
      'trigger_type', 'activity_created',
      'activity_id', NEW.id,
      'activity_type', NEW.type,
      'client_name', NEW.client_name,
      'amount', NEW.amount,
      'deal_id', NEW.deal_id,
      'user_id', NEW.user_id,
      'contact_identifier', NEW.contact_identifier
    );
    
    -- Find matching automation rules for this user
    -- Fixed: Properly reference the columns without syntax errors
    FOR rule_record IN
      SELECT * FROM user_automation_rules
      WHERE user_id = NEW.user_id
        AND trigger_type = 'activity_created'
        AND is_active = true
        AND (
          trigger_conditions IS NULL 
          OR trigger_conditions = '{}'::jsonb
          OR (
            trigger_conditions->>'activity_type' IS NULL 
            OR trigger_conditions->>'activity_type' = NEW.type
          )
        )
      ORDER BY execution_order ASC, created_at ASC
    LOOP
      BEGIN
        -- Execute the automation action
        execution_result := execute_automation_action(rule_record, trigger_data, NEW.user_id);
        
        -- Calculate execution time
        execution_time_ms := EXTRACT(MILLISECONDS FROM (clock_timestamp() - start_time))::INTEGER;
        
        -- Log successful execution
        INSERT INTO automation_executions (
          rule_id, 
          trigger_data, 
          execution_result, 
          status, 
          execution_time_ms, 
          executed_by, 
          activity_id
        ) VALUES (
          rule_record.id,
          trigger_data,
          execution_result,
          'success',
          execution_time_ms,
          NEW.user_id,
          NEW.id
        );
        
      EXCEPTION WHEN OTHERS THEN
        -- Log failed execution
        INSERT INTO automation_executions (
          rule_id, 
          trigger_data, 
          status, 
          error_message, 
          execution_time_ms, 
          executed_by, 
          activity_id
        ) VALUES (
          rule_record.id,
          trigger_data,
          'failed',
          SQLERRM,
          EXTRACT(MILLISECONDS FROM (clock_timestamp() - start_time))::INTEGER,
          NEW.user_id,
          NEW.id
        );
        -- Continue processing other rules even if one fails
      END;
    END LOOP;
  END IF;
  
  -- Always return NEW to allow the operation to continue
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."execute_unified_automation_rules"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."expire_hitl_approvals"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_count INTEGER;
BEGIN
  UPDATE hitl_pending_approvals
  SET
    status = 'expired',
    updated_at = now()
  WHERE status = 'pending'
    AND expires_at < now();

  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$;

-- ALTER FUNCTION "public"."expire_hitl_approvals"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."expire_hitl_requests"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_expired_count INT;
  v_request RECORD;
BEGIN
  -- Find and process expired requests
  FOR v_request IN
    SELECT * FROM hitl_requests
    WHERE status = 'pending'
    AND expires_at IS NOT NULL
    AND expires_at < now()
  LOOP
    -- Mark request as expired
    UPDATE hitl_requests SET
      status = 'expired',
      updated_at = now()
    WHERE id = v_request.id;

    -- Handle the execution based on timeout_action
    IF v_request.timeout_action = 'fail' THEN
      UPDATE sequence_executions SET
        status = 'failed',
        error_message = 'HITL request timed out at step ' || v_request.step_index,
        failed_step_index = v_request.step_index,
        waiting_for_hitl = false,
        current_hitl_request_id = NULL,
        completed_at = now()
      WHERE id = v_request.execution_id;
    ELSIF v_request.timeout_action = 'use_default' THEN
      -- Store default as response and mark as ready to continue
      UPDATE hitl_requests SET
        response_value = v_request.default_value,
        response_context = jsonb_build_object('auto_defaulted', true)
      WHERE id = v_request.id;

      UPDATE sequence_executions SET
        waiting_for_hitl = false,
        current_hitl_request_id = NULL
      WHERE id = v_request.execution_id;
    ELSIF v_request.timeout_action = 'continue' THEN
      -- Just continue without response
      UPDATE sequence_executions SET
        waiting_for_hitl = false,
        current_hitl_request_id = NULL
      WHERE id = v_request.execution_id;
    END IF;
  END LOOP;

  GET DIAGNOSTICS v_expired_count = ROW_COUNT;
  RETURN v_expired_count;
END;
$$;

-- ALTER FUNCTION "public"."expire_hitl_requests"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."expire_old_recommendations"() RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  v_expired_count INTEGER;
BEGIN
  UPDATE pipeline_stage_recommendations
  SET status = 'expired'
  WHERE status = 'pending'
    AND expires_at <= NOW();

  GET DIAGNOSTICS v_expired_count = ROW_COUNT;

  RETURN v_expired_count;
END;
$$;

-- ALTER FUNCTION "public"."expire_old_recommendations"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."expire_pending_hitl_requests"() RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  expired_count INTEGER;
BEGIN
  UPDATE sequence_hitl_requests
  SET
    status = 'expired',
    updated_at = now()
  WHERE
    status = 'pending'
    AND expires_at IS NOT NULL
    AND expires_at < now();

  GET DIAGNOSTICS expired_count = ROW_COUNT;
  RETURN expired_count;
END;
$$;

-- ALTER FUNCTION "public"."expire_pending_hitl_requests"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."expire_pending_hitl_requests"() IS 'Marks pending HITL requests as expired if past their timeout. Run periodically via CRON.';

CREATE OR REPLACE FUNCTION "public"."fail_sentry_bridge_item"("item_id" "uuid", "error_msg" "text", "move_to_dlq" boolean DEFAULT false) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_item sentry_bridge_queue;
BEGIN
  SELECT * INTO v_item FROM sentry_bridge_queue WHERE id = item_id;

  IF move_to_dlq OR v_item.attempt_count >= v_item.max_attempts THEN
    -- Move to DLQ
    INSERT INTO sentry_dead_letter_queue (
      org_id,
      original_queue_id,
      queue_type,
      webhook_event_id,
      sentry_issue_id,
      event_type,
      original_payload,
      failure_reason,
      attempt_count,
      last_error_details
    ) VALUES (
      v_item.org_id,
      v_item.id,
      'bridge',
      v_item.webhook_event_id,
      v_item.sentry_issue_id,
      v_item.event_type,
      v_item.ticket_payload,
      error_msg,
      v_item.attempt_count,
      jsonb_build_object('error', error_msg, 'timestamp', now())
    );

    UPDATE sentry_bridge_queue
    SET status = 'dlq', last_error = error_msg
    WHERE id = item_id;
  ELSE
    -- Schedule retry with exponential backoff
    UPDATE sentry_bridge_queue
    SET
      status = 'pending',
      locked_by = NULL,
      locked_at = NULL,
      last_error = error_msg,
      next_attempt_at = now() + (power(2, v_item.attempt_count) * interval '1 minute')
    WHERE id = item_id;
  END IF;
END;
$$;

-- ALTER FUNCTION "public"."fail_sentry_bridge_item"("item_id" "uuid", "error_msg" "text", "move_to_dlq" boolean) OWNER TO "postgres";

-- ALTER FUNCTION "public"."find_orgs_by_email_domain"("p_domain" "text", "p_user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."find_similar_org_name"("normalized_name" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" STABLE
    AS $$
DECLARE
  similar_org_id UUID;
BEGIN
  -- Find organization with similar normalized name
  -- Uses case-insensitive comparison and handles variations
  SELECT id INTO similar_org_id
  FROM organizations
  WHERE LOWER(TRIM(name)) = LOWER(normalized_name)
    AND is_active = true
  ORDER BY created_at ASC
  LIMIT 1;
  
  RETURN similar_org_id;
END;
$$;

-- ALTER FUNCTION "public"."find_similar_org_name"("normalized_name" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."find_similar_org_name"("normalized_name" "text") IS 'Finds existing organization with similar normalized name (case-insensitive) to prevent duplicates.';

CREATE OR REPLACE FUNCTION "public"."generate_api_key"() RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  key_string TEXT;
  prefix TEXT := 'sk_';
  random_part TEXT;
BEGIN
  -- Generate 32 random bytes and encode as base64
  SELECT encode(gen_random_bytes(32), 'base64') INTO random_part;
  
  -- Remove padding and special characters, keep only alphanumeric
  random_part := regexp_replace(random_part, '[^A-Za-z0-9]', '', 'g');
  
  -- Take first 40 characters and add prefix
  key_string := prefix || substring(random_part, 1, 40);
  
  RETURN key_string;
END;
$$;

-- ALTER FUNCTION "public"."generate_api_key"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."generate_api_key"("prefix" "text" DEFAULT 'sk'::"text") RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
    random_part TEXT;
BEGIN
    -- Generate a random string
    random_part := encode(gen_random_bytes(32), 'hex');
    RETURN prefix || '_' || random_part;
END;
$$;

-- ALTER FUNCTION "public"."generate_api_key"("prefix" "text") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."generate_pipeline_recommendation_from_meeting"("p_meeting_id" "uuid", "p_user_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  v_meeting RECORD;
  v_deal RECORD;
  v_recommended_stage TEXT;
  v_confidence NUMERIC;
  v_reason TEXT;
  v_key_signals TEXT[];
  v_recommendation_id UUID;
BEGIN
  -- Get meeting details
  SELECT
    m.id,
    m.company_id,
    m.primary_contact_id,
    m.sentiment_score,
    m.summary,
    m.coach_rating,
    m.talk_time_judgement
  INTO v_meeting
  FROM meetings m
  WHERE m.id = p_meeting_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Meeting not found: %', p_meeting_id;
  END IF;

  -- Find active deal for this company
  SELECT
    d.id,
    d.stage,
    d.company_id
  INTO v_deal
  FROM deals d
  WHERE d.company_id = v_meeting.company_id
    AND d.owner_id = p_user_id  -- FIXED: Changed from user_id to owner_id
    AND d.stage NOT IN ('Signed', 'Lost') -- Only active deals
  ORDER BY d.created_at DESC
  LIMIT 1;

  -- If no active deal found, skip recommendation
  IF NOT FOUND THEN
    RAISE NOTICE 'No active deal found for company, skipping recommendation';
    RETURN NULL;
  END IF;

  -- Determine recommended stage based on sentiment and current stage
  -- Business logic for 4-stage pipeline: SQL â†’ Opportunity â†’ Verbal â†’ Signed

  v_key_signals := ARRAY[]::TEXT[];

  CASE v_deal.stage
    WHEN 'SQL' THEN
      -- SQL â†’ Opportunity transition
      -- Positive sentiment (>0.3) suggests moving to Opportunity
      IF v_meeting.sentiment_score >= 0.3 THEN
        v_recommended_stage := 'Opportunity';
        v_confidence := LEAST(1.0, v_meeting.sentiment_score + 0.3);
        v_reason := 'Positive meeting sentiment suggests prospect is ready for proposal stage';
        v_key_signals := ARRAY['positive_sentiment', 'discovery_complete'];
      ELSIF v_meeting.sentiment_score >= 0.0 THEN
        v_recommended_stage := 'SQL'; -- Stay in SQL
        v_confidence := 0.5;
        v_reason := 'Neutral sentiment - continue discovery';
        v_key_signals := ARRAY['neutral_sentiment', 'more_discovery_needed'];
      ELSE
        v_recommended_stage := 'SQL'; -- Stay or consider disqualifying
        v_confidence := 0.3;
        v_reason := 'Negative sentiment - may need to re-qualify or address concerns';
        v_key_signals := ARRAY['negative_sentiment', 'objections_present'];
      END IF;

    WHEN 'Opportunity' THEN
      -- Opportunity â†’ Verbal transition
      -- High positive sentiment (>0.5) suggests verbal commitment
      IF v_meeting.sentiment_score >= 0.5 THEN
        v_recommended_stage := 'Verbal';
        v_confidence := LEAST(1.0, v_meeting.sentiment_score + 0.2);
        v_reason := 'Strong positive sentiment indicates verbal commitment likely';
        v_key_signals := ARRAY['strong_positive_sentiment', 'commitment_signals'];
      ELSIF v_meeting.sentiment_score >= 0.2 THEN
        v_recommended_stage := 'Opportunity'; -- Stay
        v_confidence := 0.6;
        v_reason := 'Positive progress but not yet ready for verbal commitment';
        v_key_signals := ARRAY['positive_progress', 'negotiation_ongoing'];
      ELSE
        v_recommended_stage := 'SQL'; -- Consider moving back
        v_confidence := 0.4;
        v_reason := 'Concerns raised - may need to revisit discovery';
        v_key_signals := ARRAY['concerns_raised', 'back_to_discovery'];
      END IF;

    WHEN 'Verbal' THEN
      -- Verbal â†’ Signed transition
      -- Very high sentiment (>0.6) suggests ready to close
      IF v_meeting.sentiment_score >= 0.6 THEN
        v_recommended_stage := 'Signed';
        v_confidence := LEAST(1.0, v_meeting.sentiment_score + 0.15);
        v_reason := 'Excellent sentiment - deal likely to close';
        v_key_signals := ARRAY['very_positive_sentiment', 'ready_to_close'];
      ELSIF v_meeting.sentiment_score >= 0.3 THEN
        v_recommended_stage := 'Verbal'; -- Stay
        v_confidence := 0.7;
        v_reason := 'Positive but awaiting final approvals';
        v_key_signals := ARRAY['awaiting_approval', 'positive_signals'];
      ELSE
        v_recommended_stage := 'Opportunity'; -- Move back if issues
        v_confidence := 0.5;
        v_reason := 'Issues detected - may need to renegotiate';
        v_key_signals := ARRAY['issues_detected', 'renegotiation_needed'];
      END IF;

    ELSE
      -- For other stages, no automatic recommendation
      RETURN NULL;
  END CASE;

  -- Only create recommendation if stage is different from current
  IF v_recommended_stage = v_deal.stage THEN
    RAISE NOTICE 'Recommended stage same as current, skipping recommendation';
    RETURN NULL;
  END IF;

  -- Create recommendation
  INSERT INTO pipeline_stage_recommendations (
    meeting_id,
    deal_id,
    company_id,
    contact_id,
    user_id,
    current_stage,
    recommended_stage,
    confidence_score,
    recommendation_reason,
    meeting_sentiment_score,
    meeting_summary,
    key_signals,
    status
  ) VALUES (
    p_meeting_id,
    v_deal.id,
    v_meeting.company_id,
    v_meeting.primary_contact_id,
    p_user_id,
    v_deal.stage,
    v_recommended_stage,
    v_confidence,
    v_reason,
    v_meeting.sentiment_score,
    v_meeting.summary,
    v_key_signals,
    'pending'
  )
  RETURNING id INTO v_recommendation_id;

  RAISE NOTICE 'Created pipeline recommendation: % â†’ % (confidence: %)',
    v_deal.stage, v_recommended_stage, v_confidence;

  RETURN v_recommendation_id;
END;
$$;

-- ALTER FUNCTION "public"."generate_pipeline_recommendation_from_meeting"("p_meeting_id" "uuid", "p_user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."generate_referral_code"() RETURNS "text"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
DECLARE
  code TEXT;
  code_exists BOOLEAN;
BEGIN
  LOOP
    code := 'MEET-' || upper(substring(md5(random()::text) from 1 for 6));
    SELECT EXISTS(
      SELECT 1 FROM meetings_waitlist WHERE referral_code = code
    ) INTO code_exists;
    EXIT WHEN NOT code_exists;
  END LOOP;
  RETURN code;
END;
$$;

-- ALTER FUNCTION "public"."generate_referral_code"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_activation_funnel"("p_start_date" "date" DEFAULT (CURRENT_DATE - '30 days'::interval), "p_end_date" "date" DEFAULT CURRENT_DATE) RETURNS TABLE("step_name" "text", "step_order" integer, "user_count" bigint, "percentage" numeric, "avg_time_to_step" interval)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  WITH funnel_data AS (
    SELECT
      uop.user_id,
      uop.created_at as account_created,
      CASE WHEN uop.fathom_connected THEN uop.updated_at END as fathom_time,
      CASE WHEN uop.first_meeting_synced THEN uop.updated_at END as meeting_time,
      uop.first_summary_viewed_at as summary_time,
      uop.activation_completed_at
    FROM user_onboarding_progress uop
    WHERE uop.created_at::date BETWEEN p_start_date AND p_end_date
  ),
  totals AS (
    SELECT COUNT(*) as total FROM funnel_data
  )
  SELECT 
    s.step_name,
    s.step_order,
    s.user_count,
    ROUND((s.user_count::NUMERIC / NULLIF(t.total, 0) * 100), 1) as percentage,
    s.avg_time
  FROM totals t
  CROSS JOIN LATERAL (
    VALUES
      ('Account Created', 1, (SELECT COUNT(*) FROM funnel_data), NULL::INTERVAL),
      ('Fathom Connected', 2, (SELECT COUNT(*) FROM funnel_data WHERE fathom_time IS NOT NULL), 
        (SELECT AVG(fathom_time - account_created) FROM funnel_data WHERE fathom_time IS NOT NULL)),
      ('First Meeting Synced', 3, (SELECT COUNT(*) FROM funnel_data WHERE meeting_time IS NOT NULL),
        (SELECT AVG(meeting_time - account_created) FROM funnel_data WHERE meeting_time IS NOT NULL)),
      ('First Summary Viewed (North Star)', 4, (SELECT COUNT(*) FROM funnel_data WHERE summary_time IS NOT NULL),
        (SELECT AVG(summary_time - account_created) FROM funnel_data WHERE summary_time IS NOT NULL)),
      ('Fully Activated', 5, (SELECT COUNT(*) FROM funnel_data WHERE activation_completed_at IS NOT NULL),
        (SELECT AVG(activation_completed_at - account_created) FROM funnel_data WHERE activation_completed_at IS NOT NULL))
  ) AS s(step_name, step_order, user_count, avg_time);
END;
$$;

-- ALTER FUNCTION "public"."get_activation_funnel"("p_start_date" "date", "p_end_date" "date") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_activation_funnel"("p_start_date" "date", "p_end_date" "date") IS 'Get activation funnel metrics for a date range';

CREATE OR REPLACE FUNCTION "public"."get_active_fathom_integration"("p_user_id" "uuid") RETURNS TABLE("id" "uuid", "user_id" "uuid", "access_token" "text", "refresh_token" "text", "token_expires_at" timestamp with time zone, "fathom_user_id" "text", "fathom_user_email" "text", "scopes" "text"[], "last_sync_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    fi.id,
    fi.user_id,
    fi.access_token,
    fi.refresh_token,
    fi.token_expires_at,
    fi.fathom_user_id,
    fi.fathom_user_email,
    fi.scopes,
    fi.last_sync_at
  FROM fathom_integrations fi
  WHERE fi.user_id = p_user_id
    AND fi.is_active = true
  LIMIT 1;
END;
$$;

-- ALTER FUNCTION "public"."get_active_fathom_integration"("p_user_id" "uuid") OWNER TO "postgres";

-- ALTER TABLE "public"."interventions" OWNER TO "postgres";

-- COMMENT ON TABLE "public"."interventions" IS 'Tracks deployed interventions and their outcomes';

-- COMMENT ON COLUMN "public"."interventions"."personalization_data" IS 'JSONB containing the AI-generated personalizations applied to this intervention';

-- COMMENT ON COLUMN "public"."interventions"."suggested_reply" IS 'AI-generated suggested response when prospect replies';

-- COMMENT ON COLUMN "public"."interventions"."health_score_at_send" IS 'Relationship health score at the time intervention was sent (for analysis)';

-- COMMENT ON COLUMN "public"."interventions"."ai_recommendation_score" IS 'AI confidence score (0-1) for template selection';

-- CREATE OR REPLACE FUNCTION "public"."get_active_interventions"("user_id_param" "uuid") RETURNS SETOF "public"."interventions"
--     LANGUAGE "sql" STABLE
--     SET "search_path" TO ''
--     AS $$
--   SELECT *
--   FROM interventions
--   WHERE user_id = user_id_param
--     AND status IN ('pending', 'sent', 'delivered', 'opened')
--     AND outcome = 'pending'
--   ORDER BY created_at DESC;
-- $$;

-- ALTER FUNCTION "public"."get_active_interventions"("user_id_param" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_activity_summary"("user_id" "uuid", "start_date" timestamp with time zone, "end_date" timestamp with time zone) RETURNS TABLE("activity_type" "text", "count" bigint, "points" bigint, "trend" numeric)
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  WITH summary AS (
    SELECT 
      a.type::text,
      COUNT(*) as count,
      SUM(calculate_activity_points(a.type, a.amount)) as points
    FROM activities a
    WHERE a.user_id = get_activity_summary.user_id
    AND a.date BETWEEN start_date AND end_date
    GROUP BY a.type
  )
  SELECT
    s.activity_type,
    s.count,
    s.points,
    calculate_activity_trend(
      get_activity_summary.user_id,
      s.activity_type::activity_type,
      start_date,
      end_date
    ) as trend
  FROM summary s;
END;
$$;

-- ALTER FUNCTION "public"."get_activity_summary"("user_id" "uuid", "start_date" timestamp with time zone, "end_date" timestamp with time zone) OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."pipeline_automation_rules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "is_active" boolean DEFAULT true,
    "trigger_type" "text" NOT NULL,
    "call_type_filter" "uuid"[],
    "action_type" "text" NOT NULL,
    "action_config" "jsonb" NOT NULL,
    "min_confidence" numeric(3,2) DEFAULT 0.7,
    "cooldown_hours" integer DEFAULT 24,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "pipeline_automation_rules_action_type_check" CHECK (("action_type" = ANY (ARRAY['advance_stage'::"text", 'create_task'::"text", 'send_notification'::"text", 'update_deal_field'::"text"]))),
    CONSTRAINT "pipeline_automation_rules_trigger_type_check" CHECK (("trigger_type" = ANY (ARRAY['forward_movement_detected'::"text", 'proposal_requested'::"text", 'pricing_discussed'::"text", 'verbal_commitment'::"text", 'next_meeting_scheduled'::"text", 'decision_maker_engaged'::"text", 'timeline_confirmed'::"text", 'checklist_incomplete'::"text"])))
);

-- ALTER TABLE "public"."pipeline_automation_rules" OWNER TO "postgres";

COMMENT ON TABLE "public"."pipeline_automation_rules" IS 'Org-configurable rules for automatic pipeline actions based on call analysis signals';

COMMENT ON COLUMN "public"."pipeline_automation_rules"."trigger_type" IS 'Type of signal that triggers this rule';

COMMENT ON COLUMN "public"."pipeline_automation_rules"."call_type_filter" IS 'Optional: Only trigger for specific call types (NULL = all)';

COMMENT ON COLUMN "public"."pipeline_automation_rules"."action_config" IS 'Configuration for the action, structure depends on action_type';

COMMENT ON COLUMN "public"."pipeline_automation_rules"."min_confidence" IS 'Minimum signal confidence required to trigger (0-1)';

COMMENT ON COLUMN "public"."pipeline_automation_rules"."cooldown_hours" IS 'Hours before rule can trigger again for the same deal';

CREATE OR REPLACE FUNCTION "public"."get_applicable_automation_rules"("p_org_id" "uuid", "p_trigger_type" "text", "p_call_type_id" "uuid" DEFAULT NULL::"uuid", "p_confidence" numeric DEFAULT 1.0) RETURNS SETOF "public"."pipeline_automation_rules"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT r.*
  FROM pipeline_automation_rules r
  WHERE r.org_id = p_org_id
    AND r.is_active = true
    AND r.trigger_type = p_trigger_type
    AND r.min_confidence <= p_confidence
    AND (
      r.call_type_filter IS NULL
      OR p_call_type_id = ANY(r.call_type_filter)
    )
  ORDER BY r.created_at;
END;
$$;

-- ALTER FUNCTION "public"."get_applicable_automation_rules"("p_org_id" "uuid", "p_trigger_type" "text", "p_call_type_id" "uuid", "p_confidence" numeric) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_at_risk_summary"() RETURNS TABLE("risk_level" "text", "user_count" bigint, "percentage" numeric)
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  WITH risk_counts AS (
    SELECT 
      risk_level,
      COUNT(*) AS user_count
    FROM at_risk_users
    WHERE risk_level != 'on_track'
    GROUP BY risk_level
  ),
  total AS (
    SELECT SUM(user_count) AS total_count FROM risk_counts
  )
  SELECT 
    rc.risk_level,
    rc.user_count,
    ROUND(100.0 * rc.user_count / NULLIF(t.total_count, 0), 1) AS percentage
  FROM risk_counts rc
  CROSS JOIN total t
  ORDER BY 
    CASE rc.risk_level
      WHEN 'high' THEN 1
      WHEN 'medium' THEN 2
      WHEN 'low' THEN 3
      ELSE 4
    END;
$$;

-- ALTER FUNCTION "public"."get_at_risk_summary"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_at_risk_summary"() IS 'Get summary counts of at-risk users by level';

CREATE OR REPLACE FUNCTION "public"."get_at_risk_users"("p_risk_level" "text" DEFAULT 'all'::"text", "p_limit" integer DEFAULT 50) RETURNS TABLE("user_id" "uuid", "email" "text", "full_name" "text", "signup_date" timestamp with time zone, "hours_since_signup" numeric, "fathom_connected" boolean, "first_meeting_synced" boolean, "first_summary_viewed" boolean, "risk_level" "text", "suggested_action" "text", "org_name" "text")
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT 
    user_id,
    email,
    full_name,
    signup_date,
    hours_since_signup::NUMERIC,
    fathom_connected,
    first_meeting_synced,
    first_summary_viewed,
    risk_level,
    suggested_action,
    org_name
  FROM at_risk_users
  WHERE 
    risk_level != 'on_track'
    AND (p_risk_level = 'all' OR risk_level = p_risk_level)
  LIMIT p_limit;
$$;

-- ALTER FUNCTION "public"."get_at_risk_users"("p_risk_level" "text", "p_limit" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_at_risk_users"("p_risk_level" "text", "p_limit" integer) IS 'Get list of at-risk users filtered by risk level';

CREATE OR REPLACE FUNCTION "public"."get_audit_history"("p_table_name" "text", "p_record_id" "uuid", "p_limit" integer DEFAULT 50) RETURNS TABLE("audit_id" "uuid", "action" "text", "changed_by" "uuid", "changed_at" timestamp with time zone, "changed_fields" "text"[], "old_value" "jsonb", "new_value" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    id as audit_id,
    audit_logs.action,
    user_id as changed_by,
    audit_logs.changed_at,
    audit_logs.changed_fields,
    old_data as old_value,
    new_data as new_value
  FROM audit_logs
  WHERE table_name = p_table_name
    AND record_id = p_record_id
  ORDER BY audit_logs.changed_at DESC
  LIMIT p_limit;
END;
$$;

-- ALTER FUNCTION "public"."get_audit_history"("p_table_name" "text", "p_record_id" "uuid", "p_limit" integer) OWNER TO "postgres";

-- ALTER FUNCTION "public"."get_auth_provider"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_auth_provider"() IS 'Returns the authentication provider being used: supabase, clerk, or none';

CREATE OR REPLACE FUNCTION "public"."get_avg_health_change_per_day"("relationship_health_id_param" "uuid", "days" integer DEFAULT 7) RETURNS numeric
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO ''
    AS $$
DECLARE
  oldest_score INTEGER;
  newest_score INTEGER;
  days_diff INTEGER;
BEGIN
  SELECT overall_health_score INTO oldest_score
  FROM relationship_health_history
  WHERE relationship_health_id = relationship_health_id_param
    AND snapshot_at >= NOW() - (days || ' days')::INTERVAL
  ORDER BY snapshot_at ASC
  LIMIT 1;

  SELECT overall_health_score INTO newest_score
  FROM relationship_health_history
  WHERE relationship_health_id = relationship_health_id_param
  ORDER BY snapshot_at DESC
  LIMIT 1;

  IF oldest_score IS NULL OR newest_score IS NULL THEN
    RETURN 0;
  END IF;

  days_diff := GREATEST(days, 1);

  RETURN (newest_score - oldest_score)::NUMERIC / days_diff::NUMERIC;
END;
$$;

-- ALTER FUNCTION "public"."get_avg_health_change_per_day"("relationship_health_id_param" "uuid", "days" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_avg_response_time"("contact_id_param" "uuid") RETURNS numeric
    LANGUAGE "sql" STABLE
    SET "search_path" TO ''
    AS $$
  SELECT AVG(response_time_hours)
  FROM communication_events
  WHERE contact_id = contact_id_param
    AND direction = 'inbound'
    AND response_time_hours IS NOT NULL;
$$;

-- ALTER FUNCTION "public"."get_avg_response_time"("contact_id_param" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_calendar_events_in_range"("p_user_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_calendar_ids" "uuid"[] DEFAULT NULL::"uuid"[]) RETURNS TABLE("id" "uuid", "external_id" "text", "calendar_id" "uuid", "title" "text", "description" "text", "location" "text", "start_time" timestamp with time zone, "end_time" timestamp with time zone, "all_day" boolean, "status" "text", "meeting_url" "text", "attendees_count" integer, "contact_id" "uuid", "contact_name" "text", "company_id" "uuid", "company_name" "text", "color" "text", "sync_status" "text", "creator_email" "text", "organizer_email" "text", "html_link" "text", "raw_data" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ce.id,
    ce.external_id,
    ce.calendar_id,
    ce.title,
    ce.description,
    ce.location,
    ce.start_time,
    ce.end_time,
    ce.all_day,
    ce.status,
    ce.meeting_url,
    ce.attendees_count,
    ce.contact_id,
    c.first_name || ' ' || c.last_name as contact_name,
    comp.id as company_id,
    comp.name as company_name,
    ce.color,
    ce.sync_status,
    ce.creator_email,
    ce.organizer_email,
    ce.html_link,
    ce.raw_data
  FROM calendar_events ce
  LEFT JOIN contacts c ON c.id = ce.contact_id
  LEFT JOIN companies comp ON comp.id = c.company_id
  WHERE ce.user_id = p_user_id
    AND ce.start_time <= p_end_date
    AND ce.end_time >= p_start_date
    AND (p_calendar_ids IS NULL OR ce.calendar_id = ANY(p_calendar_ids))
  ORDER BY ce.start_time ASC;
END;
$$;

-- ALTER FUNCTION "public"."get_calendar_events_in_range"("p_user_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_calendar_ids" "uuid"[]) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_calendar_events_in_range"("p_user_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_calendar_ids" "uuid"[]) IS 'Retrieves calendar events for a user within a specified date range, with optional calendar filtering';

CREATE OR REPLACE FUNCTION "public"."get_changed_fields"("old_data" "jsonb", "new_data" "jsonb") RETURNS "text"[]
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  changed_fields TEXT[] := '{}';
  key TEXT;
BEGIN
  -- Check fields that exist in new data
  FOR key IN SELECT jsonb_object_keys(new_data)
  LOOP
    IF old_data IS NULL OR
       NOT old_data ? key OR
       old_data->key IS DISTINCT FROM new_data->key THEN
      changed_fields := array_append(changed_fields, key);
    END IF;
  END LOOP;

  -- Check fields that were removed (exist in old but not in new)
  IF old_data IS NOT NULL THEN
    FOR key IN SELECT jsonb_object_keys(old_data)
    LOOP
      IF NOT new_data ? key THEN
        changed_fields := array_append(changed_fields, key);
      END IF;
    END LOOP;
  END IF;

  RETURN changed_fields;
END;
$$;

-- ALTER FUNCTION "public"."get_changed_fields"("old_data" "jsonb", "new_data" "jsonb") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_clerk_org_id"() RETURNS "text"
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  org_id TEXT;
BEGIN
  -- Extract 'org_id' claim from Clerk JWT
  BEGIN
    org_id := current_setting('request.jwt.claims', true)::json->>'org_id';
  EXCEPTION
    WHEN OTHERS THEN
      org_id := NULL;
  END;

  RETURN org_id;
END;
$$;

-- ALTER FUNCTION "public"."get_clerk_org_id"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_clerk_org_id"() IS 'Extracts Clerk organization ID from JWT claims';

-- ALTER FUNCTION "public"."get_clerk_user_id"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_clerk_user_id"() IS 'Returns the Clerk user ID from JWT sub claim, or NULL if not using Clerk auth';

CREATE OR REPLACE FUNCTION "public"."get_coaching_reference_meetings"("p_user_id" "uuid", "p_good_meeting_ids" "uuid"[] DEFAULT ARRAY[]::"uuid"[], "p_bad_meeting_ids" "uuid"[] DEFAULT ARRAY[]::"uuid"[]) RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  v_result JSON;
BEGIN
  WITH good_examples AS (
    SELECT
      id,
      title,
      meeting_start,
      sentiment_score,
      coach_rating,
      LEFT(transcript_text, 500) as transcript_preview
    FROM meetings
    WHERE id = ANY(p_good_meeting_ids)
      AND owner_user_id = p_user_id
      AND transcript_text IS NOT NULL
    ORDER BY coach_rating DESC NULLS LAST
    LIMIT 3
  ),
  bad_examples AS (
    SELECT
      id,
      title,
      meeting_start,
      sentiment_score,
      coach_rating,
      LEFT(transcript_text, 500) as transcript_preview
    FROM meetings
    WHERE id = ANY(p_bad_meeting_ids)
      AND owner_user_id = p_user_id
      AND transcript_text IS NOT NULL
    ORDER BY coach_rating ASC NULLS LAST
    LIMIT 3
  )
  SELECT json_build_object(
    'good_examples', COALESCE((SELECT json_agg(row_to_json(good_examples.*)) FROM good_examples), '[]'::json),
    'bad_examples', COALESCE((SELECT json_agg(row_to_json(bad_examples.*)) FROM bad_examples), '[]'::json)
  ) INTO v_result;

  RETURN v_result;
END;
$$;

-- ALTER FUNCTION "public"."get_coaching_reference_meetings"("p_user_id" "uuid", "p_good_meeting_ids" "uuid"[], "p_bad_meeting_ids" "uuid"[]) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_coaching_reference_meetings"("p_user_id" "uuid", "p_good_meeting_ids" "uuid"[], "p_bad_meeting_ids" "uuid"[]) IS 'Fetches meeting context for AI coaching analysis. Returns previews of transcripts from good and bad example meetings for context.';

CREATE OR REPLACE FUNCTION "public"."get_coaching_template_for_call_type"("p_org_id" "uuid", "p_call_type_id" "uuid", "p_meeting_type" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_template_id UUID;
BEGIN
  -- First try to find template linked to this specific call type
  SELECT id INTO v_template_id
  FROM coaching_scorecard_templates
  WHERE org_id = p_org_id
    AND call_type_id = p_call_type_id
    AND is_active = true
  ORDER BY created_at DESC
  LIMIT 1;

  -- If found, return it
  IF v_template_id IS NOT NULL THEN
    RETURN v_template_id;
  END IF;

  -- Fallback: try to match by meeting_type name
  IF p_meeting_type IS NOT NULL THEN
    SELECT id INTO v_template_id
    FROM coaching_scorecard_templates
    WHERE org_id = p_org_id
      AND LOWER(meeting_type) = LOWER(p_meeting_type)
      AND is_active = true
    ORDER BY created_at DESC
    LIMIT 1;

    IF v_template_id IS NOT NULL THEN
      RETURN v_template_id;
    END IF;
  END IF;

  -- Final fallback: get default/general template
  SELECT id INTO v_template_id
  FROM coaching_scorecard_templates
  WHERE org_id = p_org_id
    AND (LOWER(meeting_type) = 'general' OR meeting_type IS NULL)
    AND is_active = true
  ORDER BY created_at DESC
  LIMIT 1;

  RETURN v_template_id;
END;
$$;

-- ALTER FUNCTION "public"."get_coaching_template_for_call_type"("p_org_id" "uuid", "p_call_type_id" "uuid", "p_meeting_type" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_coaching_template_for_call_type"("p_org_id" "uuid", "p_call_type_id" "uuid", "p_meeting_type" "text") IS 'Find the best matching coaching template for a given call type, with fallbacks';

CREATE OR REPLACE FUNCTION "public"."get_cohort_analysis"("p_weeks" integer DEFAULT 8) RETURNS TABLE("cohort_week" "date", "week_label" "text", "total_users" bigint, "fathom_connected" bigint, "first_meeting_synced" bigint, "first_summary_viewed" bigint, "fully_activated" bigint, "fathom_rate" numeric, "meeting_synced_rate" numeric, "summary_viewed_rate" numeric, "activation_rate" numeric, "avg_days_to_activation" numeric)
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT 
    cohort_week,
    'Week ' || week_number || ' (' || to_char(cohort_week, 'Mon DD') || ')' AS week_label,
    total_users,
    fathom_connected,
    first_meeting_synced,
    first_summary_viewed,
    fully_activated,
    fathom_rate,
    meeting_synced_rate,
    summary_viewed_rate,
    activation_rate,
    avg_days_to_activation
  FROM user_weekly_cohorts
  WHERE cohort_week >= NOW() - (p_weeks || ' weeks')::INTERVAL
  ORDER BY cohort_week DESC
  LIMIT p_weeks;
$$;

-- ALTER FUNCTION "public"."get_cohort_analysis"("p_weeks" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_cohort_analysis"("p_weeks" integer) IS 'Get weekly cohort breakdown with activation rates';

CREATE OR REPLACE FUNCTION "public"."get_communication_frequency"("contact_id_param" "uuid", "days" integer DEFAULT 30) RETURNS numeric
    LANGUAGE "sql" STABLE
    SET "search_path" TO ''
    AS $$
  SELECT
    CASE
      WHEN days > 0 THEN (COUNT(*)::NUMERIC / days::NUMERIC) * 7
      ELSE 0
    END
  FROM communication_events
  WHERE contact_id = contact_id_param
    AND event_timestamp >= NOW() - (days || ' days')::INTERVAL;
$$;

-- ALTER FUNCTION "public"."get_communication_frequency"("contact_id_param" "uuid", "days" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_competitor_analysis"("p_org_id" "uuid", "p_date_from" timestamp with time zone DEFAULT NULL::timestamp with time zone, "p_date_to" timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS TABLE("competitor_name" "text", "mention_count" bigint, "positive_mentions" bigint, "negative_mentions" bigint, "neutral_mentions" bigint, "recent_meetings" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  WITH competitor_data AS (
    SELECT
      comp->>'name' as competitor_name,
      comp->>'sentiment' as sentiment,
      mc.meeting_id,
      m.start_time
    FROM meeting_classifications mc
    INNER JOIN meetings m ON mc.meeting_id = m.id
    CROSS JOIN jsonb_array_elements(mc.competitors) as comp
    WHERE mc.org_id = p_org_id
      AND (p_date_from IS NULL OR m.start_time >= p_date_from)
      AND (p_date_to IS NULL OR m.start_time <= p_date_to)
  )
  SELECT
    cd.competitor_name,
    COUNT(*) as mention_count,
    COUNT(*) FILTER (WHERE cd.sentiment = 'positive') as positive_mentions,
    COUNT(*) FILTER (WHERE cd.sentiment = 'negative') as negative_mentions,
    COUNT(*) FILTER (WHERE cd.sentiment = 'neutral') as neutral_mentions,
    (
      SELECT jsonb_agg(jsonb_build_object('meeting_id', sub.meeting_id, 'date', sub.start_time))
      FROM (
        SELECT DISTINCT ON (cd2.meeting_id) cd2.meeting_id, cd2.start_time
        FROM competitor_data cd2
        WHERE cd2.competitor_name = cd.competitor_name
        ORDER BY cd2.meeting_id, cd2.start_time DESC
        LIMIT 5
      ) sub
    ) as recent_meetings
  FROM competitor_data cd
  GROUP BY cd.competitor_name
  ORDER BY COUNT(*) DESC;
END;
$$;

-- ALTER FUNCTION "public"."get_competitor_analysis"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_competitor_analysis"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) IS 'Returns competitor mention analysis with sentiment breakdown';

CREATE OR REPLACE FUNCTION "public"."get_contact_note_stats"("target_contact_id" "uuid") RETURNS TABLE("total_notes" integer, "pinned_notes" integer, "recent_notes" integer, "last_note_date" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        COUNT(*)::INTEGER as total_notes,
        COUNT(*) FILTER (WHERE is_pinned = true)::INTEGER as pinned_notes,
        COUNT(*) FILTER (WHERE created_at >= NOW() - INTERVAL '7 days')::INTEGER as recent_notes,
        MAX(created_at) as last_note_date
    FROM contact_notes
    WHERE contact_id = target_contact_id;
END;
$$;

-- ALTER FUNCTION "public"."get_contact_note_stats"("target_contact_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_content_triggers_for_user"("p_user_id" "uuid") RETURNS TABLE("trigger_type" "text", "entity_type" "text", "entity_id" "uuid", "context" "jsonb", "priority" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  -- Upcoming meetings (next 7 days)
  RETURN QUERY
  SELECT
    'upcoming_meeting'::TEXT AS trigger_type,
    'meeting'::TEXT AS entity_type,
    m.id AS entity_id,
    jsonb_build_object(
      'title', m.title,
      'company', c.name,
      'date', m.scheduled_at,
      'prep_ready', EXISTS(SELECT 1 FROM meeting_ai_analysis WHERE meeting_id = m.id)
    ) AS context,
    90 AS priority
  FROM meetings m
  LEFT JOIN contacts c ON c.id = ANY(m.contact_ids)
  WHERE m.owner_user_id = p_user_id
    AND m.scheduled_at > NOW()
    AND m.scheduled_at < NOW() + INTERVAL '7 days'
  ORDER BY m.scheduled_at
  LIMIT 3;

  -- Deal updates (stage changes in last 7 days)
  RETURN QUERY
  SELECT
    'deal_update'::TEXT AS trigger_type,
    'deal'::TEXT AS entity_type,
    d.id AS entity_id,
    jsonb_build_object(
      'deal_name', d.name,
      'company', c.name,
      'update_type', 'Stage Change',
      'detail', 'Deal moved to ' || d.stage
    ) AS context,
    80 AS priority
  FROM deals d
  LEFT JOIN contacts c ON c.id = d.primary_contact_id
  WHERE d.user_id = p_user_id
    AND d.updated_at > NOW() - INTERVAL '7 days'
    AND d.stage IS NOT NULL
  ORDER BY d.updated_at DESC
  LIMIT 3;

  -- New emails from key contacts (last 3 days)
  RETURN QUERY
  SELECT
    'new_email'::TEXT AS trigger_type,
    'activity'::TEXT AS entity_type,
    a.id AS entity_id,
    jsonb_build_object(
      'from', c.email,
      'from_name', c.full_name,
      'subject', a.description,
      'is_important', (c.contact_type = 'champion' OR c.contact_type = 'decision_maker')
    ) AS context,
    70 AS priority
  FROM activities a
  JOIN contacts c ON c.id = a.contact_id
  WHERE a.user_id = p_user_id
    AND a.activity_type = 'email_received'
    AND a.activity_date > NOW() - INTERVAL '3 days'
  ORDER BY a.activity_date DESC
  LIMIT 5;
END;
$$;

-- ALTER FUNCTION "public"."get_content_triggers_for_user"("p_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_content_triggers_for_user"("p_user_id" "uuid") IS 'Get content-driven triggers for personalized re-engagement';

CREATE OR REPLACE FUNCTION "public"."get_content_with_topics"("p_content_id" "uuid") RETURNS TABLE("content_id" "uuid", "content" "text", "title" "text", "content_type" "text", "topics" "jsonb")
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO ''
    AS $$
BEGIN
  -- RLS policies automatically filter results by ownership

  RETURN QUERY
  SELECT
    mgc.id,
    mgc.content,
    mgc.title,
    mgc.content_type,
    mct.topics
  FROM meeting_generated_content mgc
  JOIN content_topic_links ctl ON ctl.content_id = mgc.id
  JOIN meeting_content_topics mct ON mct.meeting_id = mgc.meeting_id
  WHERE
    mgc.id = p_content_id
    AND mgc.deleted_at IS NULL
    AND mct.deleted_at IS NULL
  LIMIT 1;
END;
$$;

-- ALTER FUNCTION "public"."get_content_with_topics"("p_content_id" "uuid") OWNER TO "postgres";

-- ALTER FUNCTION "public"."get_cron_job_history"("p_job_name" "text", "p_limit" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_current_audit_context"() RETURNS TABLE("original_user_id" "uuid", "impersonated_user_id" "uuid", "is_impersonating" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    CASE 
      WHEN current_setting('app.original_user_id', true) = '' THEN NULL
      ELSE current_setting('app.original_user_id', true)::UUID
    END as original_user_id,
    CASE 
      WHEN current_setting('app.impersonated_user_id', true) = '' THEN NULL
      ELSE current_setting('app.impersonated_user_id', true)::UUID
    END as impersonated_user_id,
    COALESCE(current_setting('app.is_impersonating', true)::BOOLEAN, false) as is_impersonating;
END;
$$;

-- ALTER FUNCTION "public"."get_current_audit_context"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_current_cost_rate"("p_provider" "text", "p_model" "text") RETURNS TABLE("input_cost_per_million" numeric, "output_cost_per_million" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    cr.input_cost_per_million,
    cr.output_cost_per_million
  FROM cost_rates cr
  WHERE cr.provider = p_provider
    AND cr.model = p_model
    AND cr.effective_to IS NULL
  ORDER BY cr.effective_from DESC
  LIMIT 1;
END;
$$;

-- ALTER FUNCTION "public"."get_current_cost_rate"("p_provider" "text", "p_model" "text") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_days_since_last_contact"("contact_id_param" "uuid") RETURNS integer
    LANGUAGE "sql" STABLE
    SET "search_path" TO ''
    AS $$
  SELECT EXTRACT(DAY FROM NOW() - MAX(event_timestamp))::INTEGER
  FROM communication_events
  WHERE contact_id = contact_id_param;
$$;

-- ALTER FUNCTION "public"."get_days_since_last_contact"("contact_id_param" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_days_until_churn"("final_billing_date" "date") RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
  BEGIN
      IF final_billing_date IS NULL THEN
          RETURN NULL;
      END IF;

      RETURN final_billing_date - CURRENT_DATE;
  END;
  $$;

-- ALTER FUNCTION "public"."get_days_until_churn"("final_billing_date" "date") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_deal_active_risks"("p_deal_id" "uuid") RETURNS TABLE("signal_id" "uuid", "signal_type" "text", "severity" "text", "title" "text", "description" "text", "evidence" "jsonb", "confidence_score" numeric, "detected_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    drs.id as signal_id,
    drs.signal_type,
    drs.severity,
    drs.title,
    drs.description,
    drs.evidence,
    drs.confidence_score,
    drs.detected_at
  FROM deal_risk_signals drs
  WHERE drs.deal_id = p_deal_id
    AND drs.is_resolved = false
    AND drs.auto_dismissed = false
  ORDER BY
    CASE drs.severity
      WHEN 'critical' THEN 1
      WHEN 'high' THEN 2
      WHEN 'medium' THEN 3
      WHEN 'low' THEN 4
    END,
    drs.detected_at DESC;
END;
$$;

-- ALTER FUNCTION "public"."get_deal_active_risks"("p_deal_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_deal_active_risks"("p_deal_id" "uuid") IS 'Returns all active (unresolved) risk signals for a deal';

CREATE OR REPLACE FUNCTION "public"."get_deal_note_stats"("target_deal_id" "uuid") RETURNS TABLE("total_notes" integer, "pinned_notes" integer, "recent_notes" integer, "last_note_date" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
    RETURN QUERY
    SELECT
        COUNT(*)::INTEGER as total_notes,
        COUNT(*) FILTER (WHERE is_pinned = true)::INTEGER as pinned_notes,
        COUNT(*) FILTER (WHERE created_at >= NOW() - INTERVAL '7 days')::INTEGER as recent_notes,
        MAX(created_at) as last_note_date
    FROM deal_notes
    WHERE deal_id = target_deal_id;
END;
$$;

-- ALTER FUNCTION "public"."get_deal_note_stats"("target_deal_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_deal_truth_snapshot"("p_deal_id" "uuid") RETURNS TABLE("field_key" "text", "value" "text", "confidence" numeric, "source" "text", "contact_name" "text", "champion_strength" "text", "next_step_date" "date")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    dtf.field_key,
    dtf.value,
    dtf.confidence,
    dtf.source,
    c.name as contact_name,
    dtf.champion_strength,
    dtf.next_step_date
  FROM deal_truth_fields dtf
  LEFT JOIN contacts c ON dtf.contact_id = c.id
  WHERE dtf.deal_id = p_deal_id
  ORDER BY
    CASE dtf.field_key
      WHEN 'next_step' THEN 1
      WHEN 'economic_buyer' THEN 2
      WHEN 'champion' THEN 3
      WHEN 'success_metric' THEN 4
      WHEN 'pain' THEN 5
      WHEN 'top_risks' THEN 6
    END;
END;
$$;

-- ALTER FUNCTION "public"."get_deal_truth_snapshot"("p_deal_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_deal_truth_snapshot"("p_deal_id" "uuid") IS 'Returns all truth fields for a deal, used for Slack cards';

CREATE OR REPLACE FUNCTION "public"."get_deals_needing_attention"("p_org_id" "uuid", "p_user_id" "uuid" DEFAULT NULL::"uuid", "p_min_clarity_score" integer DEFAULT 50, "p_limit" integer DEFAULT 10) RETURNS TABLE("deal_id" "uuid", "deal_name" "text", "company_name" "text", "deal_value" numeric, "deal_stage" "text", "clarity_score" integer, "momentum_score" integer, "health_status" "text", "risk_level" "text", "close_plan_progress" integer, "owner_user_id" "uuid")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    d.id as deal_id,
    d.name as deal_name,
    c.name as company_name,
    d.value as deal_value,
    ds.name as deal_stage,
    COALESCE(dcs.clarity_score, 0) as clarity_score,
    COALESCE(dcs.momentum_score, 50) as momentum_score,
    COALESCE(dhs.health_status, 'unknown') as health_status,
    COALESCE(dra.overall_risk_level, 'unknown') as risk_level,
    COALESCE(dcs.close_plan_completed * 100 / NULLIF(dcs.close_plan_total, 0), 0)::INTEGER as close_plan_progress,
    d.user_id as owner_user_id
  FROM deals d
  LEFT JOIN companies c ON d.company_id = c.id
  LEFT JOIN deal_stages ds ON d.stage_id = ds.id
  LEFT JOIN deal_clarity_scores dcs ON d.id = dcs.deal_id
  LEFT JOIN deal_health_scores dhs ON d.id = dhs.deal_id
  LEFT JOIN deal_risk_aggregates dra ON d.id = dra.deal_id
  WHERE d.org_id = p_org_id
    AND d.status = 'active'
    AND (p_user_id IS NULL OR d.user_id = p_user_id)
    AND (
      COALESCE(dcs.clarity_score, 0) < p_min_clarity_score OR
      dhs.health_status IN ('warning', 'critical', 'stalled') OR
      dra.overall_risk_level IN ('high', 'critical')
    )
  ORDER BY
    COALESCE(dcs.momentum_score, 0) ASC,
    d.value DESC NULLS LAST
  LIMIT p_limit;
END;
$$;

-- ALTER FUNCTION "public"."get_deals_needing_attention"("p_org_id" "uuid", "p_user_id" "uuid", "p_min_clarity_score" integer, "p_limit" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_deals_needing_attention"("p_org_id" "uuid", "p_user_id" "uuid", "p_min_clarity_score" integer, "p_limit" integer) IS 'Returns deals with low clarity or at-risk status';

CREATE TABLE IF NOT EXISTS "public"."waitlist_email_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "template_name" "text" NOT NULL,
    "template_type" "text" NOT NULL,
    "description" "text",
    "subject_line" "text" NOT NULL,
    "email_body" "text" NOT NULL,
    "is_default" boolean DEFAULT false,
    "is_active" boolean DEFAULT true,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "waitlist_email_templates_template_type_check" CHECK (("template_type" = ANY (ARRAY['access_grant'::"text", 'reminder'::"text", 'welcome'::"text"])))
);

-- ALTER TABLE "public"."waitlist_email_templates" OWNER TO "postgres";

COMMENT ON TABLE "public"."waitlist_email_templates" IS 'Customizable email templates for waitlist invitations and user communications';

COMMENT ON COLUMN "public"."waitlist_email_templates"."template_type" IS 'Type of template: access_grant, reminder, or welcome';

COMMENT ON COLUMN "public"."waitlist_email_templates"."email_body" IS 'HTML email body with {{variable}} placeholders for dynamic content';

COMMENT ON COLUMN "public"."waitlist_email_templates"."is_default" IS 'Only one default template per type allowed';

CREATE OR REPLACE FUNCTION "public"."get_default_waitlist_email_template"("p_template_type" "text") RETURNS "public"."waitlist_email_templates"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  template_record waitlist_email_templates;
BEGIN
  SELECT * INTO template_record
  FROM waitlist_email_templates
  WHERE template_type = p_template_type
    AND is_default = true
    AND is_active = true
  LIMIT 1;

  RETURN template_record;
END;
$$;

-- ALTER FUNCTION "public"."get_default_waitlist_email_template"("p_template_type" "text") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_email_open_rate"("contact_id_param" "uuid", "days" integer DEFAULT 30) RETURNS integer
    LANGUAGE "sql" STABLE
    SET "search_path" TO ''
    AS $$
  SELECT
    CASE
      WHEN COUNT(*) FILTER (WHERE event_type = 'email_sent') > 0 THEN
        ROUND((COUNT(*) FILTER (WHERE event_type = 'email_sent' AND was_opened = TRUE)::NUMERIC /
               COUNT(*) FILTER (WHERE event_type = 'email_sent')::NUMERIC) * 100)::INTEGER
      ELSE 0
    END
  FROM communication_events
  WHERE contact_id = contact_id_param
    AND event_timestamp >= NOW() - (days || ' days')::INTERVAL;
$$;

-- ALTER FUNCTION "public"."get_email_open_rate"("contact_id_param" "uuid", "days" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_field_history"("p_table_name" "text", "p_record_id" "uuid", "p_field_name" "text", "p_limit" integer DEFAULT 50) RETURNS TABLE("changed_at" timestamp with time zone, "old_value" "text", "new_value" "text", "changed_by" "uuid")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    audit_logs.changed_at,
    old_data->>p_field_name as old_value,
    new_data->>p_field_name as new_value,
    user_id as changed_by
  FROM audit_logs
  WHERE table_name = p_table_name
    AND record_id = p_record_id
    AND (
      p_field_name = ANY(audit_logs.changed_fields)
      OR action IN ('INSERT', 'DELETE')
    )
  ORDER BY audit_logs.changed_at DESC
  LIMIT p_limit;
END;
$$;

-- ALTER FUNCTION "public"."get_field_history"("p_table_name" "text", "p_record_id" "uuid", "p_field_name" "text", "p_limit" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_free_tier_plan"() RETURNS TABLE("id" "uuid", "name" "text", "slug" "text", "max_meetings_per_month" integer, "max_users" integer, "features" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
  BEGIN
    RETURN QUERY
    SELECT
      sp.id,
      sp.name,
      sp.slug,
      sp.max_meetings_per_month,
      sp.max_users,
      sp.features
    FROM subscription_plans sp
    WHERE sp.is_free_tier = true
    AND sp.is_active = true
    LIMIT 1;
  END;
  $$;

-- ALTER FUNCTION "public"."get_free_tier_plan"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_free_tier_plan"() IS 'Returns the free tier plan details';

CREATE OR REPLACE FUNCTION "public"."get_global_topics_filtered"("p_user_id" "uuid", "p_date_from" timestamp with time zone DEFAULT NULL::timestamp with time zone, "p_date_to" timestamp with time zone DEFAULT NULL::timestamp with time zone, "p_company_ids" "uuid"[] DEFAULT NULL::"uuid"[], "p_contact_ids" "uuid"[] DEFAULT NULL::"uuid"[], "p_search_query" "text" DEFAULT NULL::"text", "p_sort_by" "text" DEFAULT 'relevance'::"text", "p_limit" integer DEFAULT 20, "p_offset" integer DEFAULT 0) RETURNS TABLE("id" "uuid", "canonical_title" "text", "canonical_description" "text", "source_count" integer, "first_seen_at" timestamp with time zone, "last_seen_at" timestamp with time zone, "relevance_score" numeric, "companies" "text"[], "contacts" "text"[], "meeting_count" bigint)
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  WITH filtered_sources AS (
    SELECT
      gts.global_topic_id,
      gts.company_id,
      gts.contact_id,
      gts.meeting_id
    FROM global_topic_sources gts
    JOIN global_topics gt ON gt.id = gts.global_topic_id
    WHERE gt.user_id = p_user_id
      AND gt.deleted_at IS NULL
      AND gt.is_archived = false
      AND (p_date_from IS NULL OR gts.meeting_date >= p_date_from)
      AND (p_date_to IS NULL OR gts.meeting_date <= p_date_to)
      AND (p_company_ids IS NULL OR gts.company_id = ANY(p_company_ids))
      AND (p_contact_ids IS NULL OR gts.contact_id = ANY(p_contact_ids))
  ),
  topic_stats AS (
    SELECT
      fs.global_topic_id,
      array_agg(DISTINCT c.name) FILTER (WHERE c.name IS NOT NULL) as companies,
      array_agg(DISTINCT ct.name) FILTER (WHERE ct.name IS NOT NULL) as contacts,
      COUNT(DISTINCT fs.meeting_id) as meeting_count
    FROM filtered_sources fs
    LEFT JOIN companies c ON c.id = fs.company_id
    LEFT JOIN contacts ct ON ct.id = fs.contact_id
    GROUP BY fs.global_topic_id
  )
  SELECT
    gt.id,
    gt.canonical_title,
    gt.canonical_description,
    gt.source_count,
    gt.first_seen_at,
    gt.last_seen_at,
    gt.relevance_score,
    COALESCE(ts.companies, '{}') as companies,
    COALESCE(ts.contacts, '{}') as contacts,
    COALESCE(ts.meeting_count, 0) as meeting_count
  FROM global_topics gt
  JOIN topic_stats ts ON ts.global_topic_id = gt.id
  WHERE gt.user_id = p_user_id
    AND gt.deleted_at IS NULL
    AND gt.is_archived = false
    AND (
      p_search_query IS NULL
      OR to_tsvector('english', gt.canonical_title || ' ' || COALESCE(gt.canonical_description, ''))
         @@ plainto_tsquery('english', p_search_query)
    )
  ORDER BY
    CASE WHEN p_sort_by = 'relevance' THEN gt.relevance_score END DESC NULLS LAST,
    CASE WHEN p_sort_by = 'frequency' THEN gt.source_count END DESC NULLS LAST,
    CASE WHEN p_sort_by = 'recency' THEN gt.last_seen_at END DESC NULLS LAST,
    gt.relevance_score DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

-- ALTER FUNCTION "public"."get_global_topics_filtered"("p_user_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_company_ids" "uuid"[], "p_contact_ids" "uuid"[], "p_search_query" "text", "p_sort_by" "text", "p_limit" integer, "p_offset" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_global_topics_stats"("p_user_id" "uuid") RETURNS TABLE("total_topics" bigint, "total_meetings" bigint, "total_companies" bigint, "total_contacts" bigint, "avg_sources_per_topic" numeric, "newest_topic_date" timestamp with time zone, "oldest_topic_date" timestamp with time zone)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    (SELECT COUNT(DISTINCT gt.id) FROM global_topics gt WHERE gt.user_id = p_user_id AND gt.deleted_at IS NULL AND gt.is_archived = false) as total_topics,
    (SELECT COUNT(DISTINCT gts.meeting_id) FROM global_topic_sources gts JOIN global_topics gt ON gt.id = gts.global_topic_id WHERE gt.user_id = p_user_id AND gt.deleted_at IS NULL) as total_meetings,
    (SELECT COUNT(DISTINCT gts.company_id) FROM global_topic_sources gts JOIN global_topics gt ON gt.id = gts.global_topic_id WHERE gt.user_id = p_user_id AND gt.deleted_at IS NULL AND gts.company_id IS NOT NULL) as total_companies,
    (SELECT COUNT(DISTINCT gts.contact_id) FROM global_topic_sources gts JOIN global_topics gt ON gt.id = gts.global_topic_id WHERE gt.user_id = p_user_id AND gt.deleted_at IS NULL AND gts.contact_id IS NOT NULL) as total_contacts,
    (SELECT ROUND(AVG(gt.source_count)::DECIMAL, 2) FROM global_topics gt WHERE gt.user_id = p_user_id AND gt.deleted_at IS NULL AND gt.is_archived = false) as avg_sources_per_topic,
    (SELECT MAX(gt.last_seen_at) FROM global_topics gt WHERE gt.user_id = p_user_id AND gt.deleted_at IS NULL) as newest_topic_date,
    (SELECT MIN(gt.first_seen_at) FROM global_topics gt WHERE gt.user_id = p_user_id AND gt.deleted_at IS NULL) as oldest_topic_date;
END;
$$;

-- ALTER FUNCTION "public"."get_global_topics_stats"("p_user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_google_access_token"("p_user_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  v_access_token TEXT;
BEGIN
  -- Get the access token from google_integrations table
  SELECT access_token INTO v_access_token
  FROM google_integrations
  WHERE user_id = p_user_id
    AND is_active = true
  LIMIT 1;
  
  RETURN v_access_token;
END;
$$;

-- ALTER FUNCTION "public"."get_google_access_token"("p_user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_health_score_trend"("relationship_health_id_param" "uuid", "days" integer DEFAULT 30) RETURNS TABLE("date" "date", "score" integer, "status" "text")
    LANGUAGE "sql" STABLE
    SET "search_path" TO ''
    AS $$
  SELECT
    snapshot_at::DATE AS date,
    overall_health_score AS score,
    health_status AS status
  FROM relationship_health_history
  WHERE relationship_health_id = relationship_health_id_param
    AND snapshot_at >= NOW() - (days || ' days')::INTERVAL
  ORDER BY snapshot_at ASC;
$$;

-- ALTER FUNCTION "public"."get_health_score_trend"("relationship_health_id_param" "uuid", "days" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_high_risk_deals"("p_org_id" "uuid", "p_min_risk_level" "text" DEFAULT 'medium'::"text") RETURNS TABLE("deal_id" "uuid", "deal_name" "text", "company_name" "text", "deal_value" numeric, "deal_stage" "text", "risk_level" "text", "risk_score" integer, "active_signals_count" integer, "top_risk_signal" "text", "risk_summary" "text", "owner_user_id" "uuid")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    d.id as deal_id,
    d.name as deal_name,
    c.name as company_name,
    d.value as deal_value,
    ds.name as deal_stage,
    dra.overall_risk_level as risk_level,
    dra.risk_score,
    dra.active_signals_count,
    (
      SELECT drs.title
      FROM deal_risk_signals drs
      WHERE drs.deal_id = d.id AND NOT drs.is_resolved
      ORDER BY
        CASE drs.severity
          WHEN 'critical' THEN 1
          WHEN 'high' THEN 2
          WHEN 'medium' THEN 3
          WHEN 'low' THEN 4
        END
      LIMIT 1
    ) as top_risk_signal,
    dra.risk_summary,
    d.user_id as owner_user_id
  FROM deal_risk_aggregates dra
  INNER JOIN deals d ON dra.deal_id = d.id
  LEFT JOIN companies c ON d.company_id = c.id
  LEFT JOIN deal_stages ds ON d.stage_id = ds.id
  WHERE dra.org_id = p_org_id
    AND dra.active_signals_count > 0
    AND (
      (p_min_risk_level = 'low') OR
      (p_min_risk_level = 'medium' AND dra.overall_risk_level IN ('medium', 'high', 'critical')) OR
      (p_min_risk_level = 'high' AND dra.overall_risk_level IN ('high', 'critical')) OR
      (p_min_risk_level = 'critical' AND dra.overall_risk_level = 'critical')
    )
  ORDER BY dra.risk_score DESC, dra.active_signals_count DESC;
END;
$$;

-- ALTER FUNCTION "public"."get_high_risk_deals"("p_org_id" "uuid", "p_min_risk_level" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_high_risk_deals"("p_org_id" "uuid", "p_min_risk_level" "text") IS 'Returns deals above a certain risk threshold for an org';

CREATE OR REPLACE FUNCTION "public"."get_highest_ghost_signal_severity"("relationship_health_id_param" "uuid") RETURNS "text"
    LANGUAGE "sql" STABLE
    SET "search_path" TO ''
    AS $$
  SELECT
    CASE
      WHEN COUNT(*) FILTER (WHERE severity = 'critical') > 0 THEN 'critical'
      WHEN COUNT(*) FILTER (WHERE severity = 'high') > 0 THEN 'high'
      WHEN COUNT(*) FILTER (WHERE severity = 'medium') > 0 THEN 'medium'
      WHEN COUNT(*) FILTER (WHERE severity = 'low') > 0 THEN 'low'
      ELSE 'none'
    END
  FROM ghost_detection_signals
  WHERE relationship_health_id = relationship_health_id_param
    AND resolved_at IS NULL;
$$;

-- ALTER FUNCTION "public"."get_highest_ghost_signal_severity"("relationship_health_id_param" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_intervention_success_rate"("user_id_param" "uuid") RETURNS TABLE("total_sent" integer, "total_replied" integer, "total_recovered" integer, "response_rate_percent" integer, "recovery_rate_percent" integer)
    LANGUAGE "sql" STABLE
    SET "search_path" TO ''
    AS $$
  SELECT
    COUNT(*)::INTEGER AS total_sent,
    COUNT(*) FILTER (WHERE status IN ('replied', 'recovered'))::INTEGER AS total_replied,
    COUNT(*) FILTER (WHERE status = 'recovered')::INTEGER AS total_recovered,
    CASE
      WHEN COUNT(*) > 0 THEN ROUND((COUNT(*) FILTER (WHERE status IN ('replied', 'recovered'))::NUMERIC / COUNT(*)::NUMERIC) * 100)::INTEGER
      ELSE 0
    END AS response_rate_percent,
    CASE
      WHEN COUNT(*) > 0 THEN ROUND((COUNT(*) FILTER (WHERE status = 'recovered')::NUMERIC / COUNT(*)::NUMERIC) * 100)::INTEGER
      ELSE 0
    END AS recovery_rate_percent
  FROM interventions
  WHERE user_id = user_id_param
    AND status <> 'pending'
    AND sent_at IS NOT NULL;
$$;

-- ALTER FUNCTION "public"."get_intervention_success_rate"("user_id_param" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_last_communication_date"("contact_id_param" "uuid") RETURNS timestamp with time zone
    LANGUAGE "sql" STABLE
    SET "search_path" TO ''
    AS $$
  SELECT MAX(event_timestamp)
  FROM communication_events
  WHERE contact_id = contact_id_param;
$$;

-- ALTER FUNCTION "public"."get_last_communication_date"("contact_id_param" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_last_response_date"("contact_id_param" "uuid") RETURNS timestamp with time zone
    LANGUAGE "sql" STABLE
    SET "search_path" TO ''
    AS $$
  SELECT MAX(event_timestamp)
  FROM communication_events
  WHERE contact_id = contact_id_param
    AND direction = 'inbound';
$$;

-- ALTER FUNCTION "public"."get_last_response_date"("contact_id_param" "uuid") OWNER TO "postgres";

-- ALTER FUNCTION "public"."get_latest_content"("p_meeting_id" "uuid", "p_content_type" "text") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_meeting_classification_counts"("p_org_id" "uuid", "p_date_from" timestamp with time zone DEFAULT NULL::timestamp with time zone, "p_date_to" timestamp with time zone DEFAULT NULL::timestamp with time zone, "p_owner_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("total_meetings" bigint, "forward_movement_count" bigint, "proposal_request_count" bigint, "pricing_discussion_count" bigint, "competitor_mention_count" bigint, "objection_count" bigint, "demo_request_count" bigint, "positive_outcome_count" bigint, "negative_outcome_count" bigint, "next_steps_count" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(*) as total_meetings,
    COUNT(*) FILTER (WHERE mc.has_forward_movement = true) as forward_movement_count,
    COUNT(*) FILTER (WHERE mc.has_proposal_request = true) as proposal_request_count,
    COUNT(*) FILTER (WHERE mc.has_pricing_discussion = true) as pricing_discussion_count,
    COUNT(*) FILTER (WHERE mc.has_competitor_mention = true) as competitor_mention_count,
    COUNT(*) FILTER (WHERE mc.has_objection = true) as objection_count,
    COUNT(*) FILTER (WHERE mc.has_demo_request = true) as demo_request_count,
    COUNT(*) FILTER (WHERE mc.outcome = 'positive') as positive_outcome_count,
    COUNT(*) FILTER (WHERE mc.outcome = 'negative') as negative_outcome_count,
    COUNT(*) FILTER (WHERE mc.has_next_steps = true) as next_steps_count
  FROM meeting_classifications mc
  INNER JOIN meetings m ON mc.meeting_id = m.id
  WHERE mc.org_id = p_org_id
    AND (p_date_from IS NULL OR m.start_time >= p_date_from)
    AND (p_date_to IS NULL OR m.start_time <= p_date_to)
    AND (p_owner_user_id IS NULL OR m.owner_user_id = p_owner_user_id);
END;
$$;

-- ALTER FUNCTION "public"."get_meeting_classification_counts"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_owner_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_meeting_classification_counts"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_owner_user_id" "uuid") IS 'Returns count breakdown of meeting classifications for an org';

CREATE OR REPLACE FUNCTION "public"."get_meeting_index_status"("p_user_id" "uuid") RETURNS TABLE("indexed_count" bigint, "total_meetings" bigint, "pending_count" bigint, "failed_count" bigint, "last_indexed_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
  BEGIN
    RETURN QUERY
    SELECT
      COUNT(mfi.id) FILTER (WHERE mfi.status =
  'indexed'),
      COUNT(DISTINCT m.id),
      COUNT(miq.id),
      COUNT(mfi.id) FILTER (WHERE mfi.status =
  'failed'),
      MAX(mfi.indexed_at)
    FROM meetings m
    LEFT JOIN meeting_file_search_index mfi ON
  m.id = mfi.meeting_id AND mfi.user_id =
  p_user_id
    LEFT JOIN meeting_index_queue miq ON m.id =
  miq.meeting_id
    WHERE m.owner_user_id = p_user_id AND
  m.transcript_text IS NOT NULL AND
  m.transcript_text != '';
  END;
  $$;

-- ALTER FUNCTION "public"."get_meeting_index_status"("p_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_meeting_index_status"("p_user_id" "uuid") IS 'Returns indexing status summary for a user';

CREATE OR REPLACE FUNCTION "public"."get_meeting_index_status_v2"("p_requesting_user_id" "uuid", "p_target_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("indexed_count" bigint, "total_meetings" bigint, "pending_count" bigint, "failed_count" bigint, "last_indexed_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
  BEGIN
    RETURN QUERY
    SELECT
      COUNT(mfi.id) FILTER (WHERE mfi.status =
  'indexed'),
      COUNT(DISTINCT m.id),
      COUNT(miq.id),
      COUNT(mfi.id) FILTER (WHERE mfi.status =
  'failed'),
      MAX(mfi.indexed_at)
    FROM meetings m
    LEFT JOIN meeting_file_search_index mfi ON
  m.id = mfi.meeting_id
    LEFT JOIN meeting_index_queue miq ON m.id =
  miq.meeting_id
    WHERE (p_target_user_id IS NULL OR
  m.owner_user_id = p_target_user_id)
      AND m.transcript_text IS NOT NULL AND
  m.transcript_text != '';
  END;
  $$;

-- ALTER FUNCTION "public"."get_meeting_index_status_v2"("p_requesting_user_id" "uuid", "p_target_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_meeting_index_status_v2"("p_requesting_user_id" "uuid", "p_target_user_id" "uuid") IS 'Returns indexing status summary - pass NULL for p_target_user_id to get all team meetings';

CREATE OR REPLACE FUNCTION "public"."get_meeting_retry_status"("p_meeting_id" "uuid") RETURNS TABLE("meeting_id" "uuid", "has_transcript" boolean, "retry_job_status" "text", "attempt_count" integer, "max_attempts" integer, "next_retry_at" timestamp with time zone, "last_error" "text", "transcript_fetch_attempts" integer, "last_transcript_fetch_at" timestamp with time zone)
    LANGUAGE "sql" STABLE
    SET "search_path" TO ''
    AS $$
  SELECT 
    m.id as meeting_id,
    (m.transcript_text IS NOT NULL) as has_transcript,
    COALESCE(rtj.status, 'none') as retry_job_status,
    COALESCE(rtj.attempt_count, 0) as attempt_count,
    COALESCE(rtj.max_attempts, 5) as max_attempts,
    rtj.next_retry_at,
    rtj.last_error,
    COALESCE(m.transcript_fetch_attempts, 0) as transcript_fetch_attempts,
    m.last_transcript_fetch_at
  FROM meetings m
  LEFT JOIN fathom_transcript_retry_jobs rtj ON rtj.meeting_id = m.id 
    AND rtj.status IN ('pending', 'processing', 'failed')
  WHERE m.id = p_meeting_id;
$$;

-- ALTER FUNCTION "public"."get_meeting_retry_status"("p_meeting_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_meeting_retry_status"("p_meeting_id" "uuid") IS 'Get retry status and transcript fetch info for a specific meeting';

CREATE OR REPLACE FUNCTION "public"."get_meeting_structured_summary"("p_meeting_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_summary JSONB;
BEGIN
  SELECT row_to_json(mss.*)::JSONB
  INTO v_summary
  FROM meeting_structured_summaries mss
  WHERE mss.meeting_id = p_meeting_id;

  RETURN COALESCE(v_summary, '{}'::JSONB);
END;
$$;

-- ALTER FUNCTION "public"."get_meeting_structured_summary"("p_meeting_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_meeting_structured_summary"("p_meeting_id" "uuid") IS 'Returns structured summary for a specific meeting';

-- ALTER FUNCTION "public"."get_meetings_by_classification"("p_org_id" "uuid", "p_filter_type" "text", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_owner_user_id" "uuid", "p_limit" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_meetings_by_classification"("p_org_id" "uuid", "p_filter_type" "text", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_owner_user_id" "uuid", "p_limit" integer) IS 'Returns meetings matching a specific classification filter';

CREATE OR REPLACE FUNCTION "public"."get_meetings_for_drill_down"("p_org_id" "uuid", "p_metric_type" "text", "p_period_days" integer DEFAULT 30, "p_user_id" "uuid" DEFAULT NULL::"uuid", "p_limit" integer DEFAULT 50) RETURNS TABLE("meeting_id" "uuid", "title" "text", "meeting_date" timestamp with time zone, "owner_user_id" "uuid", "owner_name" "text", "company_name" "text", "sentiment_score" numeric, "talk_time_pct" numeric, "outcome" "text", "has_forward_movement" boolean, "has_objection" boolean, "duration_minutes" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    m.id as meeting_id,
    m.title,
    m.meeting_start as meeting_date,
    m.owner_user_id,
    COALESCE(
      NULLIF(TRIM(CONCAT(COALESCE(p.first_name, ''), ' ', COALESCE(p.last_name, ''))), ''),
      p.email
    ) as owner_name,
    c.name as company_name,
    m.sentiment_score,
    m.talk_time_rep_pct as talk_time_pct,
    mc.outcome,
    mc.has_forward_movement,
    mc.has_objection,
    m.duration_minutes
  FROM meetings m
  LEFT JOIN profiles p ON m.owner_user_id = p.id
  LEFT JOIN companies c ON m.company_id = c.id
  LEFT JOIN meeting_classifications mc ON mc.meeting_id = m.id
  WHERE m.org_id = p_org_id
    AND m.meeting_start >= NOW() - (p_period_days || ' days')::INTERVAL
    AND m.meeting_start IS NOT NULL
    AND (p_user_id IS NULL OR m.owner_user_id = p_user_id)
    AND (
      p_metric_type = 'all' OR
      (p_metric_type = 'positive_sentiment' AND m.sentiment_score > 0.2) OR
      (p_metric_type = 'negative_sentiment' AND m.sentiment_score < -0.2) OR
      (p_metric_type = 'forward_movement' AND mc.has_forward_movement = true) OR
      (p_metric_type = 'objection' AND mc.has_objection = true) OR
      (p_metric_type = 'positive_outcome' AND mc.outcome = 'positive') OR
      (p_metric_type = 'negative_outcome' AND mc.outcome = 'negative')
    )
  ORDER BY m.meeting_start DESC
  LIMIT p_limit;
END;
$$;

-- ALTER FUNCTION "public"."get_meetings_for_drill_down"("p_org_id" "uuid", "p_metric_type" "text", "p_period_days" integer, "p_user_id" "uuid", "p_limit" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_meetings_for_drill_down"("p_org_id" "uuid", "p_metric_type" "text", "p_period_days" integer, "p_user_id" "uuid", "p_limit" integer) IS 'Returns filtered meeting list for drill-down modal';

CREATE OR REPLACE FUNCTION "public"."get_meetings_with_competitors"("p_org_id" "uuid", "p_date_from" timestamp with time zone DEFAULT NULL::timestamp with time zone, "p_date_to" timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS TABLE("meeting_id" "uuid", "meeting_title" "text", "meeting_date" timestamp with time zone, "owner_user_id" "uuid", "company_name" "text", "competitor_mentions" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    m.id as meeting_id,
    m.title as meeting_title,
    m.start_time as meeting_date,
    m.owner_user_id,
    c.name as company_name,
    mss.competitor_mentions
  FROM meeting_structured_summaries mss
  INNER JOIN meetings m ON mss.meeting_id = m.id
  LEFT JOIN companies c ON m.company_id = c.id
  WHERE mss.org_id = p_org_id
    AND jsonb_array_length(mss.competitor_mentions) > 0
    AND (p_date_from IS NULL OR m.start_time >= p_date_from)
    AND (p_date_to IS NULL OR m.start_time <= p_date_to)
  ORDER BY m.start_time DESC;
END;
$$;

-- ALTER FUNCTION "public"."get_meetings_with_competitors"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_meetings_with_competitors"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) IS 'Returns meetings where competitors were mentioned';

CREATE OR REPLACE FUNCTION "public"."get_meetings_with_forward_movement"("p_org_id" "uuid", "p_date_from" timestamp with time zone DEFAULT NULL::timestamp with time zone, "p_date_to" timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS TABLE("meeting_id" "uuid", "meeting_title" "text", "meeting_date" timestamp with time zone, "owner_user_id" "uuid", "company_name" "text", "positive_signals" "jsonb", "next_steps" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    m.id as meeting_id,
    m.title as meeting_title,
    m.start_time as meeting_date,
    m.owner_user_id,
    c.name as company_name,
    mss.outcome_signals->'positive_signals' as positive_signals,
    mss.outcome_signals->'next_steps' as next_steps
  FROM meeting_structured_summaries mss
  INNER JOIN meetings m ON mss.meeting_id = m.id
  LEFT JOIN companies c ON m.company_id = c.id
  WHERE mss.org_id = p_org_id
    AND (mss.outcome_signals->>'forward_movement')::boolean = true
    AND (p_date_from IS NULL OR m.start_time >= p_date_from)
    AND (p_date_to IS NULL OR m.start_time <= p_date_to)
  ORDER BY m.start_time DESC;
END;
$$;

-- ALTER FUNCTION "public"."get_meetings_with_forward_movement"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_meetings_with_forward_movement"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) IS 'Returns meetings where forward movement was detected';

CREATE OR REPLACE FUNCTION "public"."get_mrr_by_date_range"("p_start_date" "date", "p_end_date" "date", "p_currency" "text" DEFAULT NULL::"text") RETURNS TABLE("date" "date", "mrr_cents" bigint, "active_subscriptions" integer, "trialing_subscriptions" integer, "currency" "text")
    LANGUAGE "plpgsql" STABLE
    AS $$
BEGIN
  RETURN QUERY
  WITH date_series AS (
    SELECT generate_series(p_start_date, p_end_date, '1 day'::interval)::DATE as date
  ),
  daily_mrr AS (
    SELECT
      ds.date,
      COALESCE(SUM(
        CASE
          WHEN sfv.is_active AND sfv.started_at <= ds.date AND (sfv.canceled_at IS NULL OR sfv.canceled_at > ds.date)
          THEN sfv.normalized_mrr_cents
          ELSE 0
        END
      ), 0) as mrr_cents,
      COUNT(*) FILTER (
        WHERE sfv.is_active 
        AND sfv.started_at <= ds.date 
        AND (sfv.canceled_at IS NULL OR sfv.canceled_at > ds.date)
      ) as active_subscriptions,
      COUNT(*) FILTER (
        WHERE sfv.is_trialing 
        AND sfv.started_at <= ds.date 
        AND (sfv.canceled_at IS NULL OR sfv.canceled_at > ds.date)
      ) as trialing_subscriptions,
      COALESCE(p_currency, sfv.currency) as currency
    FROM date_series ds
    CROSS JOIN subscription_facts_view sfv
    WHERE (p_currency IS NULL OR sfv.currency = p_currency)
    GROUP BY ds.date, currency
  )
  SELECT * FROM daily_mrr
  ORDER BY date, currency;
END;
$$;

-- ALTER FUNCTION "public"."get_mrr_by_date_range"("p_start_date" "date", "p_end_date" "date", "p_currency" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_mrr_by_date_range"("p_start_date" "date", "p_end_date" "date", "p_currency" "text") IS 'Get MRR for a date range (daily breakdown)';

-- ALTER FUNCTION "public"."get_my_google_integration"() OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."proposal_jobs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "action" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "input_data" "jsonb" NOT NULL,
    "output_content" "text",
    "output_usage" "jsonb",
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "retry_count" integer DEFAULT 0,
    "max_retries" integer DEFAULT 3,
    CONSTRAINT "proposal_jobs_action_check" CHECK (("action" = ANY (ARRAY['generate_goals'::"text", 'generate_sow'::"text", 'generate_proposal'::"text"]))),
    CONSTRAINT "proposal_jobs_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text"])))
);

-- ALTER TABLE "public"."proposal_jobs" OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_next_proposal_job"() RETURNS "public"."proposal_jobs"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
    job proposal_jobs;
BEGIN
    SELECT * INTO job
    FROM proposal_jobs
    WHERE status = 'pending'
    ORDER BY created_at ASC
    LIMIT 1
    FOR UPDATE SKIP LOCKED;
    
    RETURN job;
END;
$$;

-- ALTER FUNCTION "public"."get_next_proposal_job"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_notification_candidates_for_testing"("p_org_id" "uuid" DEFAULT NULL::"uuid", "p_limit" integer DEFAULT 50) RETURNS TABLE("user_id" "uuid", "org_id" "uuid", "slack_user_id" "text", "email" "text", "full_name" "text", "segment" "text", "notification_fatigue_level" numeric, "preferred_notification_frequency" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    uem.user_id,
    uem.org_id,
    sum.slack_user_id,
    p.email,
    COALESCE(p.first_name || ' ' || p.last_name, p.email) AS full_name,
    uem.user_segment AS segment,
    uem.notification_fatigue_level,
    uem.preferred_notification_frequency
  FROM user_engagement_metrics uem
  JOIN profiles p ON p.id = uem.user_id
  LEFT JOIN slack_user_mappings sum ON sum.sixty_user_id = uem.user_id AND sum.org_id = uem.org_id
  WHERE
    (p_org_id IS NULL OR uem.org_id = p_org_id)
    AND (p.email IS NOT NULL OR sum.slack_user_id IS NOT NULL)
  ORDER BY uem.overall_engagement_score DESC
  LIMIT p_limit;
END;
$$;

-- ALTER FUNCTION "public"."get_notification_candidates_for_testing"("p_org_id" "uuid", "p_limit" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_notification_health_summary"() RETURNS json
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  health_summary JSON;
  sum_total_notifications INTEGER;
  total_users_with_notifications INTEGER;
  avg_notifications_per_user NUMERIC;
  rate_limit_reached_count INTEGER;
  top_notification_types JSONB;
BEGIN
  -- Get total notification counts
  SELECT
    SUM(total_notifications),
    COUNT(*),
    ROUND(AVG(total_notifications), 1)
  INTO
    sum_total_notifications,
    total_users_with_notifications,
    avg_notifications_per_user
  FROM notification_counts_by_user;

  -- Get rate limit status
  SELECT COUNT(*)
  INTO rate_limit_reached_count
  FROM notification_rate_limit_status
  WHERE limit_status IN ('HOURLY_LIMIT_REACHED', 'DAILY_LIMIT_REACHED');

  -- Get top notification types
  SELECT jsonb_agg(
    jsonb_build_object(
      'type', notification_type,
      'category', category,
      'count', total_count,
      'affected_users', affected_users
    )
  )
  INTO top_notification_types
  FROM (
    SELECT *
    FROM notification_type_breakdown
    ORDER BY total_count DESC
    LIMIT 5
  ) top_types;

  -- Build health summary
  health_summary := json_build_object(
    'timestamp', NOW(),
    'overall_health', CASE
      WHEN EXISTS (SELECT 1 FROM notification_flood_alerts WHERE alert_level = 'CRITICAL') THEN 'CRITICAL'
      WHEN EXISTS (SELECT 1 FROM notification_flood_alerts WHERE alert_level = 'HIGH') THEN 'DEGRADED'
      WHEN EXISTS (SELECT 1 FROM notification_flood_alerts WHERE alert_level = 'MEDIUM') THEN 'WARNING'
      ELSE 'HEALTHY'
    END,
    'statistics', json_build_object(
      'total_notifications', COALESCE(sum_total_notifications, 0),
      'users_with_notifications', COALESCE(total_users_with_notifications, 0),
      'avg_notifications_per_user', COALESCE(avg_notifications_per_user, 0),
      'users_at_rate_limit', COALESCE(rate_limit_reached_count, 0)
    ),
    'top_notification_types', COALESCE(top_notification_types, '[]'::jsonb),
    'flood_check', check_notification_floods('MEDIUM')
  );

  RETURN health_summary;
END;
$$;

-- ALTER FUNCTION "public"."get_notification_health_summary"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_notification_health_summary"() IS 'Get comprehensive notification system health summary. Returns: Overall health status, statistics, top notification types, and flood check results.';

CREATE OR REPLACE FUNCTION "public"."get_or_create_sync_status"("p_user_id" "uuid") RETURNS TABLE("id" "uuid", "user_id" "uuid", "sync_status" "text", "last_full_sync_at" timestamp with time zone, "last_incremental_sync_at" timestamp with time zone, "selected_list_id" "text", "selected_list_title" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Try to get existing sync status
  RETURN QUERY
  SELECT 
    s.id,
    s.user_id,
    s.sync_status,
    s.last_full_sync_at,
    s.last_incremental_sync_at,
    s.selected_list_id,
    s.selected_list_title
  FROM google_tasks_sync_status s
  WHERE s.user_id = p_user_id;
  
  -- If not found, create it
  IF NOT FOUND THEN
    RETURN QUERY
    INSERT INTO google_tasks_sync_status (
      user_id,
      sync_status,
      selected_list_id,
      selected_list_title
    )
    VALUES (
      p_user_id,
      'idle',
      NULL,
      NULL
    )
    RETURNING 
      google_tasks_sync_status.id,
      google_tasks_sync_status.user_id,
      google_tasks_sync_status.sync_status,
      google_tasks_sync_status.last_full_sync_at,
      google_tasks_sync_status.last_incremental_sync_at,
      google_tasks_sync_status.selected_list_id,
      google_tasks_sync_status.selected_list_title;
  END IF;
END;
$$;

-- ALTER FUNCTION "public"."get_or_create_sync_status"("p_user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_org_email_label_mode"("p_org_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql" STABLE
    AS $$
DECLARE
  v_mode TEXT;
BEGIN
  SELECT label_mode INTO v_mode
  FROM org_email_categorization_settings
  WHERE org_id = p_org_id;
  
  -- Default to internal-only if no settings exist
  RETURN COALESCE(v_mode, 'mode_a_internal_only');
END;
$$;

-- ALTER FUNCTION "public"."get_org_email_label_mode"("p_org_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_org_file_search_store"("p_org_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
  BEGIN
    RETURN (SELECT store_name FROM org_file_search_stores WHERE org_id = p_org_id);
  END;
  $$;

-- ALTER FUNCTION "public"."get_org_file_search_store"("p_org_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_org_internal_domain"("p_org_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_domain TEXT;
BEGIN
  SELECT company_domain INTO v_domain
  FROM organizations
  WHERE id = p_org_id;

  RETURN v_domain;
END;
$$;

-- ALTER FUNCTION "public"."get_org_internal_domain"("p_org_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_org_limits"("p_org_id" "uuid") RETURNS TABLE("max_users" integer, "max_meetings" integer, "max_ai_tokens" integer, "max_storage_mb" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    COALESCE(os.custom_max_users, sp.max_users) as max_users,
    COALESCE(os.custom_max_meetings, sp.max_meetings_per_month) as max_meetings,
    COALESCE(os.custom_max_ai_tokens, sp.max_ai_tokens_per_month) as max_ai_tokens,
    COALESCE(os.custom_max_storage_mb, sp.max_storage_mb) as max_storage_mb
  FROM organization_subscriptions os
  JOIN subscription_plans sp ON sp.id = os.plan_id
  WHERE os.org_id = p_org_id
  AND os.status IN ('active', 'trialing');
END;
$$;

-- ALTER FUNCTION "public"."get_org_limits"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_org_limits"("p_org_id" "uuid") IS 'Gets usage limits for an org (with custom overrides)';

CREATE OR REPLACE FUNCTION "public"."get_org_meeting_index_status"("p_org_id" "uuid", "p_target_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("indexed_count" bigint, "total_meetings" bigint, "pending_count" bigint, "failed_count" bigint, "last_indexed_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
  BEGIN
    RETURN QUERY
    SELECT
      COUNT(mfi.id) FILTER (WHERE mfi.status = 'indexed') as indexed_count,
      COUNT(DISTINCT m.id) as total_meetings,
      COUNT(miq.id) as pending_count,
      COUNT(mfi.id) FILTER (WHERE mfi.status = 'failed') as failed_count,
      MAX(mfi.indexed_at) as last_indexed_at
    FROM meetings m
    INNER JOIN organization_memberships om ON m.owner_user_id = om.user_id AND om.org_id =
  p_org_id
    LEFT JOIN meeting_file_search_index mfi ON m.id = mfi.meeting_id
    LEFT JOIN meeting_index_queue miq ON m.id = miq.meeting_id
    WHERE (p_target_user_id IS NULL OR m.owner_user_id = p_target_user_id)
      AND m.transcript_text IS NOT NULL AND m.transcript_text != '';
  END;
  $$;

-- ALTER FUNCTION "public"."get_org_meeting_index_status"("p_org_id" "uuid", "p_target_user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_org_member_counts"("p_org_id" "uuid") RETURNS TABLE("total_members" integer, "owners" integer, "admins" integer, "members" integer, "readonly_members" integer)
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    AS $$
BEGIN
  IF NOT can_access_org_data(p_org_id) THEN
    RAISE EXCEPTION 'Access denied to organization';
  END IF;

  RETURN QUERY
  SELECT
    COUNT(*)::INTEGER as total_members,
    COUNT(*) FILTER (WHERE role = 'owner')::INTEGER as owners,
    COUNT(*) FILTER (WHERE role = 'admin')::INTEGER as admins,
    COUNT(*) FILTER (WHERE role = 'member')::INTEGER as members,
    COUNT(*) FILTER (WHERE role = 'readonly')::INTEGER as readonly_members
  FROM organization_memberships
  WHERE org_id = p_org_id;
END;
$$;

-- ALTER FUNCTION "public"."get_org_member_counts"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_org_member_counts"("p_org_id" "uuid") IS 'Returns member counts by role for an organization';

CREATE OR REPLACE FUNCTION "public"."get_org_plan_features"("p_org_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  v_features JSONB;
BEGIN
  SELECT sp.features INTO v_features
  FROM organization_subscriptions os
  JOIN subscription_plans sp ON sp.id = os.plan_id
  WHERE os.org_id = p_org_id
  AND os.status IN ('active', 'trialing');

  RETURN COALESCE(v_features, '{}'::jsonb);
END;
$$;

-- ALTER FUNCTION "public"."get_org_plan_features"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_org_plan_features"("p_org_id" "uuid") IS 'Gets the feature flags for an org based on their plan';

CREATE OR REPLACE FUNCTION "public"."get_org_role"("p_user_id" "uuid", "p_org_id" "uuid") RETURNS "text"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT role
  FROM public.organization_memberships
  WHERE user_id = p_user_id
    AND org_id = p_org_id
  LIMIT 1;
$$;

-- ALTER FUNCTION "public"."get_org_role"("p_user_id" "uuid", "p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_org_role"("p_user_id" "uuid", "p_org_id" "uuid") IS 'Gets a user role in an organization (SECURITY DEFINER)';

CREATE OR REPLACE FUNCTION "public"."get_org_subscription_details"("p_org_id" "uuid") RETURNS TABLE("subscription_id" "uuid", "plan_id" "uuid", "plan_name" "text", "plan_slug" "text", "status" "text", "billing_cycle" "text", "price_monthly" integer, "price_yearly" integer, "currency" "text", "stripe_subscription_id" "text", "stripe_customer_id" "text", "current_period_start" timestamp with time zone, "current_period_end" timestamp with time zone, "trial_ends_at" timestamp with time zone, "cancel_at_period_end" boolean, "max_users" integer, "max_meetings_per_month" integer, "meeting_retention_months" integer, "included_seats" integer, "per_seat_price" integer, "features" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    os.id as subscription_id,
    os.plan_id,
    sp.name as plan_name,
    sp.slug as plan_slug,
    os.status,
    os.billing_cycle,
    sp.price_monthly,
    sp.price_yearly,
    sp.currency,
    os.stripe_subscription_id,
    os.stripe_customer_id,
    os.current_period_start,
    os.current_period_end,
    os.trial_ends_at,
    os.cancel_at_period_end,
    COALESCE(os.custom_max_users, sp.max_users) as max_users,
    COALESCE(os.custom_max_meetings, sp.max_meetings_per_month) as max_meetings_per_month,
    sp.meeting_retention_months,
    sp.included_seats,
    sp.per_seat_price,
    sp.features
  FROM organization_subscriptions os
  JOIN subscription_plans sp ON sp.id = os.plan_id
  WHERE os.org_id = p_org_id
  AND os.status IN ('active', 'trialing', 'past_due')
  LIMIT 1;
END;
$$;

-- ALTER FUNCTION "public"."get_org_subscription_details"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_org_subscription_details"("p_org_id" "uuid") IS 'Returns full subscription details with plan info';

-- ALTER FUNCTION "public"."get_org_team_members"("p_org_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_organization_context"("p_org_id" "uuid") RETURNS TABLE("context_key" "text", "value" "jsonb", "value_type" "text", "source" "text", "confidence" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    oc.context_key,
    oc.value,
    oc.value_type,
    oc.source,
    oc.confidence
  FROM organization_context oc
  WHERE oc.organization_id = p_org_id
  ORDER BY oc.context_key;
END;
$$;

-- ALTER FUNCTION "public"."get_organization_context"("p_org_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_organization_context_object"("p_org_id" "uuid") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_result JSONB := '{}';
  v_row RECORD;
BEGIN
  FOR v_row IN
    SELECT context_key, value
    FROM organization_context
    WHERE organization_id = p_org_id
  LOOP
    -- For string values stored as JSONB, extract the raw value
    -- For arrays/objects, keep the JSONB structure
    v_result := v_result || jsonb_build_object(v_row.context_key, v_row.value);
  END LOOP;

  RETURN v_result;
END;
$$;

-- ALTER FUNCTION "public"."get_organization_context_object"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_organization_context_object"("p_org_id" "uuid") IS 'Returns all organization context as a single JSONB object for skill template interpolation';

CREATE OR REPLACE FUNCTION "public"."get_organization_skills_for_agent"("p_org_id" "uuid") RETURNS TABLE("skill_key" "text", "category" "text", "frontmatter" "jsonb", "content" "text", "is_enabled" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    os.skill_id as skill_key,
    ps.category,
    COALESCE(os.compiled_frontmatter, ps.frontmatter) as frontmatter,
    COALESCE(os.compiled_content, ps.content_template) as content,
    os.is_enabled
  FROM organization_skills os
  JOIN platform_skills ps ON ps.skill_key = os.skill_id
  WHERE os.organization_id = p_org_id
    AND os.is_active = true
    AND ps.is_active = true
    AND os.is_enabled = true
  ORDER BY ps.category, os.skill_id;
END;
$$;

-- ALTER FUNCTION "public"."get_organization_skills_for_agent"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_organization_skills_for_agent"("p_org_id" "uuid") IS 'Returns all compiled skills for an organization in agent-executable format';

CREATE OR REPLACE FUNCTION "public"."get_organization_skills_summary"("p_org_id" "uuid") RETURNS TABLE("skill_id" "text", "skill_name" "text", "category" "text", "is_enabled" boolean, "is_compiled" boolean, "needs_compilation" boolean, "platform_version" integer, "org_version" integer, "last_compiled_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    os.skill_id,
    os.skill_name,
    ps.category,
    os.is_enabled,
    (os.last_compiled_at IS NOT NULL) as is_compiled,
    (os.last_compiled_at IS NULL OR os.platform_skill_version IS NULL OR os.platform_skill_version < ps.version) as needs_compilation,
    ps.version as platform_version,
    os.platform_skill_version as org_version,
    os.last_compiled_at
  FROM organization_skills os
  LEFT JOIN platform_skills ps ON ps.skill_key = os.skill_id
  WHERE os.organization_id = p_org_id
    AND os.is_active = true
  ORDER BY ps.category, os.skill_id;
END;
$$;

-- ALTER FUNCTION "public"."get_organization_skills_summary"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_organization_skills_summary"("p_org_id" "uuid") IS 'Returns a summary of skills with compilation status for an organization';

CREATE OR REPLACE FUNCTION "public"."get_pending_aggregation_count"("p_user_id" "uuid") RETURNS bigint
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)
    FROM topic_aggregation_queue
    WHERE user_id = p_user_id
      AND status = 'pending'
  );
END;
$$;

-- ALTER FUNCTION "public"."get_pending_aggregation_count"("p_user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_pending_ai_analysis"() RETURNS TABLE("action_item_id" "uuid", "task_id" "uuid", "title" "text", "category" "text", "priority" "text", "deadline_at" timestamp with time zone, "meeting_title" "text", "meeting_summary" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    mai.id as action_item_id,
    mai.task_id,
    mai.title,
    mai.category,
    mai.priority,
    mai.deadline_at,
    m.title as meeting_title,
    m.summary as meeting_summary
  FROM meeting_action_items mai
  JOIN meetings m ON m.id = mai.meeting_id
  WHERE mai.task_id IS NOT NULL
    AND mai.ai_analyzed_at IS NULL
    AND mai.sync_status = 'synced'
  ORDER BY mai.created_at DESC
  LIMIT 100; -- Process in batches
END;
$$;

-- ALTER FUNCTION "public"."get_pending_ai_analysis"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_pending_ai_analysis"() IS 'Get action items pending AI analysis (max 100)';

CREATE OR REPLACE FUNCTION "public"."get_pending_hitl_requests"("p_user_id" "uuid") RETURNS TABLE("id" "uuid", "execution_id" "text", "sequence_key" "text", "step_index" integer, "request_type" "text", "prompt" "text", "options" "jsonb", "default_value" "text", "timeout_minutes" integer, "timeout_action" "text", "expires_at" timestamp with time zone, "execution_context" "jsonb", "created_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    hr.id,
    hr.execution_id,
    hr.sequence_key,
    hr.step_index,
    hr.request_type,
    hr.prompt,
    hr.options,
    hr.default_value,
    hr.timeout_minutes,
    hr.timeout_action,
    hr.expires_at,
    hr.execution_context,
    hr.created_at
  FROM sequence_hitl_requests hr
  WHERE
    hr.status = 'pending'
    AND (hr.assigned_to_user_id = p_user_id OR hr.assigned_to_user_id IS NULL)
    AND hr.organization_id IN (
      SELECT om.organization_id
      FROM organization_memberships om
      WHERE om.user_id = p_user_id
    )
    AND (hr.expires_at IS NULL OR hr.expires_at > now())
  ORDER BY hr.created_at ASC;
END;
$$;

-- ALTER FUNCTION "public"."get_pending_hitl_requests"("p_user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_pending_notifications"("p_limit" integer DEFAULT 50, "p_channel" "text" DEFAULT NULL::"text") RETURNS TABLE("queue_id" "uuid", "user_id" "uuid", "org_id" "uuid", "notification_type" "text", "channel" "text", "priority" "text", "payload" "jsonb", "scheduled_for" timestamp with time zone, "optimal_send_time" timestamp with time zone, "metadata" "jsonb", "engagement_score" integer, "notification_fatigue" integer, "preferred_frequency" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    nq.id AS queue_id,
    nq.user_id,
    nq.org_id,
    nq.notification_type,
    nq.channel,
    nq.priority,
    nq.payload,
    nq.scheduled_for,
    nq.optimal_send_time,
    nq.metadata,
    uem.overall_engagement_score AS engagement_score,
    uem.notification_fatigue_level AS notification_fatigue,
    uem.preferred_notification_frequency AS preferred_frequency
  FROM notification_queue nq
  LEFT JOIN user_engagement_metrics uem ON uem.user_id = nq.user_id
  WHERE nq.status = 'pending'
    AND nq.scheduled_for <= NOW()
    AND (nq.send_deadline IS NULL OR nq.send_deadline > NOW())
    AND nq.is_batched = false
    AND (p_channel IS NULL OR nq.channel = p_channel)
  ORDER BY
    CASE nq.priority
      WHEN 'urgent' THEN 1
      WHEN 'high' THEN 2
      WHEN 'normal' THEN 3
      WHEN 'low' THEN 4
    END,
    nq.scheduled_for
  LIMIT p_limit;
END;
$$;

-- ALTER FUNCTION "public"."get_pending_notifications"("p_limit" integer, "p_channel" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_pending_notifications"("p_limit" integer, "p_channel" "text") IS 'Get notifications ready to be sent, ordered by priority';

-- ALTER FUNCTION "public"."get_pending_suggestions_count"("p_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_pending_suggestions_count"("p_user_id" "uuid") IS 'Get count of pending suggestions for current user';

CREATE OR REPLACE FUNCTION "public"."get_pending_transcript_retry_jobs"("p_batch_size" integer DEFAULT 50) RETURNS TABLE("id" "uuid", "meeting_id" "uuid", "user_id" "uuid", "recording_id" "text", "attempt_count" integer, "max_attempts" integer, "next_retry_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    rtj.id,
    rtj.meeting_id,
    rtj.user_id,
    rtj.recording_id,
    rtj.attempt_count,
    rtj.max_attempts,
    rtj.next_retry_at
  FROM fathom_transcript_retry_jobs rtj
  WHERE rtj.status = 'pending'
    AND rtj.next_retry_at <= NOW()
    AND rtj.attempt_count < rtj.max_attempts
  ORDER BY rtj.next_retry_at ASC
  LIMIT p_batch_size
  FOR UPDATE SKIP LOCKED;
END;
$$;

-- ALTER FUNCTION "public"."get_pending_transcript_retry_jobs"("p_batch_size" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_pending_transcript_retry_jobs"("p_batch_size" integer) IS 'Get next batch of jobs ready for retry (with row locking)';

CREATE OR REPLACE FUNCTION "public"."get_platform_skill"("p_skill_key" "text") RETURNS TABLE("id" "uuid", "skill_key" "text", "category" "text", "frontmatter" "jsonb", "content_template" "text", "version" integer, "is_active" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    ps.id,
    ps.skill_key,
    ps.category,
    ps.frontmatter,
    ps.content_template,
    ps.version,
    ps.is_active
  FROM platform_skills ps
  WHERE ps.skill_key = p_skill_key
    AND ps.is_active = true;
END;
$$;

-- ALTER FUNCTION "public"."get_platform_skill"("p_skill_key" "text") OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" "uuid" NOT NULL,
    "first_name" "text",
    "last_name" "text",
    "email" "text" NOT NULL,
    "stage" "text",
    "avatar_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_admin" boolean DEFAULT false,
    "clerk_user_id" "text",
    "last_login_at" timestamp with time zone,
    "auth_provider" "text" DEFAULT 'supabase'::"text",
    "bio" "text",
    "working_hours_start" integer DEFAULT 8,
    "working_hours_end" integer DEFAULT 18,
    "timezone" "text",
    "week_starts_on" smallint DEFAULT 1,
    CONSTRAINT "first_name_not_empty" CHECK ((("first_name" IS NULL) OR ("length"(TRIM(BOTH FROM "first_name")) > 0))),
    CONSTRAINT "last_name_not_empty" CHECK ((("last_name" IS NULL) OR ("length"(TRIM(BOTH FROM "last_name")) > 0))),
    CONSTRAINT "profiles_week_starts_on_check" CHECK (("week_starts_on" = ANY (ARRAY[0, 1]))),
    CONSTRAINT "valid_working_hours_end" CHECK ((("working_hours_end" >= 0) AND ("working_hours_end" <= 23))),
    CONSTRAINT "valid_working_hours_start" CHECK ((("working_hours_start" >= 0) AND ("working_hours_start" <= 23)))
);

-- ALTER TABLE "public"."profiles" OWNER TO "postgres";

COMMENT ON TABLE "public"."profiles" IS 'User profiles table - cache reload triggered';

COMMENT ON COLUMN "public"."profiles"."clerk_user_id" IS 'Clerk user ID for users authenticated via Clerk (e.g., user_2abc123...)';

COMMENT ON COLUMN "public"."profiles"."last_login_at" IS 'Last time user logged in, used for automated health refresh scheduling';

COMMENT ON COLUMN "public"."profiles"."auth_provider" IS 'Authentication provider: supabase (default), clerk, or both (during migration)';

COMMENT ON COLUMN "public"."profiles"."bio" IS 'Optional user bio used to personalize AI responses.';

COMMENT ON COLUMN "public"."profiles"."working_hours_start" IS 'Hour of day (0-23) when working hours begin. Default 8 (8 AM). Used for smart polling.';

COMMENT ON COLUMN "public"."profiles"."working_hours_end" IS 'Hour of day (0-23) when working hours end. Default 18 (6 PM). Used for smart polling.';

COMMENT ON COLUMN "public"."profiles"."timezone" IS 'User timezone (IANA format, e.g., America/New_York). NULL means auto-detect from browser.';

COMMENT ON COLUMN "public"."profiles"."week_starts_on" IS 'User preference for week start day: 0 = Sunday, 1 = Monday';

COMMENT ON CONSTRAINT "first_name_not_empty" ON "public"."profiles" IS 'Ensures first_name is either NULL or a non-empty string (no whitespace-only strings)';

COMMENT ON CONSTRAINT "last_name_not_empty" ON "public"."profiles" IS 'Ensures last_name is either NULL or a non-empty string (no whitespace-only strings)';

CREATE OR REPLACE FUNCTION "public"."get_profile_for_current_user"() RETURNS SETOF "public"."profiles"
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  v_user_id UUID;
  v_clerk_id TEXT;
BEGIN
  -- Get current user ID (handles both auth systems)
  v_user_id := current_user_id();

  IF v_user_id IS NOT NULL THEN
    RETURN QUERY SELECT * FROM profiles WHERE id = v_user_id LIMIT 1;
    RETURN;
  END IF;

  -- If no mapping found, try direct Clerk ID lookup
  v_clerk_id := get_clerk_user_id();
  IF v_clerk_id IS NOT NULL THEN
    RETURN QUERY SELECT * FROM profiles WHERE clerk_user_id = v_clerk_id LIMIT 1;
    RETURN;
  END IF;

  -- No profile found
  RETURN;
END;
$$;

-- ALTER FUNCTION "public"."get_profile_for_current_user"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_profile_for_current_user"() IS 'Returns the profile for the current user, supporting both Supabase and Clerk auth';

CREATE OR REPLACE FUNCTION "public"."get_prompt_template"("p_category" "text", "p_user_id" "uuid" DEFAULT NULL::"uuid", "p_organization_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("id" "uuid", "category" "text", "name" "text", "description" "text", "system_prompt" "text", "user_prompt" "text", "model" "text", "temperature" numeric, "max_tokens" integer, "source" "text")
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    AS $$
BEGIN
  -- First try user-specific override
  IF p_user_id IS NOT NULL THEN
    RETURN QUERY
    SELECT
      t.id, t.category, t.name, t.description,
      t.system_prompt, t.user_prompt, t.model,
      t.temperature, t.max_tokens,
      'user'::TEXT as source
    FROM ai_prompt_templates t
    WHERE t.category = p_category
      AND t.user_id = p_user_id
    LIMIT 1;

    IF FOUND THEN RETURN; END IF;
  END IF;

  -- Then try org default
  IF p_organization_id IS NOT NULL THEN
    RETURN QUERY
    SELECT
      t.id, t.category, t.name, t.description,
      t.system_prompt, t.user_prompt, t.model,
      t.temperature, t.max_tokens,
      'organization'::TEXT as source
    FROM ai_prompt_templates t
    WHERE t.category = p_category
      AND t.organization_id = p_organization_id
      AND t.is_default = TRUE
    LIMIT 1;

    IF FOUND THEN RETURN; END IF;
  END IF;

  -- Finally try system default (public, no org)
  RETURN QUERY
  SELECT
    t.id, t.category, t.name, t.description,
    t.system_prompt, t.user_prompt, t.model,
    t.temperature, t.max_tokens,
    'system'::TEXT as source
  FROM ai_prompt_templates t
  WHERE t.category = p_category
    AND t.is_public = TRUE
    AND t.organization_id IS NULL
    AND t.user_id IS NULL
  ORDER BY t.created_at DESC
  LIMIT 1;
END;
$$;

-- ALTER FUNCTION "public"."get_prompt_template"("p_category" "text", "p_user_id" "uuid", "p_organization_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_public_subscription_plans"() RETURNS TABLE("id" "uuid", "name" "text", "slug" "text", "description" "text", "price_monthly" integer, "price_yearly" integer, "currency" "text", "max_users" integer, "max_meetings_per_month" integer, "max_ai_tokens_per_month" integer, "max_storage_mb" integer, "meeting_retention_months" integer, "included_seats" integer, "per_seat_price" integer, "trial_days" integer, "features" "jsonb", "is_free_tier" boolean, "display_order" integer, "badge_text" "text", "cta_text" "text", "cta_url" "text", "highlight_features" "text"[])
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
  BEGIN
    RETURN QUERY
    SELECT
      sp.id,
      sp.name,
      sp.slug,
      sp.description,
      sp.price_monthly,
      sp.price_yearly,
      sp.currency,
      sp.max_users,
      sp.max_meetings_per_month,
      sp.max_ai_tokens_per_month,
      sp.max_storage_mb,
      sp.meeting_retention_months,
      sp.included_seats,
      sp.per_seat_price,
      sp.trial_days,
      sp.features,
      sp.is_free_tier,
      sp.display_order,
      sp.badge_text,
      sp.cta_text,
      sp.cta_url,
      sp.highlight_features
    FROM subscription_plans sp
    WHERE sp.is_active = true
    AND sp.is_public = true
    ORDER BY sp.display_order ASC, sp.price_monthly ASC;
  END;
  $$;

-- ALTER FUNCTION "public"."get_public_subscription_plans"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_public_subscription_plans"() IS 'Returns all active public plans for pricing
 --  page display';

CREATE OR REPLACE FUNCTION "public"."get_reengagement_candidates"("p_org_id" "uuid" DEFAULT NULL::"uuid", "p_segment" "text" DEFAULT NULL::"text", "p_limit" integer DEFAULT 50) RETURNS TABLE("user_id" "uuid", "org_id" "uuid", "slack_user_id" "text", "email" "text", "full_name" "text", "segment" "text", "days_inactive" integer, "overall_engagement_score" integer, "reengagement_attempts" integer, "last_reengagement_at" timestamp with time zone, "last_reengagement_type" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    uem.user_id,
    uem.org_id,
    sum.slack_user_id,
    p.email,
    COALESCE(p.first_name || ' ' || p.last_name, p.email) AS full_name,
    uem.user_segment AS segment,
    EXTRACT(DAY FROM NOW() - GREATEST(
      uem.last_app_active_at,
      uem.last_slack_active_at,
      uem.last_login_at
    ))::INTEGER AS days_inactive,
    uem.overall_engagement_score,
    COALESCE(uem.reengagement_attempts, 0) AS reengagement_attempts,
    uem.last_reengagement_at,
    uem.last_reengagement_type
  FROM user_engagement_metrics uem
  JOIN profiles p ON p.id = uem.user_id
  LEFT JOIN slack_user_mappings sum ON sum.sixty_user_id = uem.user_id AND sum.org_id = uem.org_id
  WHERE
    (p_org_id IS NULL OR uem.org_id = p_org_id)
    AND (
      (p_segment IS NOT NULL AND uem.user_segment = p_segment)
      OR (p_segment IS NULL AND uem.user_segment IN ('at_risk', 'dormant', 'churned'))
    )
    AND (p.email IS NOT NULL OR sum.slack_user_id IS NOT NULL)
    AND (uem.reengagement_cooldown_until IS NULL OR uem.reengagement_cooldown_until < NOW())
    AND (
      (uem.user_segment = 'at_risk' AND COALESCE(uem.reengagement_attempts, 0) < 3)
      OR (uem.user_segment = 'dormant' AND COALESCE(uem.reengagement_attempts, 0) < 4)
      OR (uem.user_segment = 'churned' AND COALESCE(uem.reengagement_attempts, 0) < 2)
    )
    AND (
      (uem.user_segment = 'at_risk' AND EXTRACT(DAY FROM NOW() - GREATEST(
        uem.last_app_active_at, uem.last_slack_active_at, uem.last_login_at
      )) >= 5)
      OR (uem.user_segment = 'dormant' AND EXTRACT(DAY FROM NOW() - GREATEST(
        uem.last_app_active_at, uem.last_slack_active_at, uem.last_login_at
      )) >= 3)
      OR (uem.user_segment = 'churned' AND EXTRACT(DAY FROM NOW() - GREATEST(
        uem.last_app_active_at, uem.last_slack_active_at, uem.last_login_at
      )) >= 14)
    )
  ORDER BY
    CASE uem.user_segment
      WHEN 'at_risk' THEN 1
      WHEN 'dormant' THEN 2
      WHEN 'churned' THEN 3
      ELSE 4
    END,
    uem.overall_engagement_score DESC,
    COALESCE(uem.reengagement_attempts, 0) ASC
  LIMIT p_limit;
END;
$$;

-- ALTER FUNCTION "public"."get_reengagement_candidates"("p_org_id" "uuid", "p_segment" "text", "p_limit" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_reengagement_candidates"("p_org_id" "uuid", "p_segment" "text", "p_limit" integer) IS 'Get users eligible for re-engagement - uses sixty_user_id from slack_user_mappings';

CREATE OR REPLACE FUNCTION "public"."get_reengagement_stats"("p_org_id" "uuid" DEFAULT NULL::"uuid", "p_days" integer DEFAULT 30) RETURNS TABLE("segment" "text", "total_candidates" integer, "sent_count" integer, "opened_count" integer, "returned_count" integer, "success_rate" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  WITH candidates AS (
    SELECT
      uem.user_segment AS segment,
      COUNT(DISTINCT uem.user_id) AS total
    FROM user_engagement_metrics uem
    WHERE (p_org_id IS NULL OR uem.org_id = p_org_id)
      AND uem.user_segment IN ('at_risk', 'dormant', 'churned')
    GROUP BY uem.user_segment
  ),
  sent AS (
    SELECT
      rl.segment_at_send AS segment,
      COUNT(*) AS sent_count,
      COUNT(*) FILTER (WHERE rl.opened_at IS NOT NULL) AS opened_count,
      COUNT(*) FILTER (WHERE rl.returned_to_app = TRUE) AS returned_count
    FROM reengagement_log rl
    WHERE (p_org_id IS NULL OR rl.org_id = p_org_id)
      AND rl.sent_at > NOW() - (p_days || ' days')::INTERVAL
    GROUP BY rl.segment_at_send
  )
  SELECT
    c.segment,
    c.total::INTEGER AS total_candidates,
    COALESCE(s.sent_count, 0)::INTEGER AS sent_count,
    COALESCE(s.opened_count, 0)::INTEGER AS opened_count,
    COALESCE(s.returned_count, 0)::INTEGER AS returned_count,
    CASE
      WHEN COALESCE(s.sent_count, 0) > 0
      THEN ROUND((COALESCE(s.returned_count, 0)::NUMERIC / s.sent_count) * 100, 1)
      ELSE 0
    END AS success_rate
  FROM candidates c
  LEFT JOIN sent s ON s.segment = c.segment
  ORDER BY
    CASE c.segment
      WHEN 'at_risk' THEN 1
      WHEN 'dormant' THEN 2
      WHEN 'churned' THEN 3
    END;
END;
$$;

-- ALTER FUNCTION "public"."get_reengagement_stats"("p_org_id" "uuid", "p_days" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_reengagement_stats"("p_org_id" "uuid", "p_days" integer) IS 'Get re-engagement statistics for dashboard';

CREATE OR REPLACE FUNCTION "public"."get_rep_scorecard_stats"("p_org_id" "uuid", "p_user_id" "uuid" DEFAULT NULL::"uuid", "p_date_from" timestamp with time zone DEFAULT NULL::timestamp with time zone, "p_date_to" timestamp with time zone DEFAULT NULL::timestamp with time zone) RETURNS TABLE("rep_user_id" "uuid", "meeting_count" bigint, "avg_overall_score" numeric, "avg_talk_ratio" numeric, "avg_discovery_questions" numeric, "next_steps_rate" numeric, "grade_distribution" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    ms.rep_user_id,
    COUNT(ms.id) as meeting_count,
    ROUND(AVG(ms.overall_score)::numeric, 1) as avg_overall_score,
    ROUND(AVG(ms.talk_time_rep_pct)::numeric, 1) as avg_talk_ratio,
    ROUND(AVG(ms.discovery_questions_count)::numeric, 1) as avg_discovery_questions,
    ROUND((COUNT(*) FILTER (WHERE ms.next_steps_established = true)::numeric / NULLIF(COUNT(*)::numeric, 0)) * 100, 1) as next_steps_rate,
    jsonb_build_object(
      'A', COUNT(*) FILTER (WHERE ms.grade = 'A'),
      'B', COUNT(*) FILTER (WHERE ms.grade = 'B'),
      'C', COUNT(*) FILTER (WHERE ms.grade = 'C'),
      'D', COUNT(*) FILTER (WHERE ms.grade = 'D'),
      'F', COUNT(*) FILTER (WHERE ms.grade = 'F')
    ) as grade_distribution
  FROM meeting_scorecards ms
  INNER JOIN meetings m ON ms.meeting_id = m.id
  WHERE ms.org_id = p_org_id
    AND (p_user_id IS NULL OR ms.rep_user_id = p_user_id)
    AND (p_date_from IS NULL OR m.start_time >= p_date_from)
    AND (p_date_to IS NULL OR m.start_time <= p_date_to)
  GROUP BY ms.rep_user_id;
END;
$$;

-- ALTER FUNCTION "public"."get_rep_scorecard_stats"("p_org_id" "uuid", "p_user_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_rep_scorecard_stats"("p_org_id" "uuid", "p_user_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) IS 'Returns performance statistics for reps based on their scorecards';

CREATE OR REPLACE FUNCTION "public"."get_response_rate"("contact_id_param" "uuid", "days" integer DEFAULT 30) RETURNS integer
    LANGUAGE "sql" STABLE
    SET "search_path" TO ''
    AS $$
  SELECT
    CASE
      WHEN COUNT(*) FILTER (WHERE direction = 'outbound') > 0 THEN
        ROUND((COUNT(*) FILTER (WHERE direction = 'outbound' AND was_replied = TRUE)::NUMERIC /
               COUNT(*) FILTER (WHERE direction = 'outbound')::NUMERIC) * 100)::INTEGER
      ELSE 0
    END
  FROM communication_events
  WHERE contact_id = contact_id_param
    AND event_timestamp >= NOW() - (days || ' days')::INTERVAL;
$$;

-- ALTER FUNCTION "public"."get_response_rate"("contact_id_param" "uuid", "days" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_scorecard_template_for_type"("p_org_id" "uuid", "p_meeting_type" "text") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_template JSONB;
BEGIN
  SELECT row_to_json(cst.*)::JSONB
  INTO v_template
  FROM coaching_scorecard_templates cst
  WHERE cst.org_id = p_org_id
    AND cst.meeting_type = p_meeting_type
    AND cst.is_active = true
  ORDER BY cst.is_default DESC, cst.created_at DESC
  LIMIT 1;

  RETURN COALESCE(v_template, '{}'::JSONB);
END;
$$;

-- ALTER FUNCTION "public"."get_scorecard_template_for_type"("p_org_id" "uuid", "p_meeting_type" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_scorecard_template_for_type"("p_org_id" "uuid", "p_meeting_type" "text") IS 'Returns the active template for a specific meeting type in an org';

CREATE OR REPLACE FUNCTION "public"."get_sentiment_trend"("contact_id_param" "uuid") RETURNS "text"
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO ''
    AS $$
DECLARE
  recent_sentiments NUMERIC[];
  trend TEXT;
BEGIN
  -- Get last 5 sentiment scores
  SELECT ARRAY_AGG(sentiment_score ORDER BY event_timestamp DESC)
  INTO recent_sentiments
  FROM (
    SELECT sentiment_score, event_timestamp
    FROM communication_events
    WHERE contact_id = contact_id_param
      AND sentiment_score IS NOT NULL
    ORDER BY event_timestamp DESC
    LIMIT 5
  ) sub;

  IF recent_sentiments IS NULL OR ARRAY_LENGTH(recent_sentiments, 1) < 3 THEN
    RETURN 'unknown';
  END IF;

  -- Compare most recent vs average of older scores
  IF recent_sentiments[1] > (recent_sentiments[2] + recent_sentiments[3]) / 2 + 0.1 THEN
    trend := 'improving';
  ELSIF recent_sentiments[1] < (recent_sentiments[2] + recent_sentiments[3]) / 2 - 0.1 THEN
    trend := 'declining';
  ELSE
    trend := 'stable';
  END IF;

  RETURN trend;
END;
$$;

-- ALTER FUNCTION "public"."get_sentiment_trend"("contact_id_param" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_sequence_executions"("p_sequence_key" "text" DEFAULT NULL::"text", "p_organization_id" "uuid" DEFAULT NULL::"uuid", "p_is_simulation" boolean DEFAULT NULL::boolean, "p_status" "text" DEFAULT NULL::"text", "p_limit" integer DEFAULT 50) RETURNS TABLE("id" "uuid", "sequence_key" "text", "organization_id" "uuid", "user_id" "uuid", "status" "text", "input_context" "jsonb", "step_results" "jsonb", "final_output" "jsonb", "error_message" "text", "failed_step_index" integer, "is_simulation" boolean, "started_at" timestamp with time zone, "completed_at" timestamp with time zone, "duration_ms" bigint)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    se.id,
    se.sequence_key,
    se.organization_id,
    se.user_id,
    se.status,
    se.input_context,
    se.step_results,
    se.final_output,
    se.error_message,
    se.failed_step_index,
    se.is_simulation,
    se.started_at,
    se.completed_at,
    CASE
      WHEN se.completed_at IS NOT NULL
      THEN EXTRACT(EPOCH FROM (se.completed_at - se.started_at)) * 1000
      ELSE NULL
    END::BIGINT AS duration_ms
  FROM sequence_executions se
  WHERE
    (p_sequence_key IS NULL OR se.sequence_key = p_sequence_key)
    AND (p_organization_id IS NULL OR se.organization_id = p_organization_id)
    AND (p_is_simulation IS NULL OR se.is_simulation = p_is_simulation)
    AND (p_status IS NULL OR se.status = p_status)
  ORDER BY se.created_at DESC
  LIMIT p_limit;
END;
$$;

-- ALTER FUNCTION "public"."get_sequence_executions"("p_sequence_key" "text", "p_organization_id" "uuid", "p_is_simulation" boolean, "p_status" "text", "p_limit" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_share_stats"("entry_id" "uuid") RETURNS TABLE("total_shares" bigint, "twitter_shares" bigint, "linkedin_shares" bigint, "email_shares" bigint, "copy_shares" bigint, "clicks" bigint, "conversions" bigint, "conversion_rate" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    COUNT(*)::BIGINT as total_shares,
    COUNT(*) FILTER (WHERE platform = 'twitter')::BIGINT as twitter_shares,
    COUNT(*) FILTER (WHERE platform = 'linkedin')::BIGINT as linkedin_shares,
    COUNT(*) FILTER (WHERE platform = 'email')::BIGINT as email_shares,
    COUNT(*) FILTER (WHERE platform = 'copy')::BIGINT as copy_shares,
    COUNT(*) FILTER (WHERE referral_clicked = TRUE)::BIGINT as clicks,
    COUNT(*) FILTER (WHERE referral_converted = TRUE)::BIGINT as conversions,
    CASE
      WHEN COUNT(*) FILTER (WHERE referral_clicked = TRUE) > 0
      THEN (COUNT(*) FILTER (WHERE referral_converted = TRUE)::NUMERIC /
            COUNT(*) FILTER (WHERE referral_clicked = TRUE)::NUMERIC * 100)
      ELSE 0
    END as conversion_rate
  FROM waitlist_shares
  WHERE waitlist_entry_id = entry_id;
END;
$$;

-- ALTER FUNCTION "public"."get_share_stats"("entry_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_skills_needing_compilation"() RETURNS TABLE("org_skill_id" "uuid", "organization_id" "uuid", "skill_key" "text", "platform_skill_id" "uuid", "platform_frontmatter" "jsonb", "platform_content" "text", "platform_version" integer, "user_overrides" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    os.id as org_skill_id,
    os.organization_id,
    os.skill_id as skill_key,
    ps.id as platform_skill_id,
    ps.frontmatter as platform_frontmatter,
    ps.content_template as platform_content,
    ps.version as platform_version,
    os.user_overrides
  FROM organization_skills os
  JOIN platform_skills ps ON ps.skill_key = os.skill_id
  WHERE os.is_active = true
    AND ps.is_active = true
    AND (
      os.last_compiled_at IS NULL
      OR os.platform_skill_version IS NULL
      OR os.platform_skill_version < ps.version
    )
  ORDER BY os.organization_id, ps.category, os.skill_id;
END;
$$;

-- ALTER FUNCTION "public"."get_skills_needing_compilation"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_skills_needing_compilation"() IS 'Returns organization skills that need compilation or recompilation';

CREATE OR REPLACE FUNCTION "public"."get_skills_needing_recompile"("p_org_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("organization_id" "uuid", "skill_key" "text", "platform_skill_id" "uuid", "platform_version" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    os.organization_id,
    os.skill_id as skill_key,
    ps.id as platform_skill_id,
    ps.version as platform_version
  FROM organization_skills os
  JOIN platform_skills ps ON ps.skill_key = os.skill_id
  WHERE os.is_active = true
    AND ps.is_active = true
    AND (p_org_id IS NULL OR os.organization_id = p_org_id)
    AND (
      os.last_compiled_at IS NULL
      OR os.platform_skill_version IS NULL
      OR os.platform_skill_version < ps.version
    )
  ORDER BY os.organization_id, os.skill_id;
END;
$$;

-- ALTER FUNCTION "public"."get_skills_needing_recompile"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_skills_needing_recompile"("p_org_id" "uuid") IS 'Returns organization skills that need compilation or recompilation';

-- ALTER FUNCTION "public"."get_slack_org_settings_public"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_slack_org_settings_public"("p_org_id" "uuid") IS 'Returns safe Slack org connection info (no bot_access_token) for org members.';

CREATE OR REPLACE FUNCTION "public"."get_status_change_count"("relationship_health_id_param" "uuid", "days" integer DEFAULT 30) RETURNS integer
    LANGUAGE "sql" STABLE
    SET "search_path" TO ''
    AS $$
  SELECT COUNT(*)::INTEGER
  FROM relationship_health_history
  WHERE relationship_health_id = relationship_health_id_param
    AND snapshot_at >= NOW() - (days || ' days')::INTERVAL
    AND changes_from_previous->>'status_changed' = 'true';
$$;

-- ALTER FUNCTION "public"."get_status_change_count"("relationship_health_id_param" "uuid", "days" integer) OWNER TO "postgres";

-- ALTER FUNCTION "public"."get_stuck_waitlist_onboarding_users"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_stuck_waitlist_onboarding_users"() IS 'Get list of users who are stuck in waitlist onboarding (< 50% completion after 7 days)';

CREATE OR REPLACE FUNCTION "public"."get_subscription_retention_cohorts"("p_cohort_start" "date", "p_cohort_end" "date", "p_retention_months" integer[] DEFAULT ARRAY[1, 3, 6, 12]) RETURNS TABLE("cohort_month" "date", "cohort_size" integer, "retention_month" integer, "retained_count" integer, "retention_rate" numeric, "mrr_retained_cents" bigint)
    LANGUAGE "plpgsql" STABLE
    AS $$
BEGIN
  RETURN QUERY
  WITH cohorts AS (
    SELECT
      DATE_TRUNC('month', started_at)::DATE as cohort_month,
      COUNT(*) as cohort_size,
      SUM(normalized_mrr_cents) as cohort_mrr
    FROM subscription_facts_view
    WHERE DATE_TRUNC('month', started_at)::DATE BETWEEN p_cohort_start AND p_cohort_end
    GROUP BY DATE_TRUNC('month', started_at)::DATE
  ),
  retention_data AS (
    SELECT
      c.cohort_month,
      c.cohort_size,
      rm.retention_month,
      COUNT(*) FILTER (
        WHERE sfv.is_active 
        OR (sfv.canceled_at IS NOT NULL AND sfv.canceled_at > c.cohort_month + (rm.retention_month || ' months')::INTERVAL)
      ) as retained_count,
      SUM(sfv.normalized_mrr_cents) FILTER (
        WHERE sfv.is_active 
        OR (sfv.canceled_at IS NOT NULL AND sfv.canceled_at > c.cohort_month + (rm.retention_month || ' months')::INTERVAL)
      ) as mrr_retained
    FROM cohorts c
    CROSS JOIN UNNEST(p_retention_months) as rm(retention_month)
    LEFT JOIN subscription_facts_view sfv ON 
      DATE_TRUNC('month', sfv.started_at)::DATE = c.cohort_month
      AND (
        sfv.is_active 
        OR (sfv.canceled_at IS NOT NULL AND sfv.canceled_at > c.cohort_month + (rm.retention_month || ' months')::INTERVAL)
      )
    GROUP BY c.cohort_month, c.cohort_size, rm.retention_month
  )
  SELECT
    rd.cohort_month,
    rd.cohort_size,
    rd.retention_month,
    rd.retained_count,
    CASE
      WHEN rd.cohort_size > 0 THEN (rd.retained_count::NUMERIC / rd.cohort_size::NUMERIC * 100)
      ELSE 0
    END as retention_rate,
    COALESCE(rd.mrr_retained, 0) as mrr_retained_cents
  FROM retention_data rd
  ORDER BY rd.cohort_month, rd.retention_month;
END;
$$;

-- ALTER FUNCTION "public"."get_subscription_retention_cohorts"("p_cohort_start" "date", "p_cohort_end" "date", "p_retention_months" integer[]) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_subscription_retention_cohorts"("p_cohort_start" "date", "p_cohort_end" "date", "p_retention_months" integer[]) IS 'Get subscription retention by cohort (monthly cohorts)';

CREATE OR REPLACE FUNCTION "public"."get_supabase_id_for_clerk_user"("p_clerk_user_id" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  v_supabase_id UUID;
BEGIN
  SELECT supabase_user_id INTO v_supabase_id
  FROM clerk_user_mappings
  WHERE clerk_user_id = p_clerk_user_id;

  RETURN v_supabase_id;
END;
$$;

-- ALTER FUNCTION "public"."get_supabase_id_for_clerk_user"("p_clerk_user_id" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_supabase_id_for_clerk_user"("p_clerk_user_id" "text") IS 'Returns the Supabase profile UUID for a given Clerk user ID';

CREATE OR REPLACE FUNCTION "public"."get_system_config"("p_key" "text") RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN (SELECT value FROM system_config WHERE key = p_key);
END;
$$;

-- ALTER FUNCTION "public"."get_system_config"("p_key" "text") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_task_depth"("task_id" "uuid") RETURNS integer
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
DECLARE
    depth INTEGER := 0;
    current_parent_id UUID;
BEGIN
    SELECT parent_task_id INTO current_parent_id 
    FROM tasks 
    WHERE id = task_id;
    
    WHILE current_parent_id IS NOT NULL LOOP
        depth := depth + 1;
        
        SELECT parent_task_id INTO current_parent_id 
        FROM tasks 
        WHERE id = current_parent_id;
        
        -- Safety check to prevent infinite loops (max depth of 10)
        IF depth > 10 THEN
            EXIT;
        END IF;
    END LOOP;
    
    RETURN depth;
END;
$$;

-- ALTER FUNCTION "public"."get_task_depth"("task_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_task_target_lists"("p_user_id" "uuid", "p_priority" "text", "p_category" "text" DEFAULT NULL::"text") RETURNS TABLE("config_id" "uuid", "google_list_id" "text", "list_title" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    c.id as config_id,
    c.google_list_id,
    c.list_title
  FROM google_tasks_list_configs c
  WHERE 
    c.user_id = p_user_id
    AND c.sync_enabled = true
    AND (
      c.priority_filter = '{}' 
      OR p_priority = ANY(c.priority_filter)
    )
    AND (
      c.task_categories = '{}' 
      OR p_category IS NULL
      OR p_category = ANY(c.task_categories)
    )
  ORDER BY 
    CASE WHEN c.priority_filter != '{}' THEN 0 ELSE 1 END,
    c.is_primary DESC,
    c.display_order;
END;
$$;

-- ALTER FUNCTION "public"."get_task_target_lists"("p_user_id" "uuid", "p_priority" "text", "p_category" "text") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_team_aggregates_with_comparison"("p_org_id" "uuid", "p_period_days" integer DEFAULT 30) RETURNS TABLE("current_total_meetings" bigint, "current_avg_sentiment" numeric, "current_avg_talk_time" numeric, "current_avg_coach_rating" numeric, "current_positive_count" bigint, "current_negative_count" bigint, "current_total_duration" numeric, "current_team_members" bigint, "current_forward_movement_count" bigint, "current_objection_count" bigint, "current_positive_outcome_count" bigint, "previous_total_meetings" bigint, "previous_avg_sentiment" numeric, "previous_avg_talk_time" numeric, "previous_avg_coach_rating" numeric, "previous_positive_count" bigint, "previous_forward_movement_count" bigint, "previous_positive_outcome_count" bigint, "meetings_change_pct" numeric, "sentiment_change_pct" numeric, "talk_time_change_pct" numeric, "coach_rating_change_pct" numeric, "forward_movement_change_pct" numeric, "positive_outcome_change_pct" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  WITH current_period AS (
    SELECT
      COUNT(m.id) as total_meetings,
      AVG(m.sentiment_score) as avg_sentiment,
      AVG(m.talk_time_rep_pct) as avg_talk_time,
      AVG(m.coach_rating) as avg_coach_rating,
      COUNT(CASE WHEN m.sentiment_score > 0.2 THEN 1 END) as positive_count,
      COUNT(CASE WHEN m.sentiment_score < -0.2 THEN 1 END) as negative_count,
      SUM(m.duration_minutes) as total_duration,
      COUNT(DISTINCT m.owner_user_id) as team_members,
      COUNT(CASE WHEN mc.has_forward_movement = true THEN 1 END) as forward_movement_count,
      COUNT(CASE WHEN mc.has_objection = true THEN 1 END) as objection_count,
      COUNT(CASE WHEN mc.outcome = 'positive' THEN 1 END) as positive_outcome_count
    FROM meetings m
    LEFT JOIN meeting_classifications mc ON mc.meeting_id = m.id
    WHERE m.org_id = p_org_id
      AND m.meeting_start >= NOW() - (p_period_days || ' days')::INTERVAL
      AND m.meeting_start IS NOT NULL
  ),
  previous_period AS (
    SELECT
      COUNT(m.id) as total_meetings,
      AVG(m.sentiment_score) as avg_sentiment,
      AVG(m.talk_time_rep_pct) as avg_talk_time,
      AVG(m.coach_rating) as avg_coach_rating,
      COUNT(CASE WHEN m.sentiment_score > 0.2 THEN 1 END) as positive_count,
      COUNT(CASE WHEN mc.has_forward_movement = true THEN 1 END) as forward_movement_count,
      COUNT(CASE WHEN mc.outcome = 'positive' THEN 1 END) as positive_outcome_count
    FROM meetings m
    LEFT JOIN meeting_classifications mc ON mc.meeting_id = m.id
    WHERE m.org_id = p_org_id
      AND m.meeting_start >= NOW() - (p_period_days * 2 || ' days')::INTERVAL
      AND m.meeting_start < NOW() - (p_period_days || ' days')::INTERVAL
      AND m.meeting_start IS NOT NULL
  )
  SELECT
    -- Current period
    cp.total_meetings,
    ROUND(cp.avg_sentiment, 3),
    ROUND(cp.avg_talk_time, 1),
    ROUND(cp.avg_coach_rating, 1),
    cp.positive_count,
    cp.negative_count,
    ROUND(cp.total_duration, 0),
    cp.team_members,
    cp.forward_movement_count,
    cp.objection_count,
    cp.positive_outcome_count,
    -- Previous period
    pp.total_meetings,
    ROUND(pp.avg_sentiment, 3),
    ROUND(pp.avg_talk_time, 1),
    ROUND(pp.avg_coach_rating, 1),
    pp.positive_count,
    pp.forward_movement_count,
    pp.positive_outcome_count,
    -- Changes
    CASE WHEN pp.total_meetings > 0 THEN
      ROUND(((cp.total_meetings - pp.total_meetings)::NUMERIC / pp.total_meetings) * 100, 1)
    ELSE NULL END,
    CASE WHEN pp.avg_sentiment IS NOT NULL AND ABS(pp.avg_sentiment) > 0.001 THEN
      ROUND(((cp.avg_sentiment - pp.avg_sentiment) / ABS(pp.avg_sentiment)) * 100, 1)
    ELSE NULL END,
    CASE WHEN pp.avg_talk_time IS NOT NULL AND pp.avg_talk_time > 0 THEN
      ROUND(((cp.avg_talk_time - pp.avg_talk_time) / pp.avg_talk_time) * 100, 1)
    ELSE NULL END,
    CASE WHEN pp.avg_coach_rating IS NOT NULL AND pp.avg_coach_rating > 0 THEN
      ROUND(((cp.avg_coach_rating - pp.avg_coach_rating) / pp.avg_coach_rating) * 100, 1)
    ELSE NULL END,
    CASE WHEN pp.forward_movement_count > 0 THEN
      ROUND(((cp.forward_movement_count - pp.forward_movement_count)::NUMERIC / pp.forward_movement_count) * 100, 1)
    ELSE NULL END,
    CASE WHEN pp.positive_outcome_count > 0 THEN
      ROUND(((cp.positive_outcome_count - pp.positive_outcome_count)::NUMERIC / pp.positive_outcome_count) * 100, 1)
    ELSE NULL END
  FROM current_period cp, previous_period pp;
END;
$$;

-- ALTER FUNCTION "public"."get_team_aggregates_with_comparison"("p_org_id" "uuid", "p_period_days" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_team_aggregates_with_comparison"("p_org_id" "uuid", "p_period_days" integer) IS 'Returns team aggregates with period-over-period comparison for KPI cards';

CREATE OR REPLACE FUNCTION "public"."get_team_comparison_matrix"("p_org_id" "uuid", "p_period_days" integer DEFAULT 30) RETURNS TABLE("user_id" "uuid", "user_name" "text", "user_email" "text", "avatar_url" "text", "total_meetings" bigint, "avg_sentiment" numeric, "avg_talk_time" numeric, "avg_coach_rating" numeric, "forward_movement_rate" numeric, "positive_outcome_rate" numeric, "trend_data" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  WITH rep_metrics AS (
    SELECT
      m.owner_user_id,
      COUNT(m.id) as total_meetings,
      AVG(m.sentiment_score) as avg_sentiment,
      AVG(m.talk_time_rep_pct) as avg_talk_time,
      AVG(m.coach_rating) as avg_coach_rating,
      CASE WHEN COUNT(mc.id) > 0 THEN
        ROUND((COUNT(CASE WHEN mc.has_forward_movement = true THEN 1 END)::NUMERIC / COUNT(mc.id)) * 100, 1)
      ELSE NULL END as forward_movement_rate,
      CASE WHEN COUNT(mc.id) > 0 THEN
        ROUND((COUNT(CASE WHEN mc.outcome = 'positive' THEN 1 END)::NUMERIC / COUNT(mc.id)) * 100, 1)
      ELSE NULL END as positive_outcome_rate
    FROM meetings m
    LEFT JOIN meeting_classifications mc ON mc.meeting_id = m.id
    WHERE m.org_id = p_org_id
      AND m.meeting_start >= NOW() - (p_period_days || ' days')::INTERVAL
      AND m.meeting_start IS NOT NULL
    GROUP BY m.owner_user_id
  ),
  -- First: aggregate meetings by user and date
  daily_trends AS (
    SELECT
      m.owner_user_id,
      DATE_TRUNC('day', m.meeting_start)::DATE as meeting_date,
      COUNT(*) as daily_count,
      ROUND(AVG(m.sentiment_score), 2) as daily_sentiment
    FROM meetings m
    WHERE m.org_id = p_org_id
      AND m.meeting_start >= NOW() - INTERVAL '7 days'
      AND m.meeting_start IS NOT NULL
    GROUP BY m.owner_user_id, DATE_TRUNC('day', m.meeting_start)::DATE
  ),
  -- Second: build JSONB array from daily data
  aggregated_trends AS (
    SELECT
      owner_user_id,
      jsonb_agg(
        jsonb_build_object(
          'date', meeting_date::TEXT,
          'count', daily_count,
          'sentiment', daily_sentiment
        ) ORDER BY meeting_date
      ) as trend_data
    FROM daily_trends
    GROUP BY owner_user_id
  )
  SELECT
    rm.owner_user_id as user_id,
    COALESCE(
      NULLIF(TRIM(CONCAT(COALESCE(p.first_name, ''), ' ', COALESCE(p.last_name, ''))), ''),
      p.email
    ) as user_name,
    p.email as user_email,
    p.avatar_url,
    rm.total_meetings,
    ROUND(rm.avg_sentiment, 3),
    ROUND(rm.avg_talk_time, 1),
    ROUND(rm.avg_coach_rating, 1),
    rm.forward_movement_rate,
    rm.positive_outcome_rate,
    COALESCE(at.trend_data, '[]'::jsonb) as trend_data
  FROM rep_metrics rm
  LEFT JOIN profiles p ON rm.owner_user_id = p.id
  LEFT JOIN aggregated_trends at ON at.owner_user_id = rm.owner_user_id
  ORDER BY rm.total_meetings DESC;
END;
$$;

-- ALTER FUNCTION "public"."get_team_comparison_matrix"("p_org_id" "uuid", "p_period_days" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_team_comparison_matrix"("p_org_id" "uuid", "p_period_days" integer) IS 'Returns all reps with metrics for comparison table (fixed trend_data aggregation)';

-- ALTER FUNCTION "public"."get_team_members_with_connected_accounts"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_team_members_with_connected_accounts"() IS 'Returns team members with active Fathom integrations who have meetings with transcripts';

-- ALTER FUNCTION "public"."get_team_members_with_meetings"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_team_members_with_meetings"() IS 'Returns team members who have meetings with transcripts (deprecated)';

CREATE OR REPLACE FUNCTION "public"."get_team_quality_signals"("p_org_id" "uuid", "p_period_days" integer DEFAULT 30, "p_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("user_id" "uuid", "user_name" "text", "user_email" "text", "total_meetings" bigint, "classified_meetings" bigint, "forward_movement_count" bigint, "forward_movement_rate" numeric, "objection_count" bigint, "objection_rate" numeric, "competitor_mention_count" bigint, "pricing_discussion_count" bigint, "positive_outcome_count" bigint, "negative_outcome_count" bigint, "neutral_outcome_count" bigint, "positive_outcome_rate" numeric, "avg_sentiment" numeric, "avg_talk_time" numeric, "avg_coach_rating" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    m.owner_user_id as user_id,
    COALESCE(
      NULLIF(TRIM(CONCAT(COALESCE(p.first_name, ''), ' ', COALESCE(p.last_name, ''))), ''),
      p.email
    ) as user_name,
    p.email as user_email,
    COUNT(m.id) as total_meetings,
    COUNT(mc.id) as classified_meetings,
    COUNT(CASE WHEN mc.has_forward_movement = true THEN 1 END) as forward_movement_count,
    CASE WHEN COUNT(mc.id) > 0 THEN
      ROUND((COUNT(CASE WHEN mc.has_forward_movement = true THEN 1 END)::NUMERIC / COUNT(mc.id)) * 100, 1)
    ELSE NULL END as forward_movement_rate,
    COUNT(CASE WHEN mc.has_objection = true THEN 1 END) as objection_count,
    CASE WHEN COUNT(mc.id) > 0 THEN
      ROUND((COUNT(CASE WHEN mc.has_objection = true THEN 1 END)::NUMERIC / COUNT(mc.id)) * 100, 1)
    ELSE NULL END as objection_rate,
    COUNT(CASE WHEN mc.has_competitor_mention = true THEN 1 END) as competitor_mention_count,
    COUNT(CASE WHEN mc.has_pricing_discussion = true THEN 1 END) as pricing_discussion_count,
    COUNT(CASE WHEN mc.outcome = 'positive' THEN 1 END) as positive_outcome_count,
    COUNT(CASE WHEN mc.outcome = 'negative' THEN 1 END) as negative_outcome_count,
    COUNT(CASE WHEN mc.outcome = 'neutral' THEN 1 END) as neutral_outcome_count,
    CASE WHEN COUNT(mc.id) > 0 THEN
      ROUND((COUNT(CASE WHEN mc.outcome = 'positive' THEN 1 END)::NUMERIC / COUNT(mc.id)) * 100, 1)
    ELSE NULL END as positive_outcome_rate,
    ROUND(AVG(m.sentiment_score), 3) as avg_sentiment,
    ROUND(AVG(m.talk_time_rep_pct), 1) as avg_talk_time,
    ROUND(AVG(m.coach_rating), 1) as avg_coach_rating
  FROM meetings m
  LEFT JOIN profiles p ON m.owner_user_id = p.id
  LEFT JOIN meeting_classifications mc ON mc.meeting_id = m.id
  WHERE m.org_id = p_org_id
    AND m.meeting_start >= NOW() - (p_period_days || ' days')::INTERVAL
    AND m.meeting_start IS NOT NULL
    AND (p_user_id IS NULL OR m.owner_user_id = p_user_id)
  GROUP BY m.owner_user_id, p.first_name, p.last_name, p.email
  ORDER BY COUNT(m.id) DESC;
END;
$$;

-- ALTER FUNCTION "public"."get_team_quality_signals"("p_org_id" "uuid", "p_period_days" integer, "p_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_team_quality_signals"("p_org_id" "uuid", "p_period_days" integer, "p_user_id" "uuid") IS 'Returns meeting quality signals per rep from classifications';

-- ALTER FUNCTION "public"."get_team_scorecard_leaderboard"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_limit" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_team_scorecard_leaderboard"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_limit" integer) IS 'Returns ranked leaderboard of rep performance';

CREATE OR REPLACE FUNCTION "public"."get_team_time_series_metrics"("p_org_id" "uuid", "p_period_days" integer DEFAULT 30, "p_granularity" "text" DEFAULT 'day'::"text", "p_user_id" "uuid" DEFAULT NULL::"uuid") RETURNS TABLE("period_start" timestamp with time zone, "user_id" "uuid", "user_name" "text", "meeting_count" bigint, "avg_sentiment" numeric, "avg_talk_time" numeric, "avg_coach_rating" numeric, "positive_count" bigint, "negative_count" bigint, "forward_movement_count" bigint, "total_duration" numeric)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    CASE p_granularity
      WHEN 'week' THEN DATE_TRUNC('week', m.meeting_start)
      ELSE DATE_TRUNC('day', m.meeting_start)
    END as period_start,
    m.owner_user_id as user_id,
    COALESCE(
      NULLIF(TRIM(CONCAT(COALESCE(p.first_name, ''), ' ', COALESCE(p.last_name, ''))), ''),
      p.email
    ) as user_name,
    COUNT(m.id) as meeting_count,
    ROUND(AVG(m.sentiment_score), 3) as avg_sentiment,
    ROUND(AVG(m.talk_time_rep_pct), 1) as avg_talk_time,
    ROUND(AVG(m.coach_rating), 1) as avg_coach_rating,
    COUNT(CASE WHEN m.sentiment_score > 0.2 THEN 1 END) as positive_count,
    COUNT(CASE WHEN m.sentiment_score < -0.2 THEN 1 END) as negative_count,
    COUNT(CASE WHEN mc.has_forward_movement = true THEN 1 END) as forward_movement_count,
    ROUND(SUM(m.duration_minutes), 0) as total_duration
  FROM meetings m
  LEFT JOIN profiles p ON m.owner_user_id = p.id
  LEFT JOIN meeting_classifications mc ON mc.meeting_id = m.id
  WHERE m.org_id = p_org_id
    AND m.meeting_start >= NOW() - (p_period_days || ' days')::INTERVAL
    AND m.meeting_start IS NOT NULL
    AND (p_user_id IS NULL OR m.owner_user_id = p_user_id)
  GROUP BY
    CASE p_granularity
      WHEN 'week' THEN DATE_TRUNC('week', m.meeting_start)
      ELSE DATE_TRUNC('day', m.meeting_start)
    END,
    m.owner_user_id,
    p.first_name,
    p.last_name,
    p.email
  ORDER BY period_start DESC, meeting_count DESC;
END;
$$;

-- ALTER FUNCTION "public"."get_team_time_series_metrics"("p_org_id" "uuid", "p_period_days" integer, "p_granularity" "text", "p_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_team_time_series_metrics"("p_org_id" "uuid", "p_period_days" integer, "p_granularity" "text", "p_user_id" "uuid") IS 'Returns time-bucketed metrics for trend charts';

CREATE OR REPLACE FUNCTION "public"."get_top_objections"("p_org_id" "uuid", "p_date_from" timestamp with time zone DEFAULT NULL::timestamp with time zone, "p_date_to" timestamp with time zone DEFAULT NULL::timestamp with time zone, "p_limit" integer DEFAULT 10) RETURNS TABLE("objection" "text", "category" "text", "occurrence_count" bigint, "resolved_count" bigint, "resolution_rate" numeric, "sample_meetings" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  WITH objection_data AS (
    SELECT
      obj->>'objection' as objection,
      obj->>'category' as category,
      (obj->>'resolved')::boolean as resolved,
      mc.meeting_id
    FROM meeting_classifications mc
    INNER JOIN meetings m ON mc.meeting_id = m.id
    CROSS JOIN jsonb_array_elements(mc.objections) as obj
    WHERE mc.org_id = p_org_id
      AND (p_date_from IS NULL OR m.start_time >= p_date_from)
      AND (p_date_to IS NULL OR m.start_time <= p_date_to)
  )
  SELECT
    od.objection,
    od.category,
    COUNT(*) as occurrence_count,
    COUNT(*) FILTER (WHERE od.resolved = true) as resolved_count,
    ROUND((COUNT(*) FILTER (WHERE od.resolved = true)::numeric / NULLIF(COUNT(*)::numeric, 0)) * 100, 1) as resolution_rate,
    jsonb_agg(DISTINCT od.meeting_id) FILTER (WHERE od.meeting_id IS NOT NULL) as sample_meetings
  FROM objection_data od
  GROUP BY od.objection, od.category
  ORDER BY COUNT(*) DESC
  LIMIT p_limit;
END;
$$;

-- ALTER FUNCTION "public"."get_top_objections"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_limit" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_top_objections"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_limit" integer) IS 'Returns most common objections with resolution rates';

CREATE OR REPLACE FUNCTION "public"."get_topic_sources_with_details"("p_global_topic_id" "uuid", "p_limit" integer DEFAULT 10, "p_offset" integer DEFAULT 0) RETURNS TABLE("meeting_id" "uuid", "meeting_title" "text", "meeting_date" timestamp with time zone, "company_name" "text", "contact_name" "text", "topic_title" "text", "topic_description" "text", "timestamp_seconds" integer, "fathom_url" "text", "similarity_score" numeric)
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    gts.meeting_id,
    m.title as meeting_title,
    gts.meeting_date,
    c.name as company_name,
    ct.name as contact_name,
    gts.topic_title,
    gts.topic_description,
    gts.timestamp_seconds,
    gts.fathom_url,
    gts.similarity_score
  FROM global_topic_sources gts
  JOIN meetings m ON m.id = gts.meeting_id
  LEFT JOIN companies c ON c.id = gts.company_id
  LEFT JOIN contacts ct ON ct.id = gts.contact_id
  WHERE gts.global_topic_id = p_global_topic_id
  ORDER BY gts.meeting_date DESC
  LIMIT p_limit
  OFFSET p_offset;
END;
$$;

-- ALTER FUNCTION "public"."get_topic_sources_with_details"("p_global_topic_id" "uuid", "p_limit" integer, "p_offset" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_trial_status"("p_org_id" "uuid") RETURNS TABLE("is_trialing" boolean, "trial_ends_at" timestamp with time zone, "days_remaining" integer, "trial_start_at" timestamp with time zone, "has_payment_method" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    os.status = 'trialing' as is_trialing,
    os.trial_ends_at,
    GREATEST(0, EXTRACT(DAY FROM (os.trial_ends_at - NOW()))::INTEGER) as days_remaining,
    os.trial_start_at,
    os.stripe_payment_method_id IS NOT NULL as has_payment_method
  FROM organization_subscriptions os
  WHERE os.org_id = p_org_id
  AND os.status IN ('active', 'trialing')
  LIMIT 1;
END;
$$;

-- ALTER FUNCTION "public"."get_trial_status"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_trial_status"("p_org_id" "uuid") IS 'Returns trial status details for an organization';

CREATE OR REPLACE FUNCTION "public"."get_unanswered_outbound_count"("contact_id_param" "uuid", "days" integer DEFAULT 14) RETURNS integer
    LANGUAGE "sql" STABLE
    SET "search_path" TO ''
    AS $$
  SELECT COUNT(*)::INTEGER
  FROM communication_events
  WHERE contact_id = contact_id_param
    AND direction = 'outbound'
    AND was_replied = FALSE
    AND event_timestamp >= NOW() - (days || ' days')::INTERVAL;
$$;

-- ALTER FUNCTION "public"."get_unanswered_outbound_count"("contact_id_param" "uuid", "days" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_unprocessed_billing_events"("p_provider" "text" DEFAULT NULL::"text", "p_limit" integer DEFAULT 100) RETURNS TABLE("id" "uuid", "provider" "text", "provider_event_id" "text", "event_type" "text", "occurred_at" timestamp with time zone, "org_id" "uuid", "payload" "jsonb")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    bel.id,
    bel.provider,
    bel.provider_event_id,
    bel.event_type,
    bel.occurred_at,
    bel.org_id,
    bel.payload
  FROM billing_event_log bel
  WHERE bel.processed_at IS NULL
    AND (p_provider IS NULL OR bel.provider = p_provider)
  ORDER BY bel.occurred_at ASC
  LIMIT p_limit;
END;
$$;

-- ALTER FUNCTION "public"."get_unprocessed_billing_events"("p_provider" "text", "p_limit" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_unprocessed_billing_events"("p_provider" "text", "p_limit" integer) IS 'Get unprocessed events for retry/reconciliation';

-- ALTER FUNCTION "public"."get_unread_notification_count"() OWNER TO "postgres";

-- ALTER FUNCTION "public"."get_unread_sentiment_alert_count"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_unread_sentiment_alert_count"() IS 'Get count of unread sentiment alerts for the current user';

CREATE OR REPLACE FUNCTION "public"."get_unresolved_ghost_signals_count"("relationship_health_id_param" "uuid") RETURNS integer
    LANGUAGE "sql" STABLE
    SET "search_path" TO ''
    AS $$
  SELECT COUNT(*)::INTEGER
  FROM ghost_detection_signals
  WHERE relationship_health_id = relationship_health_id_param
    AND resolved_at IS NULL;
$$;

-- ALTER FUNCTION "public"."get_unresolved_ghost_signals_count"("relationship_health_id_param" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_user_active_org"() RETURNS "uuid"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
  SELECT get_user_primary_org();
$$;

-- ALTER FUNCTION "public"."get_user_active_org"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_user_active_org"() IS 'Returns the active organization ID for current user (session override or primary)';

CREATE OR REPLACE FUNCTION "public"."get_user_api_keys"("p_user_id" "uuid") RETURNS TABLE("id" "uuid", "name" "text", "key_preview" "text", "permissions" "jsonb", "rate_limit" integer, "expires_at" timestamp with time zone, "is_active" boolean, "last_used" timestamp with time zone, "usage_count" integer, "created_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ak.id,
    ak.name,
    ak.key_preview,
    ak.permissions,
    ak.rate_limit,
    ak.expires_at,
    ak.is_active,
    ak.last_used,
    ak.usage_count,
    ak.created_at
  FROM api_keys ak
  WHERE ak.user_id = p_user_id
  ORDER BY ak.created_at DESC;
END;
$$;

-- ALTER FUNCTION "public"."get_user_api_keys"("p_user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_user_feature_model_config"("p_user_id" "uuid", "p_feature_key" "text") RETURNS TABLE("provider" "text", "model" "text", "temperature" numeric, "max_tokens" integer, "is_enabled" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT 
    uafs.provider,
    uafs.model,
    uafs.temperature,
    uafs.max_tokens,
    uafs.is_enabled
  FROM user_ai_feature_settings uafs
  WHERE uafs.user_id = p_user_id
    AND uafs.feature_key = p_feature_key
    AND uafs.is_enabled = true
  LIMIT 1;
END;
$$;

-- ALTER FUNCTION "public"."get_user_feature_model_config"("p_user_id" "uuid", "p_feature_key" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_user_feature_model_config"("p_user_id" "uuid", "p_feature_key" "text") IS 'Get user-specific model configuration for a feature, returns empty if not configured';

CREATE TABLE IF NOT EXISTS "public"."google_integrations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "email" "text" NOT NULL,
    "access_token" "text" NOT NULL,
    "refresh_token" "text",
    "expires_at" timestamp with time zone,
    "scopes" "text" NOT NULL,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "clerk_org_id" "text",
    "token_status" "text" DEFAULT 'valid'::"text",
    "last_token_refresh" timestamp with time zone,
    CONSTRAINT "google_integrations_token_status_check" CHECK (("token_status" = ANY (ARRAY['valid'::"text", 'expired'::"text", 'revoked'::"text", 'needs_reconnect'::"text"])))
);

-- ALTER TABLE "public"."google_integrations" OWNER TO "postgres";

COMMENT ON TABLE "public"."google_integrations" IS 'Google OAuth integrations with token health tracking for proactive refresh';

CREATE OR REPLACE FUNCTION "public"."get_user_google_integration"("p_user_id" "uuid") RETURNS SETOF "public"."google_integrations"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
    RETURN QUERY
    SELECT *
    FROM google_integrations
    WHERE user_id = p_user_id
    AND is_active = true
    LIMIT 1;
END;
$$;

-- ALTER FUNCTION "public"."get_user_google_integration"("p_user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_user_id_from_activity"("p_activity_id" "uuid", "p_activity_type" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_user_id UUID;
BEGIN
  CASE p_activity_type
    WHEN 'meeting' THEN
      SELECT owner_user_id INTO v_user_id
      FROM meetings
      WHERE id = p_activity_id;

    WHEN 'call' THEN
      SELECT owner_user_id INTO v_user_id
      FROM calls
      WHERE id = p_activity_id;

    WHEN 'activity' THEN
      SELECT user_id INTO v_user_id
      FROM activities
      WHERE id = p_activity_id;

    ELSE
      RETURN NULL;
  END CASE;

  RETURN v_user_id;
END;
$$;

-- ALTER FUNCTION "public"."get_user_id_from_activity"("p_activity_id" "uuid", "p_activity_type" "text") OWNER TO "postgres";

-- ALTER FUNCTION "public"."get_user_id_from_email"("email_input" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_user_id_from_email"("email_input" "text") IS 'Gets user UUID from email address';

CREATE OR REPLACE FUNCTION "public"."get_user_notification_counts"("p_user_id" "uuid") RETURNS TABLE("hour_count" integer, "day_count" integer, "last_sent_at" timestamp with time zone)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    COALESCE(
      (SELECT COUNT(*)::INTEGER FROM notification_queue
       WHERE user_id = p_user_id
         AND status = 'sent'
         AND sent_at > date_trunc('hour', NOW())),
      0
    ) AS hour_count,
    COALESCE(
      (SELECT COUNT(*)::INTEGER FROM notification_queue
       WHERE user_id = p_user_id
         AND status = 'sent'
         AND sent_at > date_trunc('day', NOW())),
      0
    ) AS day_count,
    (SELECT MAX(sent_at) FROM notification_queue
     WHERE user_id = p_user_id AND status = 'sent') AS last_sent_at;
END;
$$;

-- ALTER FUNCTION "public"."get_user_notification_counts"("p_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_user_notification_counts"("p_user_id" "uuid") IS 'Get notification counts for rate limiting';

-- ALTER FUNCTION "public"."get_user_org_id"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_user_org_id"() IS 'Get current user org_id - cached per statement for RLS performance';

CREATE OR REPLACE FUNCTION "public"."get_user_org_id"("p_user_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
  BEGIN
    RETURN (SELECT org_id FROM organization_memberships WHERE user_id = p_user_id ORDER BY
  created_at ASC LIMIT 1);
  END;
  $$;

-- ALTER FUNCTION "public"."get_user_org_id"("p_user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_user_org_ids"("p_user_id" "uuid") RETURNS SETOF "uuid"
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN QUERY
  SELECT org_id FROM organization_memberships
  WHERE user_id = p_user_id;
END;
$$;

-- ALTER FUNCTION "public"."get_user_org_ids"("p_user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_user_org_role"("p_user_id" "uuid", "p_org_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN (
    SELECT role FROM organization_memberships
    WHERE user_id = p_user_id AND org_id = p_org_id
    LIMIT 1
  );
END;
$$;

-- ALTER FUNCTION "public"."get_user_org_role"("p_user_id" "uuid", "p_org_id" "uuid") OWNER TO "postgres";

-- ALTER FUNCTION "public"."get_user_orgs_with_roles"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_user_orgs_with_roles"() IS 'Returns all organizations the current user belongs to with their roles';

CREATE TABLE IF NOT EXISTS "public"."hitl_pending_approvals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "created_by" "uuid",
    "resource_type" "text" NOT NULL,
    "resource_id" "text" NOT NULL,
    "resource_name" "text",
    "slack_team_id" "text" NOT NULL,
    "slack_channel_id" "text" NOT NULL,
    "slack_message_ts" "text" NOT NULL,
    "slack_thread_ts" "text",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "original_content" "jsonb" NOT NULL,
    "edited_content" "jsonb",
    "response" "jsonb",
    "actioned_by" "uuid",
    "actioned_at" timestamp with time zone,
    "callback_type" "text",
    "callback_target" "text",
    "callback_metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone DEFAULT ("now"() + '24:00:00'::interval),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "hitl_pending_approvals_callback_type_check" CHECK ((("callback_type" IS NULL) OR ("callback_type" = ANY (ARRAY['edge_function'::"text", 'webhook'::"text", 'workflow'::"text"])))),
    CONSTRAINT "hitl_pending_approvals_resource_type_check" CHECK (("resource_type" = ANY (ARRAY['email_draft'::"text", 'follow_up'::"text", 'task_list'::"text", 'summary'::"text", 'meeting_notes'::"text", 'proposal_section'::"text", 'coaching_tip'::"text"]))),
    CONSTRAINT "hitl_pending_approvals_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text", 'edited'::"text", 'expired'::"text", 'cancelled'::"text"])))
);

-- ALTER TABLE "public"."hitl_pending_approvals" OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."get_user_pending_approvals"("p_user_id" "uuid", "p_org_id" "uuid" DEFAULT NULL::"uuid", "p_limit" integer DEFAULT 20) RETURNS SETOF "public"."hitl_pending_approvals"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT *
  FROM hitl_pending_approvals
  WHERE user_id = p_user_id
    AND status = 'pending'
    AND expires_at > now()
    AND (p_org_id IS NULL OR org_id = p_org_id)
  ORDER BY created_at DESC
  LIMIT p_limit;
END;
$$;

-- ALTER FUNCTION "public"."get_user_pending_approvals"("p_user_id" "uuid", "p_org_id" "uuid", "p_limit" integer) OWNER TO "postgres";

-- ALTER FUNCTION "public"."get_user_primary_org"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_user_primary_org"() IS 'Returns the primary (first joined) organization ID for the current user';

CREATE OR REPLACE FUNCTION "public"."get_user_timezone_from_calendar"("p_user_id" "uuid") RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  v_timezone TEXT;
BEGIN
  -- Try to get timezone from calendar_calendars table (if stored there)
  SELECT timezone INTO v_timezone
  FROM calendar_calendars
  WHERE user_id = p_user_id
    AND external_id = 'primary'
    AND timezone IS NOT NULL
  LIMIT 1;
  
  IF v_timezone IS NOT NULL THEN
    RETURN v_timezone;
  END IF;
  
  -- Try to get from user_settings preferences
  SELECT (preferences->>'timezone')::TEXT INTO v_timezone
  FROM user_settings
  WHERE user_id = p_user_id
    AND preferences->>'timezone' IS NOT NULL;
  
  IF v_timezone IS NOT NULL THEN
    RETURN v_timezone;
  END IF;
  
  -- Try to get from profiles table (if exists)
  BEGIN
    SELECT timezone INTO v_timezone
    FROM profiles
    WHERE id = p_user_id
      AND timezone IS NOT NULL;
    
    IF v_timezone IS NOT NULL THEN
      RETURN v_timezone;
    END IF;
  EXCEPTION WHEN OTHERS THEN
    -- profiles table or timezone column might not exist
    NULL;
  END;
  
  -- Default to Europe/London for UK users (can be updated based on user's location)
  RETURN 'Europe/London';
END;
$$;

-- ALTER FUNCTION "public"."get_user_timezone_from_calendar"("p_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_user_timezone_from_calendar"("p_user_id" "uuid") IS 'Gets user timezone from calendar integration, user_settings, or profiles table. Defaults to Europe/London.';

CREATE OR REPLACE FUNCTION "public"."get_user_uuid_from_clerk"() RETURNS "uuid"
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  clerk_id TEXT;
  user_uuid UUID;
BEGIN
  clerk_id := get_clerk_user_id();

  IF clerk_id IS NULL THEN
    RETURN NULL;
  END IF;

  -- Find matching profile by clerk_user_id
  SELECT id INTO user_uuid
  FROM profiles
  WHERE clerk_user_id = clerk_id
  LIMIT 1;

  RETURN user_uuid;
END;
$$;

-- ALTER FUNCTION "public"."get_user_uuid_from_clerk"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_user_uuid_from_clerk"() IS 'Maps Clerk user ID to internal UUID';

CREATE OR REPLACE FUNCTION "public"."get_users_due_for_feedback"("p_org_id" "uuid" DEFAULT NULL::"uuid", "p_limit" integer DEFAULT 50) RETURNS TABLE("user_id" "uuid", "org_id" "uuid", "slack_user_id" "text", "days_since_last_feedback" integer, "notifications_since_last_feedback" integer, "reason" "text")
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    uem.user_id,
    uem.org_id,
    p.slack_user_id,
    CASE
      WHEN uem.last_feedback_requested_at IS NULL THEN NULL
      ELSE EXTRACT(DAY FROM NOW() - uem.last_feedback_requested_at)::INTEGER
    END AS days_since_last_feedback,
    COALESCE(uem.notifications_since_last_feedback, 0) AS notifications_since_last_feedback,
    CASE
      WHEN uem.last_feedback_requested_at IS NULL
           AND COALESCE(uem.notifications_since_last_feedback, 0) >= 10 THEN 'first_feedback_request'
      WHEN uem.last_feedback_requested_at IS NOT NULL
           AND NOW() - uem.last_feedback_requested_at >= INTERVAL '14 days' THEN 'interval_elapsed'
      WHEN COALESCE(uem.notifications_since_last_feedback, 0) >= 20 THEN 'high_notification_count'
      ELSE NULL
    END AS reason
  FROM user_engagement_metrics uem
  JOIN profiles p ON p.id = uem.user_id
  WHERE
    -- Has Slack connected
    p.slack_user_id IS NOT NULL
    -- Filter by org if specified
    AND (p_org_id IS NULL OR uem.org_id = p_org_id)
    -- Due for feedback
    AND (
      -- Never requested and has enough notifications
      (uem.last_feedback_requested_at IS NULL AND COALESCE(uem.notifications_since_last_feedback, 0) >= 10)
      -- Interval elapsed (14 days)
      OR (uem.last_feedback_requested_at IS NOT NULL AND NOW() - uem.last_feedback_requested_at >= INTERVAL '14 days')
      -- High notification count (20+)
      OR (COALESCE(uem.notifications_since_last_feedback, 0) >= 20)
    )
  ORDER BY
    -- Prioritize users with highest notification count
    COALESCE(uem.notifications_since_last_feedback, 0) DESC
  LIMIT p_limit;
END;
$$;

-- ALTER FUNCTION "public"."get_users_due_for_feedback"("p_org_id" "uuid", "p_limit" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_users_due_for_feedback"("p_org_id" "uuid", "p_limit" integer) IS 'Get list of users who are due for feedback requests';

-- ALTER FUNCTION "public"."get_users_with_targets"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_users_with_targets"() IS 'Returns all users with their profile information and targets';

CREATE OR REPLACE FUNCTION "public"."get_waitlist_analytics"() RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  result JSON;
BEGIN
  SELECT json_build_object(
    'total_entries', COUNT(*),
    'by_status', json_build_object(
      'pending', COUNT(*) FILTER (WHERE status = 'pending'),
      'released', COUNT(*) FILTER (WHERE status = 'released'),
      'converted', COUNT(*) FILTER (WHERE status = 'converted')
    ),
    'conversion_rate', ROUND(
      (COUNT(*) FILTER (WHERE status = 'converted')::FLOAT /
       NULLIF(COUNT(*) FILTER (WHERE status = 'released'), 0)) * 100,
      2
    ),
    'avg_conversion_time_days', ROUND(
      AVG(EXTRACT(EPOCH FROM (converted_at - magic_link_sent_at)) / 86400),
      2
    ) FILTER (WHERE converted_at IS NOT NULL AND magic_link_sent_at IS NOT NULL),
    'expired_links', COUNT(*) FILTER (
      WHERE status = 'released'
      AND magic_link_expires_at < now()
    ),
    'recent_conversions_7d', COUNT(*) FILTER (
      WHERE status = 'converted'
      AND converted_at > now() - INTERVAL '7 days'
    )
  ) INTO result
  FROM meetings_waitlist;

  RETURN result;
END;
$$;

-- ALTER FUNCTION "public"."get_waitlist_analytics"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_waitlist_analytics"() IS 'Get aggregated waitlist analytics including conversion rates';

CREATE OR REPLACE FUNCTION "public"."get_waitlist_onboarding_analytics"() RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  result JSON;
BEGIN
  SELECT json_build_object(
    'total_users', COUNT(*),
    'avg_completion', ROUND(AVG(completion_percentage), 2),
    'completed_users', COUNT(*) FILTER (WHERE completion_percentage = 100),
    'in_progress_users', COUNT(*) FILTER (WHERE completion_percentage > 0 AND completion_percentage < 100),
    'not_started_users', COUNT(*) FILTER (WHERE completion_percentage = 0),
    'stuck_users', COUNT(*) FILTER (
      WHERE completion_percentage < 50
      AND created_at < now() - INTERVAL '7 days'
    ),
    'distribution', json_build_object(
      '0-25', COUNT(*) FILTER (WHERE completion_percentage >= 0 AND completion_percentage <= 25),
      '26-50', COUNT(*) FILTER (WHERE completion_percentage >= 26 AND completion_percentage <= 50),
      '51-75', COUNT(*) FILTER (WHERE completion_percentage >= 51 AND completion_percentage <= 75),
      '76-100', COUNT(*) FILTER (WHERE completion_percentage >= 76 AND completion_percentage <= 100)
    ),
    'avg_days_to_complete', ROUND(AVG(EXTRACT(EPOCH FROM (updated_at - created_at)) / 86400), 2)
      FILTER (WHERE completion_percentage = 100)
  ) INTO result
  FROM waitlist_onboarding_progress;

  RETURN result;
END;
$$;

-- ALTER FUNCTION "public"."get_waitlist_onboarding_analytics"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."get_waitlist_onboarding_analytics"() IS 'Get aggregated waitlist onboarding analytics across all users';

CREATE OR REPLACE FUNCTION "public"."handle_deal_insert"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
    INSERT INTO deal_stage_history (deal_id, stage_id, user_id, entered_at)
    VALUES (NEW.id, NEW.stage_id, NEW.owner_id, NEW.created_at);
    RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."handle_deal_insert"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."handle_deal_insert"() IS 'Inserts initial deal stage history record when a deal is created';

CREATE OR REPLACE FUNCTION "public"."handle_deal_stage_change"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  previous_stage_id UUID;
  previous_entry_id UUID;
BEGIN
  -- Check if the stage_id actually changed
  IF OLD.stage_id IS DISTINCT FROM NEW.stage_id THEN

    -- Find the most recent previous history entry for this deal that hasn't exited
    SELECT id, stage_id INTO previous_entry_id, previous_stage_id
    FROM deal_stage_history
    WHERE deal_id = NEW.id AND exited_at IS NULL
    ORDER BY entered_at DESC
    LIMIT 1;

    -- If a previous entry exists, update its exited_at and duration
    IF previous_entry_id IS NOT NULL THEN
      UPDATE deal_stage_history
      SET
        exited_at = NEW.stage_changed_at,
        duration_seconds = EXTRACT(EPOCH FROM (NEW.stage_changed_at - entered_at))::INTEGER
      WHERE id = previous_entry_id;
    END IF;

    -- Insert the new stage history record
    INSERT INTO deal_stage_history (deal_id, stage_id, user_id, entered_at)
    VALUES (NEW.id, NEW.stage_id, NEW.owner_id, NEW.stage_changed_at);

  END IF;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."handle_deal_stage_change"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."handle_deal_stage_change"() IS 'Tracks deal stage transitions by updating exit times and creating new history records';

-- ALTER FUNCTION "public"."handle_hitl_response"("p_request_id" "uuid", "p_response_value" "text", "p_response_context" "jsonb") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."handle_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_waitlist_entry RECORD;
  v_first_name TEXT;
  v_last_name TEXT;
BEGIN
  -- Try to get user info from waitlist entry first
  -- Exclude incomplete signups and ensure valid names
  SELECT full_name, company_name INTO v_waitlist_entry
  FROM meetings_waitlist
  WHERE LOWER(email) = LOWER(NEW.email)
    AND (user_id = NEW.id OR user_id IS NULL)
    AND full_name IS NOT NULL
    AND full_name NOT LIKE '[%'  -- Exclude '[Incomplete Signup]' and similar
    AND LENGTH(TRIM(full_name)) > 0
  ORDER BY created_at ASC
  LIMIT 1;

  -- Parse name from waitlist or use metadata, prefer NULL over empty strings
  IF v_waitlist_entry.full_name IS NOT NULL THEN
    -- Split waitlist full_name into first and last
    v_first_name := NULLIF(TRIM(SPLIT_PART(TRIM(v_waitlist_entry.full_name), ' ', 1)), '');
    v_last_name := NULLIF(TRIM(SUBSTRING(TRIM(v_waitlist_entry.full_name) FROM LENGTH(TRIM(SPLIT_PART(TRIM(v_waitlist_entry.full_name), ' ', 1))) + 2)), '');
  ELSE
    -- Fallback to metadata - use NULL instead of empty string
    v_first_name := NULLIF(TRIM(COALESCE(NEW.raw_user_meta_data->>'first_name', '')), '');
    v_last_name := NULLIF(TRIM(COALESCE(NEW.raw_user_meta_data->>'last_name', '')), '');
  END IF;

  -- Insert profile for new user with waitlist data if available
  -- CRITICAL FIX: Changed from 'active' to 'Trainee' (valid stage value)
  INSERT INTO public.profiles (id, first_name, last_name, email, stage)
  VALUES (
    NEW.id,
    v_first_name,
    v_last_name,
    NEW.email,
    'Trainee'  -- FIXED: was 'active', now uses valid stage
  )
  ON CONFLICT (id) DO NOTHING;  -- Prevent errors if profile already exists

  RETURN NEW;
EXCEPTION
  WHEN OTHERS THEN
    -- Log error but don't fail signup
    RAISE WARNING 'handle_new_user failed for %: %', NEW.id, SQLERRM;
    RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."handle_new_user"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."has_notification_flood"() RETURNS boolean
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  flood_check JSON;
  has_flood BOOLEAN;
BEGIN
  SELECT check_notification_floods('CRITICAL') INTO flood_check;
  has_flood := (flood_check->>'flood_detected')::BOOLEAN;
  RETURN has_flood;
END;
$$;

-- ALTER FUNCTION "public"."has_notification_flood"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."has_notification_flood"() IS 'Quick boolean check for critical notification floods. Returns TRUE if any CRITICAL level floods detected, FALSE otherwise.';

CREATE OR REPLACE FUNCTION "public"."hash_api_key"("key_text" "text") RETURNS "text"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  IF key_text IS NULL OR key_text = '' THEN
    RETURN NULL;
  END IF;
  
  RETURN encode(digest(key_text, 'sha256'), 'hex');
END $$;

-- ALTER FUNCTION "public"."hash_api_key"("key_text" "text") OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."hubspot_sync_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "job_type" "text" NOT NULL,
    "priority" integer DEFAULT 0 NOT NULL,
    "run_after" timestamp with time zone DEFAULT "now"() NOT NULL,
    "attempts" integer DEFAULT 0 NOT NULL,
    "max_attempts" integer DEFAULT 10 NOT NULL,
    "last_error" "text",
    "payload" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "dedupe_key" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "clerk_org_id" "text",
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "hubspot_sync_queue_job_type_check" CHECK (("job_type" = ANY (ARRAY['sync_contact'::"text", 'sync_deal'::"text", 'sync_task'::"text", 'push_note'::"text", 'sync_quote'::"text", 'sync_line_item'::"text", 'poll_form_submissions'::"text", 'ensure_properties'::"text", 'sync_custom_object'::"text"])))
);

-- ALTER TABLE "public"."hubspot_sync_queue" OWNER TO "postgres";

COMMENT ON TABLE "public"."hubspot_sync_queue" IS 'DB-backed queue for HubSpot sync jobs (rate limited + retried by worker).';

CREATE OR REPLACE FUNCTION "public"."hubspot_dequeue_jobs"("p_limit" integer DEFAULT 10, "p_org_id" "uuid" DEFAULT NULL::"uuid") RETURNS SETOF "public"."hubspot_sync_queue"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN QUERY
  WITH picked AS (
    SELECT id
    FROM public.hubspot_sync_queue
    WHERE run_after <= now()
      AND attempts < max_attempts
      AND (p_org_id IS NULL OR org_id = p_org_id)
    ORDER BY priority DESC, run_after ASC, created_at ASC
    FOR UPDATE SKIP LOCKED
    LIMIT GREATEST(1, LEAST(p_limit, 50))
  )
  DELETE FROM public.hubspot_sync_queue q
  USING picked
  WHERE q.id = picked.id
  RETURNING q.*;
END;
$$;

-- ALTER FUNCTION "public"."hubspot_dequeue_jobs"("p_limit" integer, "p_org_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."hubspot_release_worker_lock"() RETURNS boolean
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT pg_advisory_unlock(9112025121421);
$$;

-- ALTER FUNCTION "public"."hubspot_release_worker_lock"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."hubspot_try_acquire_worker_lock"() RETURNS boolean
    LANGUAGE "sql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT pg_try_advisory_lock(9112025121421);
$$;

-- ALTER FUNCTION "public"."hubspot_try_acquire_worker_lock"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."increment_invite_code_usage"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Only increment if a code was used (not the admin bypass SIXTY60)
  IF NEW.invite_code_used IS NOT NULL AND UPPER(NEW.invite_code_used) != 'SIXTY60' THEN
    UPDATE waitlist_invite_codes
    SET use_count = use_count + 1
    WHERE UPPER(code) = UPPER(NEW.invite_code_used);
  END IF;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."increment_invite_code_usage"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."increment_invite_code_usage"("code_value" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  -- Don't track admin bypass usage
  IF UPPER(code_value) = 'SIXTY60' THEN
    RETURN;
  END IF;

  -- Increment usage count and update last_used_at
  UPDATE waitlist_invite_codes
  SET use_count = use_count + 1,
      last_used_at = NOW(),
      updated_at = NOW()
  WHERE UPPER(code) = UPPER(code_value);
END;
$$;

-- ALTER FUNCTION "public"."increment_invite_code_usage"("code_value" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."increment_invite_code_usage"("code_value" "text") IS 'Increments the usage count for an invite code. Called after successful account signup.';

CREATE OR REPLACE FUNCTION "public"."increment_notification_count"("p_user_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE user_engagement_metrics
  SET
    notifications_since_last_feedback = COALESCE(notifications_since_last_feedback, 0) + 1,
    updated_at = NOW()
  WHERE user_id = p_user_id;

  -- If no row exists, create one
  IF NOT FOUND THEN
    INSERT INTO user_engagement_metrics (user_id, notifications_since_last_feedback)
    VALUES (p_user_id, 1);
  END IF;
END;
$$;

-- ALTER FUNCTION "public"."increment_notification_count"("p_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."increment_notification_count"("p_user_id" "uuid") IS 'Increment notification count for feedback tracking';

CREATE OR REPLACE FUNCTION "public"."increment_proposal_views"("p_share_token" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
  BEGIN
    UPDATE proposals
    SET share_views = COALESCE(share_views, 0) + 1,
        last_viewed_at = now()
    WHERE share_token = p_share_token AND is_public = true;
  END;
  $$;

-- ALTER FUNCTION "public"."increment_proposal_views"("p_share_token" "uuid") OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."recording_usage" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "period_start" "date" NOT NULL,
    "period_end" "date" NOT NULL,
    "recordings_count" integer DEFAULT 0,
    "recordings_limit" integer DEFAULT 20,
    "total_duration_seconds" integer DEFAULT 0,
    "storage_used_bytes" bigint DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."recording_usage" OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."increment_recording_usage"("p_org_id" "uuid", "p_period" "date" DEFAULT NULL::"date", "p_duration_seconds" integer DEFAULT 0, "p_storage_bytes" bigint DEFAULT 0) RETURNS "public"."recording_usage"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_period_start DATE;
  v_period_end DATE;
  v_result recording_usage;
BEGIN
  -- Default to current month
  v_period_start := COALESCE(p_period, date_trunc('month', CURRENT_DATE)::DATE);
  v_period_end := (date_trunc('month', v_period_start) + INTERVAL '1 month' - INTERVAL '1 day')::DATE;

  -- Upsert usage record
  INSERT INTO recording_usage (org_id, period_start, period_end, recordings_count, total_duration_seconds, storage_used_bytes)
  VALUES (p_org_id, v_period_start, v_period_end, 1, p_duration_seconds, p_storage_bytes)
  ON CONFLICT (org_id, period_start) DO UPDATE SET
    recordings_count = recording_usage.recordings_count + 1,
    total_duration_seconds = recording_usage.total_duration_seconds + p_duration_seconds,
    storage_used_bytes = recording_usage.storage_used_bytes + p_storage_bytes,
    updated_at = NOW()
  RETURNING * INTO v_result;

  RETURN v_result;
END;
$$;

-- ALTER FUNCTION "public"."increment_recording_usage"("p_org_id" "uuid", "p_period" "date", "p_duration_seconds" integer, "p_storage_bytes" bigint) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."increment_referral_count"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  IF NEW.referred_by_code IS NOT NULL THEN
    UPDATE meetings_waitlist
    SET referral_count = referral_count + 1
    WHERE referral_code = NEW.referred_by_code;
  END IF;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."increment_referral_count"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."increment_sentry_bridge_metrics"("p_org_id" "uuid", "p_date" "date", "p_tickets_created" integer DEFAULT 0, "p_tickets_updated" integer DEFAULT 0, "p_errors" integer DEFAULT 0, "p_processing_time_ms" integer DEFAULT 0) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_bucket_start TIMESTAMPTZ;
  v_bucket_end TIMESTAMPTZ;
BEGIN
  -- Use hourly buckets
  v_bucket_start := date_trunc('hour', now());
  v_bucket_end := v_bucket_start + interval '1 hour';

  INSERT INTO sentry_bridge_metrics (
    org_id,
    bucket_start,
    bucket_end,
    tickets_created,
    tickets_updated,
    webhooks_failed,
    avg_processing_time_ms
  ) VALUES (
    p_org_id,
    v_bucket_start,
    v_bucket_end,
    p_tickets_created,
    p_tickets_updated,
    p_errors,
    p_processing_time_ms
  )
  ON CONFLICT (org_id, bucket_start) DO UPDATE SET
    tickets_created = sentry_bridge_metrics.tickets_created + EXCLUDED.tickets_created,
    tickets_updated = sentry_bridge_metrics.tickets_updated + EXCLUDED.tickets_updated,
    webhooks_failed = sentry_bridge_metrics.webhooks_failed + EXCLUDED.webhooks_failed,
    avg_processing_time_ms = (
      (sentry_bridge_metrics.avg_processing_time_ms * sentry_bridge_metrics.webhooks_processed + EXCLUDED.avg_processing_time_ms) /
      NULLIF(sentry_bridge_metrics.webhooks_processed + 1, 0)
    ),
    webhooks_processed = sentry_bridge_metrics.webhooks_processed + 1;
END;
$$;

-- ALTER FUNCTION "public"."increment_sentry_bridge_metrics"("p_org_id" "uuid", "p_date" "date", "p_tickets_created" integer, "p_tickets_updated" integer, "p_errors" integer, "p_processing_time_ms" integer) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."increment_source_count"("topic_id" "uuid") RETURNS integer
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  new_count INTEGER;
BEGIN
  UPDATE global_topics
  SET source_count = source_count + 1,
      updated_at = NOW()
  WHERE id = topic_id
  RETURNING source_count INTO new_count;

  RETURN new_count;
END;
$$;

-- ALTER FUNCTION "public"."increment_source_count"("topic_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."increment_voice_recording_views"("p_share_token" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE voice_recordings
  SET share_views = COALESCE(share_views, 0) + 1,
      last_viewed_at = now()
  WHERE share_token = p_share_token AND is_public = true;
END;
$$;

-- ALTER FUNCTION "public"."increment_voice_recording_views"("p_share_token" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."initialize_deal_close_plan"("p_deal_id" "uuid", "p_org_id" "uuid", "p_owner_id" "uuid" DEFAULT NULL::"uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  INSERT INTO deal_close_plan_items (deal_id, org_id, milestone_key, title, owner_id, sort_order)
  VALUES
    (p_deal_id, p_org_id, 'success_criteria', 'Success criteria confirmed', p_owner_id, 1),
    (p_deal_id, p_org_id, 'stakeholders_mapped', 'Stakeholders mapped', p_owner_id, 2),
    (p_deal_id, p_org_id, 'solution_fit', 'Solution fit confirmed', p_owner_id, 3),
    (p_deal_id, p_org_id, 'commercials_aligned', 'Commercials aligned', p_owner_id, 4),
    (p_deal_id, p_org_id, 'legal_procurement', 'Legal/procurement progressing', p_owner_id, 5),
    (p_deal_id, p_org_id, 'signature_kickoff', 'Signature + kickoff scheduled', p_owner_id, 6)
  ON CONFLICT (deal_id, milestone_key) DO NOTHING;
END;
$$;

-- ALTER FUNCTION "public"."initialize_deal_close_plan"("p_deal_id" "uuid", "p_org_id" "uuid", "p_owner_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."initialize_deal_close_plan"("p_deal_id" "uuid", "p_org_id" "uuid", "p_owner_id" "uuid") IS 'Creates the 6 standard milestones for a deal';

CREATE OR REPLACE FUNCTION "public"."initialize_user_engagement_metrics"("p_user_id" "uuid", "p_org_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_metrics_id UUID;
BEGIN
  INSERT INTO user_engagement_metrics (user_id, org_id)
  VALUES (p_user_id, p_org_id)
  ON CONFLICT (user_id) DO NOTHING
  RETURNING id INTO v_metrics_id;

  -- If insert was skipped due to conflict, get existing id
  IF v_metrics_id IS NULL THEN
    SELECT id INTO v_metrics_id FROM user_engagement_metrics WHERE user_id = p_user_id;
  END IF;

  RETURN v_metrics_id;
END;
$$;

-- ALTER FUNCTION "public"."initialize_user_engagement_metrics"("p_user_id" "uuid", "p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."initialize_user_engagement_metrics"("p_user_id" "uuid", "p_org_id" "uuid") IS 'Creates or returns engagement metrics record for a user';

-- ALTER FUNCTION "public"."is_admin"() OWNER TO "postgres";

-- ALTER FUNCTION "public"."is_admin_optimized"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."is_admin_optimized"() IS 'Returns true if current auth user has profiles.is_admin = true (SECURITY DEFINER to avoid RLS recursion)';

CREATE OR REPLACE FUNCTION "public"."is_clerk_admin"() RETURNS boolean
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  is_admin_claim TEXT;
  user_uuid UUID;
BEGIN
  -- Try to get from JWT metadata first
  BEGIN
    is_admin_claim := current_setting('request.jwt.claims', true)::json->'metadata'->>'is_admin';
    IF is_admin_claim = 'true' THEN
      RETURN true;
    END IF;
  EXCEPTION
    WHEN OTHERS THEN
      -- JWT metadata not available
  END;

  -- Fallback: check profiles table
  user_uuid := get_user_uuid_from_clerk();

  IF user_uuid IS NULL THEN
    RETURN false;
  END IF;

  RETURN EXISTS (
    SELECT 1
    FROM profiles
    WHERE id = user_uuid
    AND is_admin = true
  );
END;
$$;

-- ALTER FUNCTION "public"."is_clerk_admin"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."is_clerk_admin"() IS 'Checks if current Clerk user has admin privileges';

-- ALTER FUNCTION "public"."is_clerk_authenticated"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."is_clerk_authenticated"() IS 'Returns true if the current request is authenticated via Clerk JWT';

-- ALTER FUNCTION "public"."is_internal_assignee"("email_input" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."is_internal_assignee"("email_input" "text") IS 'Checks if an email belongs to an internal user (sales rep)';

CREATE OR REPLACE FUNCTION "public"."is_org_member"("p_user_id" "uuid", "p_org_id" "uuid") RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.organization_memberships
    WHERE user_id = p_user_id
      AND org_id = p_org_id
  );
$$;

-- ALTER FUNCTION "public"."is_org_member"("p_user_id" "uuid", "p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."is_org_member"("p_user_id" "uuid", "p_org_id" "uuid") IS 'Checks if a user is a member of an organization (SECURITY DEFINER)';

-- ALTER FUNCTION "public"."is_org_owner"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."is_org_owner"("p_org_id" "uuid") IS 'Checks if current user is an owner of the organization';

-- ALTER FUNCTION "public"."is_platform_admin"() OWNER TO "postgres";

-- ALTER FUNCTION "public"."is_platform_admin_for_testing"() OWNER TO "postgres";

-- ALTER FUNCTION "public"."is_service_role"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."is_service_role"() IS 'Returns true if the current request role is service_role (safe, no JSON casts)';

-- ALTER FUNCTION "public"."is_super_admin"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."is_super_admin"("p_user_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM profiles
    WHERE id = p_user_id AND is_admin = true
  );
END;
$$;

-- ALTER FUNCTION "public"."is_super_admin"("p_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."is_super_admin"("p_user_id" "uuid") IS 'Checks if a user is a super admin (is_admin flag)';

CREATE OR REPLACE FUNCTION "public"."is_task_from_meeting"("p_task_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" STABLE
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1
    FROM tasks
    WHERE id = p_task_id
      AND meeting_action_item_id IS NOT NULL
  );
END;
$$;

-- ALTER FUNCTION "public"."is_task_from_meeting"("p_task_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."is_task_from_meeting"("p_task_id" "uuid") IS 'Check if a task was created from a meeting action item';

CREATE OR REPLACE FUNCTION "public"."is_user_admin"("user_id" "uuid") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
    DECLARE
      is_admin_status boolean;
    BEGIN
      -- Check the is_admin status in the profiles table for the given user_id
      SELECT is_admin INTO is_admin_status
      FROM public.profiles
      WHERE id = user_id;

      -- Return the status, defaulting to false if not found or null
      RETURN COALESCE(is_admin_status, false);
    END;
    $$;

-- ALTER FUNCTION "public"."is_user_admin"("user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."link_profile_to_clerk_user"("p_profile_id" "uuid", "p_clerk_user_id" "text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Update the profile with Clerk user ID
  UPDATE profiles
  SET
    clerk_user_id = p_clerk_user_id,
    auth_provider = CASE
      WHEN auth_provider = 'supabase' THEN 'both'
      ELSE 'clerk'
    END,
    updated_at = NOW()
  WHERE id = p_profile_id;

  -- Also create/update the mapping table
  PERFORM create_clerk_user_mapping(p_clerk_user_id, p_profile_id, (
    SELECT email FROM profiles WHERE id = p_profile_id
  ));

  RETURN FOUND;
END;
$$;

-- ALTER FUNCTION "public"."link_profile_to_clerk_user"("p_profile_id" "uuid", "p_clerk_user_id" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."link_profile_to_clerk_user"("p_profile_id" "uuid", "p_clerk_user_id" "text") IS 'Links an existing Supabase profile to a Clerk user ID';

CREATE OR REPLACE FUNCTION "public"."link_user_to_waitlist"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  waitlist_entry RECORD;
BEGIN
  -- Find waitlist entry by email where status='released' or 'pending' and no user linked
  SELECT * INTO waitlist_entry
  FROM meetings_waitlist
  WHERE LOWER(email) = LOWER(NEW.email)
    AND status IN ('released', 'pending')
    AND user_id IS NULL
  ORDER BY
    CASE WHEN status = 'released' THEN 1 ELSE 2 END,
    created_at ASC
  LIMIT 1;

  IF FOUND THEN
    -- Link user to waitlist entry
    UPDATE meetings_waitlist
    SET
      user_id = NEW.id,
      status = 'converted',
      converted_at = now()
    WHERE id = waitlist_entry.id;

    -- Create onboarding progress record
    INSERT INTO user_onboarding_progress (
      user_id,
      waitlist_entry_id,
      account_created_at
    )
    VALUES (
      NEW.id,
      waitlist_entry.id,
      now()
    )
    ON CONFLICT (user_id) DO NOTHING;

    RAISE LOG 'Linked user % to waitlist entry %', NEW.id, waitlist_entry.id;
  END IF;

  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  -- Don't fail signup if waitlist linking fails
  RAISE WARNING 'link_user_to_waitlist failed for %: %', NEW.id, SQLERRM;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."link_user_to_waitlist"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."link_user_to_waitlist"() IS 'Automatically links new auth users to their waitlist entries by email';

CREATE OR REPLACE FUNCTION "public"."log_api_request"("p_api_key_id" "uuid", "p_user_id" "uuid", "p_method" "text", "p_endpoint" "text", "p_headers" "jsonb", "p_body" "jsonb", "p_status_code" integer, "p_response_body" "jsonb") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  -- For testing, just do nothing - logging is optional
  -- In production, you'd insert into an api_requests table
  RETURN;
END $$;

-- ALTER FUNCTION "public"."log_api_request"("p_api_key_id" "uuid", "p_user_id" "uuid", "p_method" "text", "p_endpoint" "text", "p_headers" "jsonb", "p_body" "jsonb", "p_status_code" integer, "p_response_body" "jsonb") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."log_integration_sync"("p_org_id" "uuid" DEFAULT NULL::"uuid", "p_user_id" "uuid" DEFAULT NULL::"uuid", "p_integration_name" "text" DEFAULT NULL::"text", "p_operation" "text" DEFAULT 'sync'::"text", "p_direction" "text" DEFAULT NULL::"text", "p_entity_type" "text" DEFAULT NULL::"text", "p_entity_id" "text" DEFAULT NULL::"text", "p_entity_name" "text" DEFAULT NULL::"text", "p_status" "text" DEFAULT 'success'::"text", "p_error_message" "text" DEFAULT NULL::"text", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb", "p_batch_id" "uuid" DEFAULT NULL::"uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_log_id UUID;
BEGIN
  INSERT INTO integration_sync_logs (
    org_id,
    user_id,
    integration_name,
    operation,
    direction,
    entity_type,
    entity_id,
    entity_name,
    status,
    error_message,
    metadata,
    batch_id
  ) VALUES (
    p_org_id,
    p_user_id,
    p_integration_name,
    p_operation,
    p_direction,
    p_entity_type,
    p_entity_id,
    p_entity_name,
    p_status,
    p_error_message,
    p_metadata,
    p_batch_id
  )
  RETURNING id INTO v_log_id;

  RETURN v_log_id;
END;
$$;

-- ALTER FUNCTION "public"."log_integration_sync"("p_org_id" "uuid", "p_user_id" "uuid", "p_integration_name" "text", "p_operation" "text", "p_direction" "text", "p_entity_type" "text", "p_entity_id" "text", "p_entity_name" "text", "p_status" "text", "p_error_message" "text", "p_metadata" "jsonb", "p_batch_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."log_integration_sync"("p_org_id" "uuid", "p_user_id" "uuid", "p_integration_name" "text", "p_operation" "text", "p_direction" "text", "p_entity_type" "text", "p_entity_id" "text", "p_entity_name" "text", "p_status" "text", "p_error_message" "text", "p_metadata" "jsonb", "p_batch_id" "uuid") IS 'Standardized helper for logging integration sync operations from edge functions';

CREATE OR REPLACE FUNCTION "public"."log_user_activity_event"("p_user_id" "uuid", "p_org_id" "uuid", "p_event_type" "text", "p_event_source" "text", "p_event_category" "text" DEFAULT NULL::"text", "p_entity_type" "text" DEFAULT NULL::"text", "p_entity_id" "uuid" DEFAULT NULL::"uuid", "p_action_detail" "text" DEFAULT NULL::"text", "p_session_id" "uuid" DEFAULT NULL::"uuid", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_event_id UUID;
  v_now TIMESTAMPTZ := NOW();
BEGIN
  INSERT INTO user_activity_events (
    user_id, org_id, event_type, event_source, event_category,
    entity_type, entity_id, action_detail, session_id, metadata,
    event_at, day_of_week, hour_of_day
  )
  VALUES (
    p_user_id, p_org_id, p_event_type, p_event_source, p_event_category,
    p_entity_type, p_entity_id, p_action_detail, p_session_id, p_metadata,
    v_now,
    EXTRACT(DOW FROM v_now)::INTEGER,
    EXTRACT(HOUR FROM v_now)::INTEGER
  )
  RETURNING id INTO v_event_id;

  -- Update last activity timestamp in engagement metrics
  UPDATE user_engagement_metrics
  SET
    last_app_active_at = CASE WHEN p_event_source = 'app' THEN v_now ELSE last_app_active_at END,
    last_slack_active_at = CASE WHEN p_event_source = 'slack' THEN v_now ELSE last_slack_active_at END,
    last_login_at = CASE WHEN p_event_type = 'login' THEN v_now ELSE last_login_at END
  WHERE user_id = p_user_id;

  -- Initialize metrics if they don't exist yet
  IF NOT FOUND THEN
    PERFORM initialize_user_engagement_metrics(p_user_id, p_org_id);

    UPDATE user_engagement_metrics
    SET
      last_app_active_at = CASE WHEN p_event_source = 'app' THEN v_now ELSE NULL END,
      last_slack_active_at = CASE WHEN p_event_source = 'slack' THEN v_now ELSE NULL END,
      last_login_at = CASE WHEN p_event_type = 'login' THEN v_now ELSE NULL END
    WHERE user_id = p_user_id;
  END IF;

  RETURN v_event_id;
END;
$$;

-- ALTER FUNCTION "public"."log_user_activity_event"("p_user_id" "uuid", "p_org_id" "uuid", "p_event_type" "text", "p_event_source" "text", "p_event_category" "text", "p_entity_type" "text", "p_entity_id" "uuid", "p_action_detail" "text", "p_session_id" "uuid", "p_metadata" "jsonb") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."log_user_activity_event"("p_user_id" "uuid", "p_org_id" "uuid", "p_event_type" "text", "p_event_source" "text", "p_event_category" "text", "p_entity_type" "text", "p_entity_id" "uuid", "p_action_detail" "text", "p_session_id" "uuid", "p_metadata" "jsonb") IS 'Logs a user activity event with auto-computed timing fields';

-- ALTER FUNCTION "public"."log_waitlist_admin_action"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."log_waitlist_admin_action"() IS 'Logs admin actions on waitlist entries. Gracefully handles missing waitlist_admin_actions table - updates will still succeed even if logging fails.';

CREATE OR REPLACE FUNCTION "public"."map_deal_activity_to_main_activity"("deal_activity_type" "text") RETURNS "text"
    LANGUAGE "plpgsql" IMMUTABLE
    SET "search_path" TO ''
    AS $$
BEGIN
  RETURN CASE deal_activity_type
    WHEN 'call' THEN 'outbound'
    WHEN 'email' THEN 'outbound'  
    WHEN 'meeting' THEN 'meeting'
    WHEN 'task' THEN 'outbound'
    -- Don't sync notes and stage_changes to main activities
    ELSE NULL
  END;
END;
$$;

-- ALTER FUNCTION "public"."map_deal_activity_to_main_activity"("deal_activity_type" "text") OWNER TO "postgres";

-- ALTER FUNCTION "public"."mark_all_notifications_read"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."mark_all_notifications_read"() IS 'Marks all unread notifications as read for the current user';

CREATE OR REPLACE FUNCTION "public"."mark_billing_event_processed"("p_id" "uuid", "p_error" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE billing_event_log
  SET
    processed_at = NOW(),
    processing_error = p_error
  WHERE id = p_id;
END;
$$;

-- ALTER FUNCTION "public"."mark_billing_event_processed"("p_id" "uuid", "p_error" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."mark_billing_event_processed"("p_id" "uuid", "p_error" "text") IS 'Mark an event as processed (with optional error)';

CREATE OR REPLACE FUNCTION "public"."mark_notification_failed"("p_queue_id" "uuid", "p_error_message" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE notification_queue
  SET
    status = CASE WHEN attempts >= 3 THEN 'failed' ELSE 'pending' END,
    error_message = p_error_message
  WHERE id = p_queue_id;
END;
$$;

-- ALTER FUNCTION "public"."mark_notification_failed"("p_queue_id" "uuid", "p_error_message" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."mark_notification_failed"("p_queue_id" "uuid", "p_error_message" "text") IS 'Mark a notification as failed, may retry';

-- ALTER FUNCTION "public"."mark_notification_read"("p_notification_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."mark_notification_read"("p_notification_id" "uuid") IS 'Marks a specific notification as read for the current user';

CREATE OR REPLACE FUNCTION "public"."mark_notification_sent"("p_queue_id" "uuid", "p_interaction_id" "uuid" DEFAULT NULL::"uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE notification_queue
  SET
    status = 'sent',
    sent_at = NOW(),
    notification_interaction_id = p_interaction_id
  WHERE id = p_queue_id;
END;
$$;

-- ALTER FUNCTION "public"."mark_notification_sent"("p_queue_id" "uuid", "p_interaction_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."mark_notification_sent"("p_queue_id" "uuid", "p_interaction_id" "uuid") IS 'Mark a notification as successfully sent';

CREATE OR REPLACE FUNCTION "public"."mark_onboarding_complete"("p_org_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  UPDATE organizations
  SET 
    onboarding_completed_at = NOW(),
    updated_at = NOW()
  WHERE id = p_org_id
  AND onboarding_completed_at IS NULL;
  
  -- Also mark all existing meetings as historical imports
  UPDATE meetings
  SET is_historical_import = true
  WHERE org_id = p_org_id
  AND is_historical_import = false;
END;
$$;

-- ALTER FUNCTION "public"."mark_onboarding_complete"("p_org_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."mark_onboarding_complete"("p_org_id" "uuid") IS 'Mark org onboarding as complete and flag existing meetings as historical imports';

-- ALTER FUNCTION "public"."mark_sentiment_alert_read"("p_alert_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."mark_sentiment_alert_read"("p_alert_id" "uuid") IS 'Mark a sentiment alert as read for the current user';

CREATE OR REPLACE FUNCTION "public"."mark_skill_compiled"("p_org_skill_id" "uuid", "p_compiled_frontmatter" "jsonb", "p_compiled_content" "text", "p_platform_skill_id" "uuid", "p_platform_version" integer) RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE organization_skills
  SET
    compiled_frontmatter = p_compiled_frontmatter,
    compiled_content = p_compiled_content,
    platform_skill_id = p_platform_skill_id,
    platform_skill_version = p_platform_version,
    last_compiled_at = now(),
    updated_at = now()
  WHERE id = p_org_skill_id;

  RETURN FOUND;
END;
$$;

-- ALTER FUNCTION "public"."mark_skill_compiled"("p_org_skill_id" "uuid", "p_compiled_frontmatter" "jsonb", "p_compiled_content" "text", "p_platform_skill_id" "uuid", "p_platform_version" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."mark_skill_compiled"("p_org_skill_id" "uuid", "p_compiled_frontmatter" "jsonb", "p_compiled_content" "text", "p_platform_skill_id" "uuid", "p_platform_version" integer) IS 'Updates organization_skills after successful compilation';

CREATE OR REPLACE FUNCTION "public"."mark_waitlist_onboarding_step"("p_user_id" "uuid", "p_step" "text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $_$
DECLARE
  step_column TEXT;
  rows_affected INTEGER;
BEGIN
  -- Validate step name and map to column
  step_column := CASE p_step
    WHEN 'account_created' THEN 'account_created_at'
    WHEN 'profile_completed' THEN 'profile_completed_at'
    WHEN 'first_meeting_synced' THEN 'first_meeting_synced_at'
    WHEN 'meeting_intelligence_used' THEN 'meeting_intelligence_used_at'
    WHEN 'crm_integrated' THEN 'crm_integrated_at'
    WHEN 'team_invited' THEN 'team_invited_at'
    ELSE NULL
  END;

  IF step_column IS NULL THEN
    RAISE EXCEPTION 'Invalid onboarding step: %', p_step;
  END IF;

  -- Update the step timestamp if not already set
  EXECUTE format(
    'UPDATE waitlist_onboarding_progress
     SET %I = COALESCE(%I, now())
     WHERE user_id = $1',
    step_column, step_column
  ) USING p_user_id;

  GET DIAGNOSTICS rows_affected = ROW_COUNT;

  RETURN rows_affected > 0;
END;
$_$;

-- ALTER FUNCTION "public"."mark_waitlist_onboarding_step"("p_user_id" "uuid", "p_step" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."mark_waitlist_onboarding_step"("p_user_id" "uuid", "p_step" "text") IS 'Mark a specific waitlist onboarding step as complete for a user';

CREATE TABLE IF NOT EXISTS "public"."meetings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "fathom_recording_id" "text" NOT NULL,
    "title" "text",
    "share_url" "text",
    "calls_url" "text",
    "meeting_start" timestamp with time zone,
    "meeting_end" timestamp with time zone,
    "duration_minutes" numeric,
    "owner_user_id" "uuid",
    "owner_email" "text",
    "team_name" "text",
    "company_id" "uuid",
    "primary_contact_id" "uuid",
    "summary" "text",
    "transcript_doc_url" "text",
    "sentiment_score" numeric,
    "coach_rating" numeric,
    "coach_summary" "text",
    "talk_time_rep_pct" numeric,
    "talk_time_customer_pct" numeric,
    "talk_time_judgement" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "contact_id" "uuid",
    "start_time" timestamp with time zone,
    "fathom_embed_url" "text",
    "ai_training_metadata" "jsonb",
    "fathom_user_id" "text",
    "last_synced_at" timestamp with time zone,
    "sync_status" "text" DEFAULT 'synced'::"text",
    "thumbnail_url" "text",
    "fathom_created_at" timestamp with time zone,
    "transcript_language" "text" DEFAULT 'en'::"text",
    "calendar_invitees_type" "text",
    "transcript_text" "text",
    "transcript_fetch_attempts" integer DEFAULT 0,
    "last_transcript_fetch_at" timestamp with time zone,
    "sentiment_reasoning" "text",
    "next_actions_generated_at" timestamp with time zone,
    "next_actions_count" integer DEFAULT 0,
    "summary_oneliner" "text",
    "next_steps_oneliner" "text",
    "clerk_org_id" "text",
    "org_id" "uuid",
    "is_historical_import" boolean DEFAULT false,
    "call_type_id" "uuid",
    "call_type_reasoning" "text",
    "call_type_confidence" numeric(3,2),
    "thumbnail_status" "public"."meeting_processing_status" DEFAULT 'pending'::"public"."meeting_processing_status",
    "transcript_status" "public"."meeting_processing_status" DEFAULT 'pending'::"public"."meeting_processing_status",
    "summary_status" "public"."meeting_processing_status" DEFAULT 'pending'::"public"."meeting_processing_status",
    "source_type" "text" DEFAULT 'fathom'::"text" NOT NULL,
    "voice_recording_id" "uuid",
    CONSTRAINT "meetings_calendar_invitees_type_check" CHECK (("calendar_invitees_type" = ANY (ARRAY['all_internal'::"text", 'one_or_more_external'::"text"]))),
    CONSTRAINT "meetings_call_type_confidence_check" CHECK ((("call_type_confidence" >= (0)::numeric) AND ("call_type_confidence" <= (1)::numeric))),
    CONSTRAINT "meetings_coach_rating_check" CHECK ((("coach_rating" >= (0)::numeric) AND ("coach_rating" <= (100)::numeric))),
    CONSTRAINT "meetings_sentiment_score_check" CHECK ((("sentiment_score" >= ('-1'::integer)::numeric) AND ("sentiment_score" <= (1)::numeric))),
    CONSTRAINT "meetings_source_type_check" CHECK (("source_type" = ANY (ARRAY['fathom'::"text", 'voice'::"text"]))),
    CONSTRAINT "meetings_sync_status_check" CHECK (("sync_status" = ANY (ARRAY['synced'::"text", 'pending'::"text", 'error'::"text"])))
);

-- ALTER TABLE "public"."meetings" OWNER TO "postgres";

COMMENT ON COLUMN "public"."meetings"."primary_contact_id" IS 'Primary external contact for quick reference (denormalized from meeting_contacts)';

COMMENT ON COLUMN "public"."meetings"."sentiment_score" IS 'Overall call sentiment from -1.0 (negative) to 1.0 (positive) calculated by Claude AI';

COMMENT ON COLUMN "public"."meetings"."talk_time_rep_pct" IS 'Sales rep talk time percentage calculated by Claude AI';

COMMENT ON COLUMN "public"."meetings"."talk_time_customer_pct" IS 'Customer talk time percentage calculated by Claude AI';

COMMENT ON COLUMN "public"."meetings"."talk_time_judgement" IS 'Natural language assessment of talk time balance from Claude AI (e.g., "Balanced conversation", "Rep talked too much", "Good listening")';

COMMENT ON COLUMN "public"."meetings"."fathom_user_id" IS 'Fathom user ID who owns this recording';

COMMENT ON COLUMN "public"."meetings"."last_synced_at" IS 'Timestamp of last sync from Fathom API';

COMMENT ON COLUMN "public"."meetings"."sync_status" IS 'Current sync status: synced, syncing, or error';

COMMENT ON COLUMN "public"."meetings"."thumbnail_url" IS 'Cached thumbnail image for the Fathom recording (from share page og:image)';

COMMENT ON COLUMN "public"."meetings"."fathom_created_at" IS 'Timestamp when the recording was created in Fathom (may differ from meeting_start)';

COMMENT ON COLUMN "public"."meetings"."transcript_language" IS 'Language code for the transcript (e.g., en, es, fr)';

COMMENT ON COLUMN "public"."meetings"."calendar_invitees_type" IS 'Type of invitees: all_internal or one_or_more_external';

COMMENT ON COLUMN "public"."meetings"."transcript_text" IS 'Raw plaintext transcript from Fathom API. Used for search and analysis. Google Doc URL still stored in transcript_doc_url.';

COMMENT ON COLUMN "public"."meetings"."transcript_fetch_attempts" IS 'Number of times we''ve attempted to fetch the transcript from Fathom';

COMMENT ON COLUMN "public"."meetings"."last_transcript_fetch_at" IS 'Last time we attempted to fetch the transcript';

COMMENT ON COLUMN "public"."meetings"."sentiment_reasoning" IS 'Explanation of sentiment score from Claude AI';

COMMENT ON COLUMN "public"."meetings"."is_historical_import" IS 'True if meeting was imported during initial onboarding sync (not counted toward new meeting limit)';

COMMENT ON COLUMN "public"."meetings"."call_type_id" IS 'AI-classified call type from org_call_types';

COMMENT ON COLUMN "public"."meetings"."call_type_reasoning" IS 'AI explanation for why this call type was selected';

COMMENT ON COLUMN "public"."meetings"."call_type_confidence" IS 'Confidence score (0-1) for the call type classification';

COMMENT ON COLUMN "public"."meetings"."thumbnail_status" IS 'Processing status for video thumbnail generation';

COMMENT ON COLUMN "public"."meetings"."transcript_status" IS 'Processing status for transcript fetching from Fathom';

COMMENT ON COLUMN "public"."meetings"."summary_status" IS 'Processing status for AI-generated meeting summary';

COMMENT ON COLUMN "public"."meetings"."source_type" IS 'Source of meeting: fathom (video from Fathom.video) or voice (audio from Voice Recorder)';

COMMENT ON COLUMN "public"."meetings"."voice_recording_id" IS 'Reference to voice_recordings table when source_type is voice';

CREATE OR REPLACE FUNCTION "public"."meeting_needs_transcript_retry"("meeting_row" "public"."meetings") RETURNS boolean
    LANGUAGE "sql" STABLE
    AS $$
  SELECT
    meeting_row.transcript_text IS NULL
    AND meeting_row.fathom_recording_id IS NOT NULL
    AND (
      meeting_row.transcript_fetch_attempts IS NULL
      OR meeting_row.transcript_fetch_attempts < 5
    )
    AND NOT EXISTS (
      SELECT 1
      FROM fathom_transcript_retry_jobs
      WHERE meeting_id = meeting_row.id
        AND status IN ('pending', 'processing')
    );
$$;

-- ALTER FUNCTION "public"."meeting_needs_transcript_retry"("meeting_row" "public"."meetings") OWNER TO "postgres";

-- ALTER FUNCTION "public"."merge_global_topics"("p_source_topic_id" "uuid", "p_target_topic_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."migrate_deal_entities"("deal_record" "record") RETURNS "jsonb"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $_$
DECLARE
  v_company_id UUID;
  v_contact_id UUID;
  v_domain TEXT;
  v_contact_name TEXT;
  v_first_name TEXT;
  v_last_name TEXT;
BEGIN
  -- Use email as fallback if contact_name is missing
  v_contact_name := COALESCE(NULLIF(TRIM(deal_record.contact_name), ''),
                              SPLIT_PART(deal_record.contact_email, '@', 1));

  -- Extract domain from email
  v_domain := LOWER(TRIM(SUBSTRING(deal_record.contact_email FROM '@(.*)$')));

  -- Skip personal email domains
  IF v_domain IN ('gmail.com', 'yahoo.com', 'hotmail.com', 'outlook.com', 'icloud.com', 'me.com', 'aol.com', 'live.com') THEN
    v_domain := NULL;
  END IF;

  -- Find or create company
  BEGIN
    IF v_domain IS NOT NULL THEN
      SELECT id INTO v_company_id FROM companies WHERE LOWER(domain) = v_domain LIMIT 1;

      IF v_company_id IS NULL THEN
        INSERT INTO companies (name, domain, owner_id, created_at, updated_at)
        VALUES (
          COALESCE(deal_record.company, INITCAP(REPLACE(v_domain, '.', ' '))),
          v_domain,
          deal_record.owner_id,
          NOW(),
          NOW()
        )
        RETURNING id INTO v_company_id;
      END IF;
    ELSE
      -- No domain - use company name
      IF deal_record.company IS NOT NULL AND TRIM(deal_record.company) != '' THEN
        SELECT id INTO v_company_id
        FROM companies
        WHERE LOWER(name) = LOWER(TRIM(deal_record.company))
          AND owner_id = deal_record.owner_id
        LIMIT 1;

        IF v_company_id IS NULL THEN
          INSERT INTO companies (name, owner_id, created_at, updated_at)
          VALUES (deal_record.company, deal_record.owner_id, NOW(), NOW())
          RETURNING id INTO v_company_id;
        END IF;
      END IF;
    END IF;
  EXCEPTION WHEN OTHERS THEN
    v_company_id := NULL;
  END;

  -- Find or create contact
  IF v_company_id IS NOT NULL THEN
    BEGIN
      -- Check for existing contact by email
      SELECT id INTO v_contact_id
      FROM contacts
      WHERE LOWER(TRIM(email)) = LOWER(TRIM(deal_record.contact_email))
        AND company_id = v_company_id;

      IF v_contact_id IS NULL THEN
        -- Check if email exists with different company
        SELECT id, company_id INTO v_contact_id, v_company_id
        FROM contacts
        WHERE LOWER(TRIM(email)) = LOWER(TRIM(deal_record.contact_email))
        LIMIT 1;

        IF v_contact_id IS NULL THEN
          -- Create new contact
          IF POSITION(' ' IN v_contact_name) > 0 THEN
            v_first_name := SPLIT_PART(v_contact_name, ' ', 1);
            v_last_name := SUBSTRING(v_contact_name FROM POSITION(' ' IN v_contact_name) + 1);
          ELSE
            v_first_name := v_contact_name;
            v_last_name := '';
          END IF;

          INSERT INTO contacts (
            first_name,
            last_name,
            email,
            company_id,
            is_primary,
            owner_id,
            created_at,
            updated_at
          )
          VALUES (
            v_first_name,
            NULLIF(v_last_name, ''),
            LOWER(TRIM(deal_record.contact_email)),
            v_company_id,
            NOT EXISTS (SELECT 1 FROM contacts WHERE company_id = v_company_id LIMIT 1),
            deal_record.owner_id,
            NOW(),
            NOW()
          )
          RETURNING id INTO v_contact_id;
        END IF;
      END IF;
    EXCEPTION WHEN OTHERS THEN
      v_contact_id := NULL;
    END;
  END IF;

  RETURN jsonb_build_object(
    'success', v_company_id IS NOT NULL AND v_contact_id IS NOT NULL,
    'company_id', v_company_id,
    'contact_id', v_contact_id
  );
END;
$_$;

-- ALTER FUNCTION "public"."migrate_deal_entities"("deal_record" "record") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."migrate_existing_list_configs"() RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  r RECORD;
BEGIN
  FOR r IN 
    SELECT 
      user_id,
      selected_list_id,
      selected_list_title
    FROM google_tasks_sync_status
    WHERE selected_list_id IS NOT NULL
  LOOP
    INSERT INTO google_tasks_list_configs (
      user_id,
      google_list_id,
      list_title,
      is_primary,
      sync_direction,
      priority_filter,
      auto_create_in_list
    ) VALUES (
      r.user_id,
      r.selected_list_id,
      r.selected_list_title,
      true,
      'bidirectional',
      '{}',
      true
    )
    ON CONFLICT (user_id, google_list_id) DO NOTHING;
  END LOOP;
END;
$$;

-- ALTER FUNCTION "public"."migrate_existing_list_configs"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."normalize_org_name"("raw_name" "text") RETURNS "text"
    LANGUAGE "plpgsql" IMMUTABLE
    AS $$
BEGIN
  -- Trim whitespace
  raw_name := TRIM(raw_name);
  
  -- Return empty string if input is null or empty
  IF raw_name IS NULL OR LENGTH(raw_name) = 0 THEN
    RETURN '';
  END IF;
  
  -- Convert to lowercase for comparison, but return properly capitalized
  -- Remove extra spaces
  raw_name := regexp_replace(raw_name, '\s+', ' ', 'g');
  
  -- Capitalize first letter of each word
  raw_name := INITCAP(raw_name);
  
  RETURN raw_name;
END;
$$;

-- ALTER FUNCTION "public"."normalize_org_name"("raw_name" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."normalize_org_name"("raw_name" "text") IS 'Normalizes organization names by trimming whitespace, removing extra spaces, and capitalizing properly.';

CREATE OR REPLACE FUNCTION "public"."notify_api_monitor_improvements"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  supabase_url TEXT;
  service_role_key TEXT;
BEGIN
  -- Get Supabase configuration from environment
  supabase_url := current_setting('app.supabase_url', true);
  service_role_key := current_setting('app.supabase_service_role_key', true);

  -- If not configured, log warning and exit
  IF supabase_url IS NULL OR service_role_key IS NULL THEN
    RAISE WARNING 'Supabase configuration not set for API monitor notifications';
    RETURN;
  END IF;

  -- Call the edge function using pg_net (Supabase's async HTTP)
  BEGIN
    PERFORM net.http_post(
      url := supabase_url || '/functions/v1/api-monitor-notify',
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || service_role_key
      ),
      body := '{}'::jsonb
    );

    RAISE NOTICE 'API Monitor notification check triggered';
  EXCEPTION WHEN OTHERS THEN
    RAISE WARNING 'Failed to invoke API monitor notification Edge Function: %', SQLERRM;
  END;
END;
$$;

-- ALTER FUNCTION "public"."notify_api_monitor_improvements"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."notify_api_monitor_improvements"() IS 'Triggers API monitor notification Edge Function to notify platform admins of high-priority API improvements';

CREATE OR REPLACE FUNCTION "public"."notify_overdue_tasks"() RETURNS json
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  task_record RECORD;
  notification_count INTEGER := 0;
  notification_title TEXT;
  notification_message TEXT;
  days_overdue INTEGER;
  max_overdue_window_days INTEGER := 30;
BEGIN
  FOR task_record IN
    SELECT
      t.id,
      t.title,
      t.assigned_to,
      t.due_date,
      t.priority,
      t.meeting_action_item_id,
      m.title as meeting_title,
      EXTRACT(DAY FROM NOW() - t.due_date)::INTEGER as days_overdue
    FROM tasks t
    LEFT JOIN meeting_action_items mai ON mai.id = t.meeting_action_item_id
    LEFT JOIN meetings m ON m.id = mai.meeting_id
    WHERE
      t.completed = FALSE
      AND t.status NOT IN ('completed', 'cancelled')
      AND t.due_date IS NOT NULL
      AND t.due_date < NOW()
      -- Guardrail: ignore tasks that are *way* overdue (likely bad data / wrong year)
      AND t.due_date >= NOW() - make_interval(days => max_overdue_window_days)
      -- Guardrail: skip tasks that were recently repaired (avoid immediate "overdue" spam)
      AND NOT (
        COALESCE(t.metadata, '{}'::jsonb) ? 'due_date_repair'
        AND (t.metadata->'due_date_repair'->>'repaired_at')::timestamptz > NOW() - INTERVAL '24 hours'
      )
      -- Only notify once per day per task
      AND NOT EXISTS (
        SELECT 1 FROM notifications n
        WHERE n.entity_id = t.id
          AND n.entity_type = 'task'
          AND n.title LIKE 'Task Overdue%'
          AND n.created_at > NOW() - INTERVAL '23 hours'
      )
  LOOP
    days_overdue := task_record.days_overdue;

    notification_title := 'Task Overdue';
    notification_message := CONCAT(
      'Your task "', task_record.title, '" is ',
      CASE
        WHEN days_overdue = 0 THEN 'overdue (was due today)'
        WHEN days_overdue = 1 THEN '1 day overdue'
        ELSE CONCAT(days_overdue, ' days overdue')
      END,
      '.',
      CASE
        WHEN task_record.meeting_title IS NOT NULL
        THEN CONCAT(' From meeting: ', task_record.meeting_title)
        ELSE ''
      END
    );

    PERFORM create_task_notification(
      task_record.assigned_to,
      task_record.id,
      notification_title,
      notification_message,
      'error',
      CONCAT('/crm/tasks?task_id=', task_record.id)
    );

    notification_count := notification_count + 1;

    -- Keep task status aligned (non-blocking)
    UPDATE tasks
    SET status = 'overdue', updated_at = NOW()
    WHERE id = task_record.id AND status != 'overdue';
  END LOOP;

  RETURN json_build_object(
    'success', true,
    'notifications_sent', notification_count,
    'guardrails', json_build_object(
      'max_overdue_window_days', max_overdue_window_days,
      'skip_recent_repairs_hours', 24
    ),
    'timestamp', NOW()
  );
END;
$$;

-- ALTER FUNCTION "public"."notify_overdue_tasks"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."notify_overdue_tasks"() IS 'Overdue task notifications with guardrails (bounded overdue window + skip recent due_date repairs) to prevent flood from bad due_date data.';

CREATE OR REPLACE FUNCTION "public"."notify_roadmap_suggestion"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  webhook_url TEXT;
  payload JSONB;
BEGIN
  -- Get webhook URL from app_settings (with proper schema qualification)
  SELECT value INTO webhook_url
  FROM public.app_settings
  WHERE key = 'roadmap_webhook_url';

  -- If no webhook configured, skip notification
  IF webhook_url IS NULL OR webhook_url = '' THEN
    RETURN NEW;
  END IF;

  -- Build notification payload
  payload := jsonb_build_object(
    'event', TG_OP,
    'table', TG_TABLE_NAME,
    'schema', TG_TABLE_SCHEMA,
    'record', to_jsonb(NEW),
    'timestamp', now()
  );

  -- Send async HTTP request via pg_net
  -- Note: This requires pg_net extension to be enabled
  BEGIN
    PERFORM net.http_post(
      url := webhook_url,
      headers := jsonb_build_object(
        'Content-Type', 'application/json'
      ),
      body := payload::text
    );
  EXCEPTION WHEN OTHERS THEN
    -- Log error but don't fail the transaction
    RAISE WARNING 'Failed to send roadmap webhook: %', SQLERRM;
  END;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."notify_roadmap_suggestion"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."notify_skill_update"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Mark all organization skills using this platform skill for recompilation
  UPDATE organization_skills
  SET last_compiled_at = NULL
  WHERE skill_id = NEW.skill_key;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."notify_skill_update"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."notify_skill_update"() IS 'Trigger function that marks organization skills for recompilation when platform skill changes';

CREATE OR REPLACE FUNCTION "public"."notify_task_from_meeting"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  meeting_title TEXT;
  notification_title TEXT;
  notification_message TEXT;
  notification_id UUID;
BEGIN
  -- Only notify if task was created from a meeting action item
  IF NEW.meeting_action_item_id IS NULL THEN
    RETURN NEW;
  END IF;

  -- Get meeting title
  SELECT m.title INTO meeting_title
  FROM meetings m
  JOIN meeting_action_items mai ON mai.meeting_id = m.id
  WHERE mai.id = NEW.meeting_action_item_id;

  -- Build notification
  notification_title := 'New Action Item from Meeting';
  notification_message := CONCAT(
    'A new task "', NEW.title, '" has been assigned to you from the meeting "',
    COALESCE(meeting_title, 'Unknown Meeting'), '".',
    CASE
      WHEN NEW.due_date IS NOT NULL THEN CONCAT(' Due: ', TO_CHAR(NEW.due_date, 'Mon DD, YYYY'))
      ELSE ''
    END
  );

  -- Create notification (may be NULL if rate limited)
  SELECT create_task_notification(
    NEW.assigned_to,
    NEW.id,
    notification_title,
    notification_message,
    CASE
      WHEN NEW.priority = 'urgent' THEN 'error'
      WHEN NEW.priority = 'high' THEN 'warning'
      ELSE 'info'
    END,
    CONCAT('/crm/tasks?task_id=', NEW.id)
  ) INTO notification_id;

  -- Log if notification was rate limited
  IF notification_id IS NULL THEN
    RAISE NOTICE 'Meeting task notification rate limited for user % task %',
      NEW.assigned_to, NEW.id;
  END IF;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."notify_task_from_meeting"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."notify_task_from_meeting"() IS 'Trigger function: Notify user when task is created from meeting action item. RATE LIMITED: May skip notification if user rate limit exceeded.';

-- ALTER FUNCTION "public"."notify_task_reassignment"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."notify_task_reassignment"() IS 'Trigger function: Notify user when task is reassigned to them. RATE LIMITED: May skip notification if user rate limit exceeded.';

CREATE OR REPLACE FUNCTION "public"."notify_upcoming_task_deadlines"() RETURNS json
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  task_record RECORD;
  notification_count INTEGER := 0;
  notification_title TEXT;
  notification_message TEXT;
BEGIN
  -- Find all tasks due tomorrow (between 24 and 48 hours from now)
  FOR task_record IN
    SELECT
      t.id,
      t.title,
      t.assigned_to,
      t.due_date,
      t.priority,
      t.meeting_action_item_id,
      m.title as meeting_title
    FROM tasks t
    LEFT JOIN meeting_action_items mai ON mai.id = t.meeting_action_item_id
    LEFT JOIN meetings m ON m.id = mai.meeting_id
    WHERE
      t.completed = FALSE
      AND t.status NOT IN ('completed', 'cancelled')
      AND t.due_date IS NOT NULL
      AND t.due_date BETWEEN NOW() + INTERVAL '23 hours' AND NOW() + INTERVAL '25 hours'
      -- Don't notify if already notified in the last 12 hours
      AND NOT EXISTS (
        SELECT 1 FROM notifications n
        WHERE n.entity_id = t.id
          AND n.entity_type = 'task'
          AND n.title LIKE 'Task Due Tomorrow%'
          AND n.created_at > NOW() - INTERVAL '12 hours'
      )
  LOOP
    -- Build notification
    notification_title := 'Task Due Tomorrow';
    notification_message := CONCAT(
      'Your task "', task_record.title, '" is due tomorrow (',
      TO_CHAR(task_record.due_date, 'Mon DD, YYYY at HH12:MI AM'), ').',
      CASE
        WHEN task_record.meeting_title IS NOT NULL
        THEN CONCAT(' From meeting: ', task_record.meeting_title)
        ELSE ''
      END
    );

    -- Create notification
    PERFORM create_task_notification(
      task_record.assigned_to,
      task_record.id,
      notification_title,
      notification_message,
      CASE
        WHEN task_record.priority IN ('urgent', 'high') THEN 'warning'
        ELSE 'info'
      END,
      CONCAT('/crm/tasks?task_id=', task_record.id)
    );

    notification_count := notification_count + 1;
  END LOOP;

  RETURN json_build_object(
    'success', true,
    'notifications_sent', notification_count,
    'timestamp', NOW()
  );
END;
$$;

-- ALTER FUNCTION "public"."notify_upcoming_task_deadlines"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."notify_upcoming_task_deadlines"() IS 'Scheduled function: Send notifications for tasks due in 24 hours';

-- ALTER FUNCTION "public"."notify_waitlist_signup"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."notify_waitlist_signup"() IS 'Sends Slack notification when a new user signs up for the waitlist';

-- ALTER FUNCTION "public"."notify_waitlist_update"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."notify_waitlist_update"() IS 'Sends Slack notifications for referral milestones (3, 5, 10) and tier upgrades (VIP, Priority)';

CREATE OR REPLACE FUNCTION "public"."on_user_activity_update_segment"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
DECLARE
  v_current_segment TEXT;
BEGIN
  -- Get current segment
  SELECT user_segment INTO v_current_segment
  FROM user_engagement_metrics
  WHERE user_id = NEW.user_id;

  -- If user was at_risk, dormant, or churned and now has activity, reset
  IF v_current_segment IN ('at_risk', 'dormant', 'churned') THEN
    UPDATE user_engagement_metrics
    SET
      previous_segment = v_current_segment,
      segment_changed_at = NOW(),
      reengagement_attempts = 0,
      reengagement_cooldown_until = NULL,
      last_app_active_at = CASE WHEN NEW.event_source = 'app' THEN NOW() ELSE last_app_active_at END,
      last_slack_active_at = CASE WHEN NEW.event_source = 'slack' THEN NOW() ELSE last_slack_active_at END,
      updated_at = NOW()
    WHERE user_id = NEW.user_id;
  END IF;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."on_user_activity_update_segment"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."org_has_feature"("p_org_id" "uuid", "p_feature_key" "text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  v_plan_feature BOOLEAN;
  v_override_enabled BOOLEAN;
BEGIN
  -- First check for explicit override
  SELECT is_enabled INTO v_override_enabled
  FROM organization_feature_flags
  WHERE org_id = p_org_id
  AND feature_key = p_feature_key
  AND (expires_at IS NULL OR expires_at > NOW());

  IF v_override_enabled IS NOT NULL THEN
    RETURN v_override_enabled;
  END IF;

  -- Fall back to plan features
  SELECT (sp.features->p_feature_key)::boolean INTO v_plan_feature
  FROM organization_subscriptions os
  JOIN subscription_plans sp ON sp.id = os.plan_id
  WHERE os.org_id = p_org_id
  AND os.status IN ('active', 'trialing');

  RETURN COALESCE(v_plan_feature, false);
END;
$$;

-- ALTER FUNCTION "public"."org_has_feature"("p_org_id" "uuid", "p_feature_key" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."org_has_feature"("p_org_id" "uuid", "p_feature_key" "text") IS 'Checks if an org has access to a specific feature';

CREATE OR REPLACE FUNCTION "public"."prevent_task_circular_reference"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
    current_parent_id UUID;
    check_id UUID;
BEGIN
    -- Only check if parent_task_id is being set
    IF NEW.parent_task_id IS NULL THEN
        RETURN NEW;
    END IF;
    
    -- Start checking from the proposed parent
    current_parent_id := NEW.parent_task_id;
    
    -- Traverse up the hierarchy to check for circular reference
    WHILE current_parent_id IS NOT NULL LOOP
        -- If we find the current task ID in the parent chain, it's circular
        IF current_parent_id = NEW.id THEN
            RAISE EXCEPTION 'Circular reference detected: Task cannot be a subtask of itself or its descendants';
        END IF;
        
        -- Get the parent of the current parent
        SELECT parent_task_id INTO check_id 
        FROM tasks 
        WHERE id = current_parent_id;
        
        current_parent_id := check_id;
    END LOOP;
    
    RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."prevent_task_circular_reference"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."process_hitl_action"("p_approval_id" "uuid", "p_action" "text", "p_actioned_by" "uuid", "p_response" "jsonb" DEFAULT NULL::"jsonb", "p_edited_content" "jsonb" DEFAULT NULL::"jsonb") RETURNS "public"."hitl_pending_approvals"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_approval hitl_pending_approvals;
BEGIN
  -- Validate action
  IF p_action NOT IN ('approved', 'rejected', 'edited', 'cancelled') THEN
    RAISE EXCEPTION 'Invalid action: %', p_action;
  END IF;

  UPDATE hitl_pending_approvals
  SET
    status = p_action,
    actioned_by = p_actioned_by,
    actioned_at = now(),
    response = p_response,
    edited_content = COALESCE(p_edited_content, edited_content)
  WHERE id = p_approval_id
    AND status = 'pending'
  RETURNING * INTO v_approval;

  IF v_approval IS NULL THEN
    -- Check if it exists but is not pending
    SELECT * INTO v_approval FROM hitl_pending_approvals WHERE id = p_approval_id;
    IF v_approval IS NOT NULL THEN
      RAISE EXCEPTION 'Approval is not pending (current status: %)', v_approval.status;
    ELSE
      RAISE EXCEPTION 'Approval not found: %', p_approval_id;
    END IF;
  END IF;

  RETURN v_approval;
END;
$$;

-- ALTER FUNCTION "public"."process_hitl_action"("p_approval_id" "uuid", "p_action" "text", "p_actioned_by" "uuid", "p_response" "jsonb", "p_edited_content" "jsonb") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."queue_call_for_indexing"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  IF (OLD.transcript_text IS NULL OR OLD.transcript_text = '')
     AND (NEW.transcript_text IS NOT NULL AND NEW.transcript_text != '')
     AND LENGTH(NEW.transcript_text) > 100 THEN
    INSERT INTO call_index_queue (call_id, org_id, owner_user_id, priority)
    VALUES (NEW.id, NEW.org_id, NEW.owner_user_id, 0)
    ON CONFLICT (call_id) DO UPDATE SET
      attempts = 0,
      error_message = NULL,
      created_at = NOW();
  END IF;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."queue_call_for_indexing"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."queue_meeting_for_indexing"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Only queue when transcript goes from NULL/empty to having content
  IF (OLD.transcript_text IS NULL OR OLD.transcript_text = '')
     AND (NEW.transcript_text IS NOT NULL AND NEW.transcript_text != '')
     AND LENGTH(NEW.transcript_text) > 100 THEN

    INSERT INTO meeting_index_queue (meeting_id, user_id, priority)
    VALUES (NEW.id, NEW.owner_user_id, 0)
    ON CONFLICT (meeting_id) DO UPDATE SET
      attempts = 0,
      error_message = NULL,
      created_at = NOW();

  END IF;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."queue_meeting_for_indexing"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."queue_meeting_for_indexing"() IS 'Auto-queues meetings for File Search indexing when transcript is populated';

CREATE OR REPLACE FUNCTION "public"."queue_notification"("p_user_id" "uuid", "p_org_id" "uuid", "p_notification_type" "text", "p_channel" "text", "p_payload" "jsonb", "p_priority" "text" DEFAULT 'normal'::"text", "p_scheduled_for" timestamp with time zone DEFAULT "now"(), "p_send_deadline" timestamp with time zone DEFAULT NULL::timestamp with time zone, "p_dedupe_key" "text" DEFAULT NULL::"text", "p_dedupe_window_minutes" integer DEFAULT 60, "p_related_entity_type" "text" DEFAULT NULL::"text", "p_related_entity_id" "uuid" DEFAULT NULL::"uuid", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_queue_id UUID;
  v_existing_id UUID;
  v_user_metrics RECORD;
  v_optimal_time TIMESTAMPTZ;
  v_confidence NUMERIC;
BEGIN
  -- Check for duplicate if dedupe_key provided
  IF p_dedupe_key IS NOT NULL THEN
    SELECT id INTO v_existing_id
    FROM notification_queue
    WHERE user_id = p_user_id
      AND dedupe_key = p_dedupe_key
      AND status IN ('pending', 'scheduled')
      AND created_at > NOW() - (p_dedupe_window_minutes || ' minutes')::INTERVAL
    LIMIT 1;

    IF v_existing_id IS NOT NULL THEN
      -- Update existing notification instead of creating duplicate
      UPDATE notification_queue
      SET
        payload = p_payload,
        priority = CASE
          WHEN p_priority = 'urgent' THEN p_priority
          WHEN p_priority = 'high' AND priority != 'urgent' THEN p_priority
          ELSE priority
        END,
        metadata = metadata || p_metadata
      WHERE id = v_existing_id;

      RETURN v_existing_id;
    END IF;
  END IF;

  -- Get user engagement metrics for optimal timing
  SELECT
    peak_activity_hour,
    notification_fatigue_level,
    preferred_notification_frequency,
    typical_active_hours
  INTO v_user_metrics
  FROM user_engagement_metrics
  WHERE user_id = p_user_id;

  -- Calculate optimal send time (simplified - full logic in Edge Function)
  IF v_user_metrics.peak_activity_hour IS NOT NULL AND p_priority NOT IN ('urgent', 'high') THEN
    -- Schedule for peak activity hour if possible
    v_optimal_time := date_trunc('hour', p_scheduled_for) +
      (v_user_metrics.peak_activity_hour || ' hours')::INTERVAL;

    -- If peak hour is in the past today, schedule for tomorrow
    IF v_optimal_time < NOW() THEN
      v_optimal_time := v_optimal_time + INTERVAL '1 day';
    END IF;

    -- Ensure it's after scheduled_for
    IF v_optimal_time < p_scheduled_for THEN
      v_optimal_time := p_scheduled_for;
    END IF;

    v_confidence := 0.6;
  ELSE
    v_optimal_time := p_scheduled_for;
    v_confidence := 0.3;
  END IF;

  -- Insert into queue
  INSERT INTO notification_queue (
    user_id, org_id, notification_type, channel, payload, priority,
    scheduled_for, optimal_send_time, optimal_time_confidence, send_deadline,
    dedupe_key, dedupe_window_minutes,
    related_entity_type, related_entity_id, metadata
  )
  VALUES (
    p_user_id, p_org_id, p_notification_type, p_channel, p_payload, p_priority,
    p_scheduled_for, v_optimal_time, v_confidence, p_send_deadline,
    p_dedupe_key, p_dedupe_window_minutes,
    p_related_entity_type, p_related_entity_id, p_metadata
  )
  RETURNING id INTO v_queue_id;

  RETURN v_queue_id;
END;
$$;

-- ALTER FUNCTION "public"."queue_notification"("p_user_id" "uuid", "p_org_id" "uuid", "p_notification_type" "text", "p_channel" "text", "p_payload" "jsonb", "p_priority" "text", "p_scheduled_for" timestamp with time zone, "p_send_deadline" timestamp with time zone, "p_dedupe_key" "text", "p_dedupe_window_minutes" integer, "p_related_entity_type" "text", "p_related_entity_id" "uuid", "p_metadata" "jsonb") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."queue_notification"("p_user_id" "uuid", "p_org_id" "uuid", "p_notification_type" "text", "p_channel" "text", "p_payload" "jsonb", "p_priority" "text", "p_scheduled_for" timestamp with time zone, "p_send_deadline" timestamp with time zone, "p_dedupe_key" "text", "p_dedupe_window_minutes" integer, "p_related_entity_type" "text", "p_related_entity_id" "uuid", "p_metadata" "jsonb") IS 'Add a notification to the queue with optimal timing calculation';

CREATE OR REPLACE FUNCTION "public"."queue_topics_for_aggregation"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  topic_count INTEGER;
  i INTEGER;
BEGIN
  -- Get the number of topics in the JSONB array
  topic_count := jsonb_array_length(NEW.topics);

  -- Queue each topic for aggregation
  FOR i IN 0..(topic_count - 1) LOOP
    INSERT INTO topic_aggregation_queue (user_id, meeting_id, topic_index, status)
    VALUES (NEW.user_id, NEW.meeting_id, i, 'pending')
    ON CONFLICT (user_id, meeting_id, topic_index) DO NOTHING;
  END LOOP;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."queue_topics_for_aggregation"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."reanalyze_action_items_with_ai"("p_meeting_id" "uuid" DEFAULT NULL::"uuid") RETURNS json
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  action_item_record RECORD;
  analyzed_count INTEGER := 0;
  failed_count INTEGER := 0;
  result JSON;
BEGIN
  -- Loop through action items
  FOR action_item_record IN
    SELECT id, title
    FROM meeting_action_items
    WHERE (p_meeting_id IS NULL OR meeting_id = p_meeting_id)
      AND task_id IS NOT NULL
      AND ai_analyzed_at IS NULL
    LIMIT 50 -- Process in batches
  LOOP
    BEGIN
      -- Analyze with AI
      PERFORM analyze_action_item_with_ai(action_item_record.id);
      analyzed_count := analyzed_count + 1;

    EXCEPTION WHEN OTHERS THEN
      failed_count := failed_count + 1;
      RAISE WARNING 'Failed to analyze action item %: %', action_item_record.id, SQLERRM;
    END;
  END LOOP;

  RETURN json_build_object(
    'analyzed', analyzed_count,
    'failed', failed_count,
    'meeting_id', p_meeting_id
  );
END;
$$;

-- ALTER FUNCTION "public"."reanalyze_action_items_with_ai"("p_meeting_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."reanalyze_action_items_with_ai"("p_meeting_id" "uuid") IS 'Manually re-analyze existing action items with AI (max 50 per call)';

CREATE OR REPLACE FUNCTION "public"."reconcile_billing_subscriptions"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  supabase_url TEXT;
  service_role_key TEXT;
BEGIN
  -- Get Supabase configuration from environment/system config
  -- Try system_config first, then fallback to app settings
  BEGIN
    SELECT value INTO supabase_url FROM system_config WHERE key = 'supabase_url' LIMIT 1;
    SELECT value INTO service_role_key FROM system_config WHERE key = 'service_role_key' LIMIT 1;
  EXCEPTION WHEN OTHERS THEN
    -- Fallback to app settings if system_config doesn't exist
    supabase_url := current_setting('app.supabase_url', true);
    service_role_key := current_setting('app.supabase_service_role_key', true);
  END;

  -- If not configured, log warning and exit
  IF supabase_url IS NULL OR service_role_key IS NULL THEN
    RAISE WARNING 'Supabase configuration not set for billing reconciliation';
    RETURN;
  END IF;

  -- Call the reconciliation edge function using pg_net
  BEGIN
    PERFORM net.http_post(
      url := supabase_url || '/functions/v1/reconcile-billing',
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || service_role_key
      ),
      body := '{}'::jsonb
    );

    RAISE NOTICE 'Billing reconciliation triggered';
  EXCEPTION WHEN OTHERS THEN
    RAISE WARNING 'Failed to invoke billing reconciliation Edge Function: %', SQLERRM;
  END;
END;
$$;

-- ALTER FUNCTION "public"."reconcile_billing_subscriptions"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."reconcile_billing_subscriptions"() IS 'Triggers daily reconciliation of Stripe subscriptions with database state';

CREATE OR REPLACE FUNCTION "public"."record_activation_event"("p_user_id" "uuid", "p_event_type" "text", "p_event_data" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_event_id UUID;
  v_org_id UUID;
BEGIN
  -- Get user's org_id
  SELECT org_id INTO v_org_id
  FROM organization_memberships
  WHERE user_id = p_user_id
  LIMIT 1;

  -- Insert the event
  INSERT INTO user_activation_events (user_id, org_id, event_type, event_data)
  VALUES (p_user_id, v_org_id, p_event_type, p_event_data)
  RETURNING id INTO v_event_id;

  -- Update onboarding progress based on event type
  CASE p_event_type
    WHEN 'fathom_connected' THEN
      UPDATE user_onboarding_progress
      SET fathom_connected = true, updated_at = NOW()
      WHERE user_id = p_user_id;
      
    WHEN 'first_meeting_synced' THEN
      UPDATE user_onboarding_progress
      SET first_meeting_synced = true, updated_at = NOW()
      WHERE user_id = p_user_id;
      
    WHEN 'first_summary_viewed' THEN
      UPDATE user_onboarding_progress
      SET 
        first_summary_viewed = true, 
        first_summary_viewed_at = NOW(),
        updated_at = NOW()
      WHERE user_id = p_user_id
      AND first_summary_viewed = false; -- Only update if not already set
      
    WHEN 'first_proposal_generated' THEN
      UPDATE user_onboarding_progress
      SET first_proposal_generated = true, updated_at = NOW()
      WHERE user_id = p_user_id;
      
    ELSE
      -- No special handling needed
      NULL;
  END CASE;

  -- Check if user has completed full activation (all key milestones)
  UPDATE user_onboarding_progress
  SET 
    activation_completed_at = NOW(),
    updated_at = NOW()
  WHERE user_id = p_user_id
  AND activation_completed_at IS NULL
  AND fathom_connected = true
  AND first_meeting_synced = true
  AND first_summary_viewed = true;

  RETURN v_event_id;
END;
$$;

-- ALTER FUNCTION "public"."record_activation_event"("p_user_id" "uuid", "p_event_type" "text", "p_event_data" "jsonb") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."record_activation_event"("p_user_id" "uuid", "p_event_type" "text", "p_event_data" "jsonb") IS 'Record an activation event and update onboarding progress accordingly';

CREATE OR REPLACE FUNCTION "public"."record_email_send"("p_user_id" "uuid", "p_journey_id" "uuid", "p_email_type" "text", "p_to_email" "text", "p_encharge_message_id" "text" DEFAULT NULL::"text", "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_send_id UUID;
BEGIN
  INSERT INTO email_sends (
    user_id,
    journey_id,
    email_type,
    to_email,
    encharge_message_id,
    status,
    metadata
  )
  VALUES (
    p_user_id,
    p_journey_id,
    p_email_type,
    p_to_email,
    p_encharge_message_id,
    'sent',
    p_metadata
  )
  RETURNING id INTO v_send_id;

  RETURN v_send_id;
END;
$$;

-- ALTER FUNCTION "public"."record_email_send"("p_user_id" "uuid", "p_journey_id" "uuid", "p_email_type" "text", "p_to_email" "text", "p_encharge_message_id" "text", "p_metadata" "jsonb") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."record_email_send"("p_user_id" "uuid", "p_journey_id" "uuid", "p_email_type" "text", "p_to_email" "text", "p_encharge_message_id" "text", "p_metadata" "jsonb") IS 'Record an email send in the database';

CREATE OR REPLACE FUNCTION "public"."record_notification_interaction"("p_user_id" "uuid", "p_org_id" "uuid", "p_notification_type" "text", "p_delivered_via" "text", "p_slack_notification_sent_id" "uuid" DEFAULT NULL::"uuid", "p_notification_id" "uuid" DEFAULT NULL::"uuid") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_interaction_id UUID;
  v_now TIMESTAMPTZ := NOW();
  v_user_active BOOLEAN;
BEGIN
  -- Check if user was recently active (within last 5 minutes)
  SELECT EXISTS (
    SELECT 1 FROM user_activity_events
    WHERE user_id = p_user_id
      AND event_at > v_now - INTERVAL '5 minutes'
  ) INTO v_user_active;

  INSERT INTO notification_interactions (
    user_id, org_id, notification_type, delivered_via,
    slack_notification_sent_id, notification_id,
    delivered_at, user_was_active, hour_of_day, day_of_week
  )
  VALUES (
    p_user_id, p_org_id, p_notification_type, p_delivered_via,
    p_slack_notification_sent_id, p_notification_id,
    v_now, v_user_active,
    EXTRACT(HOUR FROM v_now)::INTEGER,
    EXTRACT(DOW FROM v_now)::INTEGER
  )
  RETURNING id INTO v_interaction_id;

  -- Increment notification counter for feedback timing
  UPDATE user_engagement_metrics
  SET notifications_since_last_feedback = notifications_since_last_feedback + 1
  WHERE user_id = p_user_id;

  RETURN v_interaction_id;
END;
$$;

-- ALTER FUNCTION "public"."record_notification_interaction"("p_user_id" "uuid", "p_org_id" "uuid", "p_notification_type" "text", "p_delivered_via" "text", "p_slack_notification_sent_id" "uuid", "p_notification_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."record_notification_interaction"("p_user_id" "uuid", "p_org_id" "uuid", "p_notification_type" "text", "p_delivered_via" "text", "p_slack_notification_sent_id" "uuid", "p_notification_id" "uuid") IS 'Records when a notification is delivered to a user';

CREATE OR REPLACE FUNCTION "public"."record_notification_preference_feedback"("p_user_id" "uuid", "p_feedback_value" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_new_frequency TEXT;
  v_fatigue_adjustment INTEGER;
BEGIN
  -- Determine new frequency and fatigue adjustment
  CASE p_feedback_value
    WHEN 'more' THEN
      v_new_frequency := 'high';
      v_fatigue_adjustment := -20;
    WHEN 'less' THEN
      v_new_frequency := 'low';
      v_fatigue_adjustment := 30;
    ELSE  -- 'just_right'
      v_new_frequency := NULL;  -- Keep current
      v_fatigue_adjustment := 0;
  END CASE;

  -- Update user preferences
  UPDATE user_engagement_metrics
  SET
    preferred_notification_frequency = COALESCE(v_new_frequency, preferred_notification_frequency),
    notification_fatigue_level = GREATEST(0, LEAST(100, COALESCE(notification_fatigue_level, 0) + v_fatigue_adjustment)),
    last_feedback_requested_at = NOW(),
    notifications_since_last_feedback = 0,
    updated_at = NOW()
  WHERE user_id = p_user_id;
END;
$$;

-- ALTER FUNCTION "public"."record_notification_preference_feedback"("p_user_id" "uuid", "p_feedback_value" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."record_notification_preference_feedback"("p_user_id" "uuid", "p_feedback_value" "text") IS 'Record feedback and update user preferences';

CREATE OR REPLACE FUNCTION "public"."record_reengagement_attempt"("p_user_id" "uuid", "p_org_id" "uuid", "p_reengagement_type" "text", "p_channel" "text", "p_trigger_type" "text" DEFAULT NULL::"text", "p_trigger_entity_type" "text" DEFAULT NULL::"text", "p_trigger_entity_id" "uuid" DEFAULT NULL::"uuid", "p_trigger_context" "jsonb" DEFAULT NULL::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_log_id UUID;
  v_segment TEXT;
  v_cooldown_days INTEGER;
BEGIN
  -- Get current segment
  SELECT user_segment INTO v_segment
  FROM user_engagement_metrics
  WHERE user_id = p_user_id;

  -- Calculate cooldown based on segment
  v_cooldown_days := CASE v_segment
    WHEN 'at_risk' THEN 7
    WHEN 'dormant' THEN 5
    WHEN 'churned' THEN 14
    ELSE 7
  END;

  -- Insert log entry
  INSERT INTO reengagement_log (
    user_id, org_id, segment_at_send, reengagement_type, channel,
    trigger_type, trigger_entity_type, trigger_entity_id, trigger_context
  ) VALUES (
    p_user_id, p_org_id, v_segment, p_reengagement_type, p_channel,
    p_trigger_type, p_trigger_entity_type, p_trigger_entity_id, p_trigger_context
  )
  RETURNING id INTO v_log_id;

  -- Update user metrics
  UPDATE user_engagement_metrics
  SET
    reengagement_attempts = COALESCE(reengagement_attempts, 0) + 1,
    last_reengagement_at = NOW(),
    last_reengagement_type = p_reengagement_type,
    reengagement_cooldown_until = NOW() + (v_cooldown_days || ' days')::INTERVAL,
    updated_at = NOW()
  WHERE user_id = p_user_id;

  RETURN v_log_id;
END;
$$;

-- ALTER FUNCTION "public"."record_reengagement_attempt"("p_user_id" "uuid", "p_org_id" "uuid", "p_reengagement_type" "text", "p_channel" "text", "p_trigger_type" "text", "p_trigger_entity_type" "text", "p_trigger_entity_id" "uuid", "p_trigger_context" "jsonb") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."record_reengagement_attempt"("p_user_id" "uuid", "p_org_id" "uuid", "p_reengagement_type" "text", "p_channel" "text", "p_trigger_type" "text", "p_trigger_entity_type" "text", "p_trigger_entity_id" "uuid", "p_trigger_context" "jsonb") IS 'Record a re-engagement attempt and set cooldown';

CREATE OR REPLACE FUNCTION "public"."record_reengagement_response"("p_log_id" "uuid", "p_action" "text", "p_action_detail" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE reengagement_log
  SET
    opened_at = CASE WHEN p_action = 'opened' AND opened_at IS NULL THEN NOW() ELSE opened_at END,
    clicked_at = CASE WHEN p_action = 'clicked' AND clicked_at IS NULL THEN NOW() ELSE clicked_at END,
    returned_to_app = CASE WHEN p_action = 'returned' THEN TRUE ELSE returned_to_app END,
    returned_at = CASE WHEN p_action = 'returned' AND returned_at IS NULL THEN NOW() ELSE returned_at END,
    action_taken = COALESCE(action_taken, p_action_detail),
    outcome = CASE
      WHEN p_action = 'returned' THEN 'success'
      WHEN p_action = 'unsubscribed' THEN 'unsubscribed'
      ELSE outcome
    END
  WHERE id = p_log_id;

  -- If user returned, reset their re-engagement attempts
  IF p_action = 'returned' THEN
    UPDATE user_engagement_metrics uem
    SET
      reengagement_attempts = 0,
      reengagement_cooldown_until = NULL,
      updated_at = NOW()
    FROM reengagement_log rl
    WHERE rl.id = p_log_id
      AND uem.user_id = rl.user_id;
  END IF;
END;
$$;

-- ALTER FUNCTION "public"."record_reengagement_response"("p_log_id" "uuid", "p_action" "text", "p_action_detail" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."record_reengagement_response"("p_log_id" "uuid", "p_action" "text", "p_action_detail" "text") IS 'Record user response to re-engagement (open, click, return)';

CREATE OR REPLACE FUNCTION "public"."record_usage_event"("p_org_id" "uuid", "p_user_id" "uuid", "p_event_type" "text", "p_event_subtype" "text" DEFAULT NULL::"text", "p_quantity" integer DEFAULT 1, "p_metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  v_event_id UUID;
BEGIN
  INSERT INTO usage_events (org_id, user_id, event_type, event_subtype, quantity, metadata)
  VALUES (p_org_id, p_user_id, p_event_type, p_event_subtype, p_quantity, p_metadata)
  RETURNING id INTO v_event_id;

  RETURN v_event_id;
END;
$$;

-- ALTER FUNCTION "public"."record_usage_event"("p_org_id" "uuid", "p_user_id" "uuid", "p_event_type" "text", "p_event_subtype" "text", "p_quantity" integer, "p_metadata" "jsonb") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."record_usage_event"("p_org_id" "uuid", "p_user_id" "uuid", "p_event_type" "text", "p_event_subtype" "text", "p_quantity" integer, "p_metadata" "jsonb") IS 'Records a usage event for tracking';

CREATE OR REPLACE FUNCTION "public"."refresh_deal_health_scores"("p_user_id" "uuid", "p_max_age_hours" integer DEFAULT 24) RETURNS TABLE("deal_id" "uuid", "health_score" integer, "health_status" "text", "updated" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
  DECLARE
    v_stale_threshold TIMESTAMP WITH TIME ZONE;
    v_deal RECORD;
    v_existing_score RECORD;
  BEGIN
    v_stale_threshold := NOW() - (p_max_age_hours || ' hours')::INTERVAL;

    FOR v_deal IN
      SELECT d.id, ds.name as stage_name, d.created_at, d.stage_id, d.one_off_amount,
  d.monthly_amount
      FROM deals d
      INNER JOIN deal_stages ds ON d.stage_id = ds.id
      WHERE d.owner_id = p_user_id AND d.status = 'active' AND ds.name NOT IN ('Signed',
  'Lost')
    LOOP
      SELECT * INTO v_existing_score FROM deal_health_scores WHERE deal_id = v_deal.id ORDER BY
   last_calculated_at DESC LIMIT 1;

      IF v_existing_score.id IS NOT NULL AND v_existing_score.last_calculated_at >
  v_stale_threshold THEN
        RETURN QUERY SELECT v_deal.id, v_existing_score.overall_health_score,
  v_existing_score.health_status::TEXT, FALSE;
        CONTINUE;
      END IF;

      DECLARE
        v_days_in_stage INTEGER;
        v_stage_velocity_score INTEGER;
        v_overall_score INTEGER;
        v_health_status TEXT;
      BEGIN
        v_days_in_stage := EXTRACT(DAY FROM NOW() - v_deal.created_at)::INTEGER;

        CASE v_deal.stage_name
          WHEN 'SQL' THEN
            IF v_days_in_stage <= 7 THEN v_stage_velocity_score := 100;
            ELSIF v_days_in_stage <= 14 THEN v_stage_velocity_score := 75;
            ELSIF v_days_in_stage <= 30 THEN v_stage_velocity_score := 50;
            ELSE v_stage_velocity_score := 25;
            END IF;
          WHEN 'Opportunity' THEN
            IF v_days_in_stage <= 14 THEN v_stage_velocity_score := 100;
            ELSIF v_days_in_stage <= 21 THEN v_stage_velocity_score := 75;
            ELSIF v_days_in_stage <= 45 THEN v_stage_velocity_score := 50;
            ELSE v_stage_velocity_score := 25;
            END IF;
          WHEN 'Verbal' THEN
            IF v_days_in_stage <= 7 THEN v_stage_velocity_score := 100;
            ELSIF v_days_in_stage <= 14 THEN v_stage_velocity_score := 75;
            ELSIF v_days_in_stage <= 21 THEN v_stage_velocity_score := 50;
            ELSE v_stage_velocity_score := 25;
            END IF;
          ELSE
            v_stage_velocity_score := 50;
        END CASE;

        v_overall_score := v_stage_velocity_score;

        IF v_overall_score >= 70 THEN v_health_status := 'healthy';
        ELSIF v_overall_score >= 50 THEN v_health_status := 'warning';
        ELSIF v_overall_score >= 30 THEN v_health_status := 'critical';
        ELSE v_health_status := 'stalled';
        END IF;

        INSERT INTO deal_health_scores (
          deal_id, user_id, overall_health_score, health_status, stage_velocity_score,
          days_in_current_stage, sentiment_score, engagement_score, activity_score,
          response_time_score, risk_level, last_calculated_at
        ) VALUES (
          v_deal.id, p_user_id, v_overall_score, v_health_status, v_stage_velocity_score,
          v_days_in_stage, 50, 50, 50, 50,
          CASE WHEN v_overall_score >= 70 THEN 'low' WHEN v_overall_score >= 50 THEN 'medium'
               WHEN v_overall_score >= 30 THEN 'high' ELSE 'critical' END,
          NOW()
        )
        ON CONFLICT (deal_id) DO UPDATE SET
          overall_health_score = EXCLUDED.overall_health_score,
          health_status = EXCLUDED.health_status,
          stage_velocity_score = EXCLUDED.stage_velocity_score,
          days_in_current_stage = EXCLUDED.days_in_current_stage,
          risk_level = EXCLUDED.risk_level,
          last_calculated_at = NOW(),
          updated_at = NOW();

        RETURN QUERY SELECT v_deal.id, v_overall_score, v_health_status, TRUE;
      END;
    END LOOP;
    RETURN;
  END;
  $$;

-- ALTER FUNCTION "public"."refresh_deal_health_scores"("p_user_id" "uuid", "p_max_age_hours" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."refresh_deal_health_scores"("p_user_id" "uuid", "p_max_age_hours" integer) IS 'Refreshes health scores for active deals';

CREATE OR REPLACE FUNCTION "public"."refresh_meeting_aggregate_metrics"("p_org_id" "uuid", "p_period_type" "text", "p_period_start" "date") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_period_end DATE;
  v_prev_period_start DATE;
  v_metrics RECORD;
  v_prev_metrics RECORD;
BEGIN
  -- Calculate period end
  v_period_end := CASE p_period_type
    WHEN 'day' THEN p_period_start + interval '1 day' - interval '1 second'
    WHEN 'week' THEN p_period_start + interval '1 week' - interval '1 second'
    WHEN 'month' THEN (p_period_start + interval '1 month')::date - interval '1 second'
    WHEN 'quarter' THEN (p_period_start + interval '3 months')::date - interval '1 second'
  END;

  -- Calculate previous period start for comparison
  v_prev_period_start := CASE p_period_type
    WHEN 'day' THEN p_period_start - interval '1 day'
    WHEN 'week' THEN p_period_start - interval '1 week'
    WHEN 'month' THEN p_period_start - interval '1 month'
    WHEN 'quarter' THEN p_period_start - interval '3 months'
  END;

  -- Get current period metrics
  SELECT
    COUNT(DISTINCT m.id) as total_meetings,
    COUNT(DISTINCT m.id) FILTER (WHERE m.transcript_text IS NOT NULL AND m.transcript_text != '') as meetings_with_transcripts,
    COUNT(DISTINCT mc.meeting_id) as meetings_analyzed,
    COUNT(*) FILTER (WHERE m.sentiment_label = 'positive') as positive_sentiment_count,
    COUNT(*) FILTER (WHERE m.sentiment_label = 'neutral') as neutral_sentiment_count,
    COUNT(*) FILTER (WHERE m.sentiment_label = 'negative') as negative_sentiment_count,
    AVG(m.sentiment_score) as avg_sentiment_score,
    COUNT(*) FILTER (WHERE mc.outcome = 'positive') as positive_outcome_count,
    COUNT(*) FILTER (WHERE mc.outcome = 'neutral') as neutral_outcome_count,
    COUNT(*) FILTER (WHERE mc.outcome = 'negative') as negative_outcome_count,
    COUNT(*) FILTER (WHERE mc.has_forward_movement = true) as forward_movement_count,
    COUNT(*) FILTER (WHERE mc.has_proposal_request = true) as proposal_request_count,
    COUNT(*) FILTER (WHERE mc.has_demo_request = true) as demo_request_count,
    COUNT(*) FILTER (WHERE mc.has_next_steps = true) as next_steps_established_count,
    COUNT(*) FILTER (WHERE mc.has_pricing_discussion = true) as pricing_discussion_count,
    COUNT(*) FILTER (WHERE mc.has_competitor_mention = true) as competitor_mention_count,
    COUNT(*) FILTER (WHERE mc.has_timeline_discussion = true) as timeline_discussion_count,
    COUNT(*) FILTER (WHERE mc.has_budget_discussion = true) as budget_discussion_count,
    COUNT(*) FILTER (WHERE mc.has_objection = true) as objection_count,
    AVG(m.talk_time_rep_pct) as avg_rep_talk_time,
    AVG(m.talk_time_customer_pct) as avg_customer_talk_time
  INTO v_metrics
  FROM meetings m
  INNER JOIN organization_memberships om ON m.owner_user_id = om.user_id AND om.org_id = p_org_id
  LEFT JOIN meeting_classifications mc ON m.id = mc.meeting_id
  WHERE m.start_time >= p_period_start::timestamptz
    AND m.start_time < v_period_end::timestamptz;

  -- Get previous period for comparison
  SELECT
    COUNT(DISTINCT m.id) as total_meetings,
    COUNT(*) FILTER (WHERE mc.has_forward_movement = true) as forward_movement_count,
    AVG(m.sentiment_score) as avg_sentiment_score
  INTO v_prev_metrics
  FROM meetings m
  INNER JOIN organization_memberships om ON m.owner_user_id = om.user_id AND om.org_id = p_org_id
  LEFT JOIN meeting_classifications mc ON m.id = mc.meeting_id
  WHERE m.start_time >= v_prev_period_start::timestamptz
    AND m.start_time < p_period_start::timestamptz;

  -- Upsert metrics
  INSERT INTO meeting_aggregate_metrics (
    org_id, period_type, period_start, period_end,
    total_meetings, meetings_with_transcripts, meetings_analyzed,
    positive_sentiment_count, neutral_sentiment_count, negative_sentiment_count,
    avg_sentiment_score, positive_outcome_count, neutral_outcome_count, negative_outcome_count,
    forward_movement_count, proposal_request_count, demo_request_count, next_steps_established_count,
    pricing_discussion_count, competitor_mention_count, timeline_discussion_count,
    budget_discussion_count, objection_count,
    avg_rep_talk_time, avg_customer_talk_time,
    meetings_change_pct, forward_movement_change_pct, sentiment_change_pct,
    last_calculated_at
  )
  VALUES (
    p_org_id, p_period_type, p_period_start, v_period_end,
    v_metrics.total_meetings, v_metrics.meetings_with_transcripts, v_metrics.meetings_analyzed,
    v_metrics.positive_sentiment_count, v_metrics.neutral_sentiment_count, v_metrics.negative_sentiment_count,
    v_metrics.avg_sentiment_score, v_metrics.positive_outcome_count, v_metrics.neutral_outcome_count, v_metrics.negative_outcome_count,
    v_metrics.forward_movement_count, v_metrics.proposal_request_count, v_metrics.demo_request_count, v_metrics.next_steps_established_count,
    v_metrics.pricing_discussion_count, v_metrics.competitor_mention_count, v_metrics.timeline_discussion_count,
    v_metrics.budget_discussion_count, v_metrics.objection_count,
    v_metrics.avg_rep_talk_time, v_metrics.avg_customer_talk_time,
    CASE WHEN v_prev_metrics.total_meetings > 0 THEN
      ROUND(((v_metrics.total_meetings - v_prev_metrics.total_meetings)::numeric / v_prev_metrics.total_meetings) * 100, 1)
    END,
    CASE WHEN v_prev_metrics.forward_movement_count > 0 THEN
      ROUND(((v_metrics.forward_movement_count - v_prev_metrics.forward_movement_count)::numeric / v_prev_metrics.forward_movement_count) * 100, 1)
    END,
    CASE WHEN v_prev_metrics.avg_sentiment_score IS NOT NULL AND v_prev_metrics.avg_sentiment_score > 0 THEN
      ROUND(((v_metrics.avg_sentiment_score - v_prev_metrics.avg_sentiment_score) / v_prev_metrics.avg_sentiment_score) * 100, 1)
    END,
    NOW()
  )
  ON CONFLICT (org_id, period_type, period_start) DO UPDATE SET
    total_meetings = EXCLUDED.total_meetings,
    meetings_with_transcripts = EXCLUDED.meetings_with_transcripts,
    meetings_analyzed = EXCLUDED.meetings_analyzed,
    positive_sentiment_count = EXCLUDED.positive_sentiment_count,
    neutral_sentiment_count = EXCLUDED.neutral_sentiment_count,
    negative_sentiment_count = EXCLUDED.negative_sentiment_count,
    avg_sentiment_score = EXCLUDED.avg_sentiment_score,
    positive_outcome_count = EXCLUDED.positive_outcome_count,
    neutral_outcome_count = EXCLUDED.neutral_outcome_count,
    negative_outcome_count = EXCLUDED.negative_outcome_count,
    forward_movement_count = EXCLUDED.forward_movement_count,
    proposal_request_count = EXCLUDED.proposal_request_count,
    demo_request_count = EXCLUDED.demo_request_count,
    next_steps_established_count = EXCLUDED.next_steps_established_count,
    pricing_discussion_count = EXCLUDED.pricing_discussion_count,
    competitor_mention_count = EXCLUDED.competitor_mention_count,
    timeline_discussion_count = EXCLUDED.timeline_discussion_count,
    budget_discussion_count = EXCLUDED.budget_discussion_count,
    objection_count = EXCLUDED.objection_count,
    avg_rep_talk_time = EXCLUDED.avg_rep_talk_time,
    avg_customer_talk_time = EXCLUDED.avg_customer_talk_time,
    meetings_change_pct = EXCLUDED.meetings_change_pct,
    forward_movement_change_pct = EXCLUDED.forward_movement_change_pct,
    sentiment_change_pct = EXCLUDED.sentiment_change_pct,
    last_calculated_at = NOW();
END;
$$;

-- ALTER FUNCTION "public"."refresh_meeting_aggregate_metrics"("p_org_id" "uuid", "p_period_type" "text", "p_period_start" "date") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."refresh_meeting_aggregate_metrics"("p_org_id" "uuid", "p_period_type" "text", "p_period_start" "date") IS 'Refreshes pre-computed aggregate metrics for a period';

CREATE OR REPLACE FUNCTION "public"."refresh_relationship_health_scores"("p_user_id" "uuid", "p_max_age_hours" integer DEFAULT 24) RETURNS TABLE("contact_id" "uuid", "health_score" integer, "health_status" "text", "updated" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
  DECLARE
    v_stale_threshold TIMESTAMP WITH TIME ZONE;
    v_contact RECORD;
    v_existing_score RECORD;
  BEGIN
    v_stale_threshold := NOW() - (p_max_age_hours || ' hours')::INTERVAL;

    FOR v_contact IN
      SELECT id, name, email FROM contacts WHERE owner_id = p_user_id
    LOOP
      SELECT * INTO v_existing_score FROM relationship_health_scores
      WHERE contact_id = v_contact.id AND user_id = p_user_id
      ORDER BY last_calculated_at DESC LIMIT 1;

      IF v_existing_score.id IS NOT NULL AND v_existing_score.last_calculated_at >
  v_stale_threshold THEN
        RETURN QUERY SELECT v_contact.id, v_existing_score.overall_health_score,
  v_existing_score.health_status::TEXT, FALSE;
        CONTINUE;
      END IF;

      DECLARE
        v_communication_count INTEGER;
        v_meeting_count INTEGER;
        v_days_since_contact INTEGER;
        v_overall_score INTEGER;
        v_health_status TEXT;
        v_risk_level TEXT;
      BEGIN
        SELECT COUNT(*) INTO v_communication_count FROM communication_events
        WHERE contact_id = v_contact.id AND user_id = p_user_id
        AND communication_date >= NOW() - INTERVAL '30 days';

        SELECT COUNT(*) INTO v_meeting_count FROM meetings m
        INNER JOIN meeting_contacts mc ON m.id = mc.meeting_id
        WHERE mc.contact_id = v_contact.id AND m.owner_user_id = p_user_id
        AND m.meeting_start >= NOW() - INTERVAL '30 days';

        SELECT EXTRACT(DAY FROM NOW() - MAX(communication_date))::INTEGER INTO
  v_days_since_contact
        FROM communication_events WHERE contact_id = v_contact.id AND user_id = p_user_id;

        v_overall_score := LEAST(100, (v_communication_count * 10) + (v_meeting_count * 20));

        IF v_days_since_contact IS NOT NULL AND v_days_since_contact > 14 THEN
          v_overall_score := v_overall_score - ((v_days_since_contact - 14) * 2);
        END IF;

        v_overall_score := GREATEST(0, v_overall_score);

        IF v_overall_score >= 70 THEN v_health_status := 'healthy';
        ELSIF v_overall_score >= 50 THEN v_health_status := 'at_risk';
        ELSIF v_overall_score >= 30 THEN v_health_status := 'critical';
        ELSE v_health_status := 'ghost';
        END IF;

        IF v_overall_score >= 70 THEN v_risk_level := 'low';
        ELSIF v_overall_score >= 50 THEN v_risk_level := 'medium';
        ELSIF v_overall_score >= 30 THEN v_risk_level := 'high';
        ELSE v_risk_level := 'critical';
        END IF;

        INSERT INTO relationship_health_scores (
          user_id, relationship_type, contact_id, overall_health_score, health_status,
  risk_level,
          communication_frequency_score, days_since_last_contact, meeting_count_30_days,
          email_count_30_days, total_interactions_30_days, is_ghost_risk,
          ghost_probability_percent, last_calculated_at
        ) VALUES (
          p_user_id, 'contact', v_contact.id, v_overall_score, v_health_status, v_risk_level,
          LEAST(100, v_communication_count * 25), v_days_since_contact, v_meeting_count,
          v_communication_count, v_communication_count + v_meeting_count, v_overall_score < 30,
          CASE WHEN v_overall_score < 30 THEN 75 WHEN v_overall_score < 50 THEN 40 ELSE 10 END,
          NOW()
        )
        ON CONFLICT (user_id, relationship_type, contact_id, company_id) DO UPDATE SET
          overall_health_score = EXCLUDED.overall_health_score,
          health_status = EXCLUDED.health_status,
          risk_level = EXCLUDED.risk_level,
          communication_frequency_score = EXCLUDED.communication_frequency_score,
          days_since_last_contact = EXCLUDED.days_since_last_contact,
          meeting_count_30_days = EXCLUDED.meeting_count_30_days,
          email_count_30_days = EXCLUDED.email_count_30_days,
          total_interactions_30_days = EXCLUDED.total_interactions_30_days,
          is_ghost_risk = EXCLUDED.is_ghost_risk,
          ghost_probability_percent = EXCLUDED.ghost_probability_percent,
          last_calculated_at = NOW(),
          updated_at = NOW();

        RETURN QUERY SELECT v_contact.id, v_overall_score, v_health_status, TRUE;
      END;
    END LOOP;
    RETURN;
  END;
  $$;

-- ALTER FUNCTION "public"."refresh_relationship_health_scores"("p_user_id" "uuid", "p_max_age_hours" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."refresh_relationship_health_scores"("p_user_id" "uuid", "p_max_age_hours" integer) IS 'Refreshes health scores for 
 -- contacts';

CREATE OR REPLACE FUNCTION "public"."regenerate_next_actions_for_activity"("p_activity_id" "uuid", "p_activity_type" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
     DECLARE
       v_user_id UUID;
       edge_function_url TEXT;
       request_id BIGINT;
     BEGIN
       v_user_id := get_user_id_from_activity(p_activity_id, p_activity_type);

       IF v_user_id IS NULL THEN
         RETURN json_build_object('error', 'Cannot determine user_id for activity');
       END IF;

       edge_function_url := get_system_config('supabase_url') || '/functions/v1/suggest-next-actions';

       -- pg_net.http_post returns a request_id, not the response
       -- The request is async, response comes later
       SELECT net.http_post(
         url := edge_function_url,
         body := jsonb_build_object(
           'activityId', p_activity_id,
           'activityType', p_activity_type,
           'userId', v_user_id,
           'forceRegenerate', true
         ),
         params := '{}'::jsonb,
         headers := jsonb_build_object(
           'Content-Type', 'application/json',
           'Authorization', 'Bearer ' || get_system_config('service_role_key')
         ),
         timeout_milliseconds := 30000
       ) INTO request_id;

       -- Return the request_id
       -- The actual Edge Function will run async and create suggestions
       RETURN json_build_object(
         'success', true,
         'request_id', request_id,
         'message', 'Suggestion generation queued'
       );

     EXCEPTION WHEN OTHERS THEN
       RETURN json_build_object(
         'error', 'Failed to regenerate suggestions',
         'details', SQLERRM
       );
     END;
     $$;

-- ALTER FUNCTION "public"."regenerate_next_actions_for_activity"("p_activity_id" "uuid", "p_activity_type" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."regenerate_next_actions_for_activity"("p_activity_id" "uuid", "p_activity_type" "text") IS 'Queues async suggestion generation via pg_net. Returns request_id. Edge Function runs in background.';

CREATE OR REPLACE FUNCTION "public"."reject_pipeline_recommendation"("p_recommendation_id" "uuid", "p_reviewed_by" "uuid", "p_notes" "text" DEFAULT NULL::"text") RETURNS boolean
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  UPDATE pipeline_stage_recommendations
  SET
    status = 'rejected',
    reviewed_at = NOW(),
    reviewed_by = p_reviewed_by,
    review_notes = p_notes
  WHERE id = p_recommendation_id
    AND status = 'pending';

  RETURN FOUND;
END;
$$;

-- ALTER FUNCTION "public"."reject_pipeline_recommendation"("p_recommendation_id" "uuid", "p_reviewed_by" "uuid", "p_notes" "text") OWNER TO "postgres";

-- ALTER FUNCTION "public"."rename_user_organization"("p_new_name" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."rename_user_organization"("p_new_name" "text") IS 'Renames the organization where the current user is an owner';

CREATE OR REPLACE FUNCTION "public"."resend_waitlist_magic_link"("p_entry_id" "uuid", "p_admin_user_id" "uuid") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  entry RECORD;
  result JSON;
BEGIN
  -- Validate admin permissions using the optimized function
  IF NOT public.is_admin_optimized() THEN
    RAISE EXCEPTION 'User % does not have admin permissions', p_admin_user_id;
  END IF;

  -- Get waitlist entry
  SELECT * INTO entry
  FROM public.meetings_waitlist
  WHERE id = p_entry_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Waitlist entry % not found', p_entry_id;
  END IF;

  -- Validate entry is in 'released' status or already converted
  IF entry.status NOT IN ('released', 'converted') THEN
    RAISE EXCEPTION 'Cannot resend magic link for entry with status: %', entry.status;
  END IF;

  -- Update magic link timestamps
  UPDATE public.meetings_waitlist
  SET
    magic_link_sent_at = now(),
    magic_link_expires_at = now() + INTERVAL '7 days',
    updated_at = now()
  WHERE id = p_entry_id;

  -- Build result
  result := json_build_object(
    'success', true,
    'entry_id', p_entry_id,
    'email', entry.email,
    'expires_at', now() + INTERVAL '7 days'
  );

  RETURN result;
END;
$$;

-- ALTER FUNCTION "public"."resend_waitlist_magic_link"("p_entry_id" "uuid", "p_admin_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."resend_waitlist_magic_link"("p_entry_id" "uuid", "p_admin_user_id" "uuid") IS 'Resend magic link for a waitlist entry - uses is_admin_optimized() for permission check';

-- ALTER FUNCTION "public"."reset_prompt_to_default"("p_category" "text") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."resolve_deal_migration_review"("p_review_id" "uuid", "p_company_id" "uuid", "p_contact_id" "uuid", "p_resolved_by" "uuid", "p_notes" "text" DEFAULT NULL::"text") RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  v_deal_id UUID;
BEGIN
  -- Get deal_id from review
  SELECT deal_id INTO v_deal_id
  FROM deal_migration_reviews
  WHERE id = p_review_id
    AND status = 'pending';

  IF v_deal_id IS NULL THEN
    RAISE EXCEPTION 'Review not found or already resolved';
  END IF;

  -- Update deal with resolved entities
  UPDATE deals
  SET company_id = p_company_id,
      primary_contact_id = p_contact_id,
      updated_at = NOW()
  WHERE id = v_deal_id;

  -- Mark review as resolved
  UPDATE deal_migration_reviews
  SET status = 'resolved',
      suggested_company_id = p_company_id,
      suggested_contact_id = p_contact_id,
      resolution_notes = p_notes,
      resolved_at = NOW(),
      resolved_by = p_resolved_by
  WHERE id = p_review_id;

  RETURN TRUE;
END;
$$;

-- ALTER FUNCTION "public"."resolve_deal_migration_review"("p_review_id" "uuid", "p_company_id" "uuid", "p_contact_id" "uuid", "p_resolved_by" "uuid", "p_notes" "text") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."resolve_fathom_user_to_sixty"("p_org_id" "uuid", "p_fathom_email" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_sixty_user_id UUID;
BEGIN
  -- Normalize email to lowercase
  SELECT sixty_user_id INTO v_sixty_user_id
  FROM fathom_user_mappings
  WHERE org_id = p_org_id
    AND fathom_user_email = LOWER(TRIM(p_fathom_email))
    AND sixty_user_id IS NOT NULL;
  
  RETURN v_sixty_user_id;
END;
$$;

-- ALTER FUNCTION "public"."resolve_fathom_user_to_sixty"("p_org_id" "uuid", "p_fathom_email" "text") OWNER TO "postgres";

-- ALTER FUNCTION "public"."respond_to_hitl_request"("p_request_id" "uuid", "p_response_value" "text", "p_response_context" "jsonb", "p_response_channel" "text") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."retry_roadmap_sync"("suggestion_id_param" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  suggestion_record record;
BEGIN
  -- Get the suggestion record
  SELECT * INTO suggestion_record
  FROM roadmap_suggestions
  WHERE id = suggestion_id_param;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Roadmap suggestion not found: %', suggestion_id_param;
  END IF;

  -- Reset sync status to pending
  UPDATE roadmap_suggestions
  SET
    hub_sync_status = 'pending',
    hub_sync_error = NULL,
    hub_last_sync_at = NOW()
  WHERE id = suggestion_id_param;

  -- Trigger webhook manually
  PERFORM trigger_roadmap_sync_webhook();
END;
$$;

-- ALTER FUNCTION "public"."retry_roadmap_sync"("suggestion_id_param" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."retry_roadmap_sync"("suggestion_id_param" "uuid") IS 'Manually retry synchronization for a failed roadmap item. Usage: SELECT retry_roadmap_sync(''<uuid>'');';

CREATE OR REPLACE FUNCTION "public"."safe_execute_unified_automation_rules"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Check if required tables exist
  IF NOT EXISTS (SELECT 1 FROM information_schema.tables 
                 WHERE table_schema = 'public' 
                 AND table_name = 'user_automation_rules') THEN
    -- Tables don't exist yet, just return without doing anything
    RETURN NEW;
  END IF;
  
  -- Tables exist, proceed with normal automation logic
  -- (This would normally call the actual automation function)
  -- For now, just return NEW to allow the operation to continue
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."safe_execute_unified_automation_rules"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."save_compiled_organization_skill"("p_org_id" "uuid", "p_skill_key" "text", "p_platform_skill_id" "uuid", "p_platform_version" integer, "p_compiled_frontmatter" "jsonb", "p_compiled_content" "text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_result_id UUID;
  v_skill_name TEXT;
BEGIN
  -- Get skill name from platform_skills
  SELECT COALESCE(
    ps.frontmatter->>'name',
    INITCAP(REPLACE(ps.skill_key, '-', ' '))
  ) INTO v_skill_name
  FROM platform_skills ps
  WHERE ps.id = p_platform_skill_id;

  -- Upsert organization skill
  INSERT INTO organization_skills (
    organization_id,
    skill_id,
    skill_name,
    config,
    platform_skill_id,
    platform_skill_version,
    compiled_frontmatter,
    compiled_content,
    is_enabled,
    is_active,
    ai_generated,
    last_compiled_at
  )
  VALUES (
    p_org_id,
    p_skill_key,
    COALESCE(v_skill_name, INITCAP(REPLACE(p_skill_key, '-', ' '))),
    '{}',
    p_platform_skill_id,
    p_platform_version,
    p_compiled_frontmatter,
    p_compiled_content,
    true,
    true,
    false,
    now()
  )
  ON CONFLICT (organization_id, skill_id)
  DO UPDATE SET
    platform_skill_id = EXCLUDED.platform_skill_id,
    platform_skill_version = EXCLUDED.platform_skill_version,
    compiled_frontmatter = EXCLUDED.compiled_frontmatter,
    compiled_content = EXCLUDED.compiled_content,
    last_compiled_at = now(),
    updated_at = now()
  RETURNING id INTO v_result_id;

  RETURN v_result_id;
END;
$$;

-- ALTER FUNCTION "public"."save_compiled_organization_skill"("p_org_id" "uuid", "p_skill_key" "text", "p_platform_skill_id" "uuid", "p_platform_version" integer, "p_compiled_frontmatter" "jsonb", "p_compiled_content" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."save_compiled_organization_skill"("p_org_id" "uuid", "p_skill_key" "text", "p_platform_skill_id" "uuid", "p_platform_version" integer, "p_compiled_frontmatter" "jsonb", "p_compiled_content" "text") IS 'Creates or updates an organization skill with compiled platform skill content';

CREATE OR REPLACE FUNCTION "public"."save_organization_skill"("p_org_id" "uuid", "p_skill_id" "text", "p_skill_name" "text", "p_config" "jsonb", "p_user_id" "uuid", "p_ai_generated" boolean DEFAULT false, "p_change_reason" "text" DEFAULT NULL::"text") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_existing_id UUID;
  v_current_version INT;
  v_new_version INT;
  v_result_id UUID;
BEGIN
  -- Check if skill already exists
  SELECT id, version INTO v_existing_id, v_current_version
  FROM organization_skills
  WHERE organization_id = p_org_id AND skill_id = p_skill_id;

  IF v_existing_id IS NOT NULL THEN
    -- Save current version to history
    INSERT INTO organization_skills_history (
      skill_record_id, organization_id, skill_id, config, version, changed_by, change_reason
    )
    SELECT id, organization_id, skill_id, config, version, p_user_id, p_change_reason
    FROM organization_skills
    WHERE id = v_existing_id;

    -- Update existing skill
    v_new_version := v_current_version + 1;
    UPDATE organization_skills
    SET
      config = p_config,
      user_modified = NOT p_ai_generated,
      version = v_new_version,
      updated_at = now()
    WHERE id = v_existing_id;

    v_result_id := v_existing_id;
  ELSE
    -- Insert new skill
    INSERT INTO organization_skills (
      organization_id, skill_id, skill_name, config, ai_generated, created_by
    )
    VALUES (p_org_id, p_skill_id, p_skill_name, p_config, p_ai_generated, p_user_id)
    RETURNING id INTO v_result_id;
  END IF;

  RETURN v_result_id;
END;
$$;

-- ALTER FUNCTION "public"."save_organization_skill"("p_org_id" "uuid", "p_skill_id" "text", "p_skill_name" "text", "p_config" "jsonb", "p_user_id" "uuid", "p_ai_generated" boolean, "p_change_reason" "text") OWNER TO "postgres";

-- ALTER FUNCTION "public"."save_platform_skill_history"() OWNER TO "postgres";

-- ALTER FUNCTION "public"."save_prompt_template"("p_category" "text", "p_name" "text", "p_system_prompt" "text", "p_user_prompt" "text", "p_model" "text", "p_temperature" numeric, "p_max_tokens" integer, "p_description" "text", "p_organization_id" "uuid", "p_is_public" boolean) OWNER TO "postgres";

-- ALTER FUNCTION "public"."search_meetings_by_owner"("p_owner_user_id" "uuid", "p_sentiment" "text", "p_date_from" "date", "p_date_to" "date", "p_company_id" "uuid", "p_has_action_items" boolean, "p_limit" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."search_meetings_by_owner"("p_owner_user_id" "uuid", "p_sentiment" "text", "p_date_from" "date", "p_date_to" "date", "p_company_id" "uuid", "p_has_action_items" boolean, "p_limit" integer) IS 'Search meetings with optional owner filter - pass NULL for all team meetings';

CREATE OR REPLACE FUNCTION "public"."seed_default_call_types"("p_org_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  -- Only seed if org doesn't have any call types yet
  IF NOT EXISTS (SELECT 1 FROM org_call_types WHERE org_id = p_org_id) THEN
    INSERT INTO org_call_types (org_id, name, description, keywords, color, icon, is_system, display_order) VALUES
      (p_org_id, 'Discovery', 'Initial qualification and needs assessment', 
       ARRAY['pain points', 'challenges', 'current process', 'goals', 'objectives', 'what are you', 'tell me about', 'how do you', 'what challenges', 'what problems', 'current situation', 'understanding', 'learn more', 'background'], 
       '#8b5cf6', 'search', true, 1),
      (p_org_id, 'Demo', 'Product demonstration', 
       ARRAY['show you', 'demonstration', 'walkthrough', 'feature', 'demo', 'showcase', 'preview', 'see how', 'let me show', 'here is how', 'this is how', 'example', 'illustrate'], 
       '#3b82f6', 'presentation', true, 2),
      (p_org_id, 'Close', 'Contract finalization', 
       ARRAY['sign', 'agreement', 'start date', 'onboarding', 'next steps', 'move forward', 'ready to', 'commit', 'decision', 'approve', 'finalize', 'execute', 'contract', 'paperwork'], 
       '#10b981', 'check-circle', true, 3),
      (p_org_id, 'Client', 'Existing client communication', 
       ARRAY['check in', 'status update', 'support', 'client', 'customer', 'account', 'relationship'], 
       '#6366f1', 'users', true, 4),
      (p_org_id, 'Internal Stand Up', 'Internal team meeting', 
       ARRAY['standup', 'team sync', 'blockers', 'daily', 'status', 'update', 'internal'], 
       '#f59e0b', 'users-2', true, 5),
      (p_org_id, 'Scrum', 'Agile ceremony', 
       ARRAY['sprint', 'backlog', 'retro', 'scrum', 'agile', 'sprint planning', 'sprint review', 'retrospective'], 
       '#ef4444', 'calendar', true, 6)
    ON CONFLICT (org_id, name) DO NOTHING;
  END IF;
END;
$$;

-- ALTER FUNCTION "public"."seed_default_call_types"("p_org_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."set_audit_context"("p_original_user_id" "uuid" DEFAULT NULL::"uuid", "p_impersonated_user_id" "uuid" DEFAULT NULL::"uuid", "p_is_impersonating" boolean DEFAULT false) RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Set the context variables that the audit trigger will read
  PERFORM set_config('app.original_user_id', COALESCE(p_original_user_id::text, ''), false);
  PERFORM set_config('app.impersonated_user_id', COALESCE(p_impersonated_user_id::text, ''), false);
  PERFORM set_config('app.is_impersonating', p_is_impersonating::text, false);
END;
$$;

-- ALTER FUNCTION "public"."set_audit_context"("p_original_user_id" "uuid", "p_impersonated_user_id" "uuid", "p_is_impersonating" boolean) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."set_calendar_event_org_id"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  -- Only set org_id if not already provided
  IF NEW.org_id IS NULL AND NEW.user_id IS NOT NULL THEN
    SELECT om.org_id INTO NEW.org_id
    FROM organization_memberships om
    WHERE om.user_id = NEW.user_id
    ORDER BY om.created_at ASC
    LIMIT 1;
  END IF;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."set_calendar_event_org_id"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."set_referral_code"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  IF NEW.referral_code IS NULL OR NEW.referral_code = '' THEN
    NEW.referral_code := generate_referral_code();
  END IF;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."set_referral_code"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."set_signup_position"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
DECLARE
  max_position INTEGER;
BEGIN
  SELECT COALESCE(MAX(signup_position), 0) INTO max_position
  FROM meetings_waitlist;
  NEW.signup_position := max_position + 1;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."set_signup_position"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."set_system_config"("p_key" "text", "p_value" "text", "p_description" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  INSERT INTO system_config (key, value, description, updated_at)
  VALUES (p_key, p_value, p_description, NOW())
  ON CONFLICT (key) DO UPDATE SET
    value = EXCLUDED.value,
    description = COALESCE(EXCLUDED.description, system_config.description),
    updated_at = NOW();
END;
$$;

-- ALTER FUNCTION "public"."set_system_config"("p_key" "text", "p_value" "text", "p_description" "text") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."should_create_notification"("p_user_id" "uuid", "p_notification_type" "text", "p_max_per_hour" integer DEFAULT 10, "p_max_per_day" integer DEFAULT 50) RETURNS boolean
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  count_last_hour INTEGER;
  count_last_day INTEGER;
BEGIN
  -- Count notifications in the last hour
  SELECT COUNT(*) INTO count_last_hour
  FROM notification_rate_limits
  WHERE user_id = p_user_id
    AND notification_type = p_notification_type
    AND created_at > NOW() - INTERVAL '1 hour';

  -- Count notifications in the last 24 hours
  SELECT COUNT(*) INTO count_last_day
  FROM notification_rate_limits
  WHERE user_id = p_user_id
    AND notification_type = p_notification_type
    AND created_at > NOW() - INTERVAL '24 hours';

  -- Check if limits are exceeded
  IF count_last_hour >= p_max_per_hour THEN
    RAISE NOTICE 'Rate limit exceeded: % notifications in last hour (max: %)',
      count_last_hour, p_max_per_hour;
    RETURN FALSE;
  END IF;

  IF count_last_day >= p_max_per_day THEN
    RAISE NOTICE 'Rate limit exceeded: % notifications in last 24 hours (max: %)',
      count_last_day, p_max_per_day;
    RETURN FALSE;
  END IF;

  -- Record this notification attempt
  INSERT INTO notification_rate_limits (user_id, notification_type, created_at)
  VALUES (p_user_id, p_notification_type, NOW());

  RETURN TRUE;
END;
$$;

-- ALTER FUNCTION "public"."should_create_notification"("p_user_id" "uuid", "p_notification_type" "text", "p_max_per_hour" integer, "p_max_per_day" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."should_create_notification"("p_user_id" "uuid", "p_notification_type" "text", "p_max_per_hour" integer, "p_max_per_day" integer) IS 'Check if notification should be created based on rate limits. Default limits: 10 per hour, 50 per day. Returns TRUE if notification should be created, FALSE if rate limit exceeded.';

CREATE OR REPLACE FUNCTION "public"."should_request_feedback"("p_user_id" "uuid") RETURNS TABLE("should_request" boolean, "reason" "text", "days_since_last_feedback" integer, "notifications_since_last_feedback" integer)
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_metrics RECORD;
  v_days_since INTEGER;
  v_notif_count INTEGER;
BEGIN
  -- Get user metrics
  SELECT
    last_feedback_requested_at,
    COALESCE(notifications_since_last_feedback, 0) AS notif_count
  INTO v_metrics
  FROM user_engagement_metrics
  WHERE user_id = p_user_id;

  -- Calculate days since last feedback
  IF v_metrics.last_feedback_requested_at IS NOT NULL THEN
    v_days_since := EXTRACT(DAY FROM NOW() - v_metrics.last_feedback_requested_at)::INTEGER;
  ELSE
    v_days_since := NULL;
  END IF;

  v_notif_count := COALESCE(v_metrics.notif_count, 0);

  -- Check conditions
  -- 1. Never requested before and sent enough notifications (10+)
  IF v_days_since IS NULL AND v_notif_count >= 10 THEN
    RETURN QUERY SELECT TRUE, 'first_feedback_request'::TEXT, v_days_since, v_notif_count;
    RETURN;
  END IF;

  -- 2. Time-based check (every 14 days)
  IF v_days_since IS NOT NULL AND v_days_since >= 14 THEN
    RETURN QUERY SELECT TRUE, 'interval_elapsed'::TEXT, v_days_since, v_notif_count;
    RETURN;
  END IF;

  -- 3. High notification count (20+)
  IF v_notif_count >= 20 THEN
    RETURN QUERY SELECT TRUE, 'high_notification_count'::TEXT, v_days_since, v_notif_count;
    RETURN;
  END IF;

  -- Not due for feedback
  RETURN QUERY SELECT FALSE, 'not_due'::TEXT, v_days_since, v_notif_count;
END;
$$;

-- ALTER FUNCTION "public"."should_request_feedback"("p_user_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."should_request_feedback"("p_user_id" "uuid") IS 'Check if a user is due for a feedback request';

CREATE OR REPLACE FUNCTION "public"."sync_action_item_completion_to_task"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- When an action item's completed status changes, update the linked task
  IF NEW.linked_task_id IS NOT NULL AND 
     OLD.completed IS DISTINCT FROM NEW.completed THEN
    UPDATE tasks 
    SET 
      completed = NEW.completed,
      completed_at = CASE 
        WHEN NEW.completed = true THEN NOW() 
        ELSE NULL 
      END,
      status = CASE 
        WHEN NEW.completed = true THEN 'completed'::text
        ELSE 'pending'::text
      END,
      updated_at = NOW()
    WHERE id = NEW.linked_task_id;
  END IF;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."sync_action_item_completion_to_task"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."sync_action_item_to_task"("action_item_id" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  v_action_item RECORD;
  v_user_id UUID;
  v_task_id UUID;
  v_meeting_owner_id UUID;
  v_company_id UUID;
  v_deal_id UUID;
BEGIN
  -- Get action item details
  SELECT * INTO v_action_item
  FROM meeting_action_items
  WHERE id = action_item_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Action item not found: %', action_item_id;
  END IF;

  -- Get meeting owner and company
  SELECT owner_user_id, company_id INTO v_meeting_owner_id, v_company_id
  FROM meetings
  WHERE id = v_action_item.meeting_id;

  -- Get active deal for this company
  -- FIXED: deals table uses 'status' not 'stage'
  SELECT id INTO v_deal_id
  FROM deals
  WHERE company_id = v_company_id
    AND status = 'active' -- Only active deals, not won/lost
  ORDER BY created_at DESC
  LIMIT 1;

  -- Check if assignee is internal (sales rep)
  IF NOT is_internal_assignee(v_action_item.assignee_email) THEN
    -- External assignee - mark as excluded
    UPDATE meeting_action_items
    SET
      sync_status = 'excluded',
      sync_error = 'External assignee - not synced to CRM tasks'
    WHERE id = action_item_id;

    RETURN NULL;
  END IF;

  -- Get user ID for internal assignee
  v_user_id := get_user_id_from_email(v_action_item.assignee_email);

  IF v_user_id IS NULL THEN
    UPDATE meeting_action_items
    SET
      sync_status = 'failed',
      sync_error = 'Could not find user ID for email: ' || v_action_item.assignee_email
    WHERE id = action_item_id;

    RETURN NULL;
  END IF;

  -- Check if task already exists
  IF v_action_item.task_id IS NOT NULL THEN
    -- Update existing task
    UPDATE tasks
    SET
      title = v_action_item.title,
      description = NULL, -- meeting_action_items has no notes field
      priority = CASE
        WHEN v_action_item.priority = 'high' THEN 'high'
        WHEN v_action_item.priority = 'medium' THEN 'medium'
        ELSE 'low'
      END,
      due_date = v_action_item.deadline_at, -- FIXED: deadline_at not due_date
      status = CASE
        WHEN v_action_item.completed THEN 'completed'
        ELSE 'open'
      END,
      updated_at = NOW()
    WHERE id = v_action_item.task_id;

    v_task_id := v_action_item.task_id;
  ELSE
    -- Create new task
    INSERT INTO tasks (
      title,
      description,
      created_by,
      assigned_to,
      company_id,
      deal_id,
      priority,
      due_date,
      status,
      task_type,
      meeting_action_item_id,
      created_at,
      updated_at
    ) VALUES (
      v_action_item.title,
      NULL, -- meeting_action_items has no notes field
      v_meeting_owner_id, -- creator is meeting owner
      v_user_id, -- assigned to the action item assignee
      v_company_id,
      v_deal_id,
      CASE
        WHEN v_action_item.priority = 'high' THEN 'high'
        WHEN v_action_item.priority = 'medium' THEN 'medium'
        ELSE 'low'
      END,
      v_action_item.deadline_at, -- FIXED: deadline_at not due_date
      CASE
        WHEN v_action_item.completed THEN 'completed'
        ELSE 'open'
      END,
      'follow_up',
      action_item_id,
      NOW(),
      NOW()
    )
    RETURNING id INTO v_task_id;

    -- Update action item with task reference
    UPDATE meeting_action_items
    SET task_id = v_task_id
    WHERE id = action_item_id;
  END IF;

  -- Mark as synced
  UPDATE meeting_action_items
  SET
    synced_to_task = true,
    sync_status = 'synced',
    sync_error = NULL,
    synced_at = NOW()
  WHERE id = action_item_id;

  RETURN v_task_id;
END;
$$;

-- ALTER FUNCTION "public"."sync_action_item_to_task"("action_item_id" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."sync_action_item_to_task"("action_item_id" "uuid") IS 'Syncs a meeting action item to a CRM task (internal assignees only)';

CREATE OR REPLACE FUNCTION "public"."sync_deal_activity_to_main_activities"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  main_activity_type TEXT;
  deal_record RECORD;
  sales_rep_name TEXT;
BEGIN
  -- Only sync completed activities that map to main activity types
  IF NEW.completed = false THEN
    RETURN NEW;
  END IF;
  
  -- Map the activity type
  main_activity_type := map_deal_activity_to_main_activity(NEW.activity_type);
  
  -- Skip if activity type doesn't map
  IF main_activity_type IS NULL THEN
    RETURN NEW;
  END IF;
  
  -- Get deal information
  SELECT d.*, c.name as company_name, ct.email as contact_email
  INTO deal_record
  FROM deals d
  LEFT JOIN companies c ON d.company_id = c.id
  LEFT JOIN contacts ct ON d.primary_contact_id = ct.id
  WHERE d.id = NEW.deal_id;
  
  -- Get sales rep name
  SELECT COALESCE(p.first_name || ' ' || p.last_name, p.email)
  INTO sales_rep_name
  FROM profiles p
  WHERE p.id = NEW.user_id;
  
  -- Insert into main activities table
  INSERT INTO activities (
    user_id,
    type,
    status,
    priority,
    client_name,
    sales_rep,
    details,
    amount,
    date,
    created_at,
    updated_at,
    quantity,
    contact_identifier,
    contact_identifier_type,
    company_id,
    contact_id,
    deal_id,
    auto_matched
  ) VALUES (
    NEW.user_id,
    main_activity_type,
    'completed',
    'medium', -- Default priority
    COALESCE(deal_record.company_name, deal_record.company, 'Unknown Company'),
    COALESCE(sales_rep_name, 'Unknown Rep'),
    NEW.notes,
    CASE WHEN main_activity_type = 'meeting' THEN deal_record.value ELSE NULL END,
    COALESCE(NEW.created_at, NOW()),
    COALESCE(NEW.created_at, NOW()),
    NOW(),
    1, -- Default quantity
    COALESCE(NEW.contact_email, deal_record.contact_email),
    CASE WHEN COALESCE(NEW.contact_email, deal_record.contact_email) IS NOT NULL THEN 'email' ELSE NULL END,
    deal_record.company_id,
    deal_record.primary_contact_id,
    NEW.deal_id,
    true -- Auto-matched since it came from deal
  );
  
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."sync_deal_activity_to_main_activities"() OWNER TO "postgres";

-- ALTER FUNCTION "public"."sync_playwright_test_user"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."sync_playwright_test_user"() IS 'Syncs the Playwright test user data with andrew.bryce@sixtyseconds.video for consistent testing';

-- ALTER FUNCTION "public"."sync_task_assignee_to_action_item"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."sync_task_completion_to_action_item"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- When a task's completed status changes, update the linked action item
  IF NEW.meeting_action_item_id IS NOT NULL AND 
     OLD.completed IS DISTINCT FROM NEW.completed THEN
    UPDATE meeting_action_items 
    SET 
      completed = NEW.completed,
      updated_at = NOW()
    WHERE id = NEW.meeting_action_item_id;
  END IF;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."sync_task_completion_to_action_item"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."sync_task_to_action_item"("task_id_input" "uuid") RETURNS "uuid"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  v_task RECORD;
  v_action_item_id UUID;
BEGIN
  -- Get task details
  SELECT * INTO v_task
  FROM tasks
  WHERE id = task_id_input;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Task not found: %', task_id_input;
  END IF;

  -- Get linked action item
  v_action_item_id := v_task.meeting_action_item_id;

  IF v_action_item_id IS NULL THEN
    -- Task not linked to action item
    RETURN NULL;
  END IF;

  -- Update action item
  UPDATE meeting_action_items
  SET
    title = v_task.title,
    -- No notes field in meeting_action_items
    priority = CASE
      WHEN v_task.priority = 'high' THEN 'high'
      WHEN v_task.priority = 'medium' THEN 'medium'
      ELSE 'low'
    END,
    deadline_at = v_task.due_date, -- FIXED: deadline_at not due_date
    completed = (v_task.status = 'completed'),
    updated_at = NOW()
  WHERE id = v_action_item_id;

  RETURN v_action_item_id;
END;
$$;

-- ALTER FUNCTION "public"."sync_task_to_action_item"("task_id_input" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."sync_task_to_action_item"("task_id_input" "uuid") IS 'Syncs task changes back to the source action item';

CREATE OR REPLACE FUNCTION "public"."sync_task_type_columns"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- If type is provided but task_type is not, copy type to task_type
  IF NEW.type IS NOT NULL AND NEW.task_type IS NULL THEN
    NEW.task_type = NEW.type;
  END IF;
  
  -- If task_type is provided but type is not, copy task_type to type
  IF NEW.task_type IS NOT NULL AND NEW.type IS NULL THEN
    NEW.type = NEW.task_type;
  END IF;
  
  -- If both are provided, use whichever was updated (prefer type for automation compatibility)
  IF NEW.type IS NOT NULL AND NEW.task_type IS NOT NULL AND NEW.type != OLD.type THEN
    NEW.task_type = NEW.type;
  ELSIF NEW.task_type IS NOT NULL AND NEW.type IS NOT NULL AND NEW.task_type != OLD.task_type THEN
    NEW.type = NEW.task_type;
  END IF;
  
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."sync_task_type_columns"() OWNER TO "postgres";

-- ALTER FUNCTION "public"."toggle_topic_archive"("p_topic_id" "uuid", "p_archive" boolean) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."track_waitlist_link_share"("p_entry_id" "uuid", "p_platform" "text") RETURNS json
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  v_entry RECORD;
  v_new_share_id UUID;
BEGIN
  -- Validate platform (basic check)
  IF p_platform IS NULL OR TRIM(p_platform) = '' THEN
    p_platform := 'copy';
  END IF;

  -- Check if entry exists
  SELECT id FROM meetings_waitlist WHERE id = p_entry_id INTO v_entry;

  IF v_entry.id IS NULL THEN
    RETURN json_build_object(
      'success', false,
      'error', 'Entry not found'
    );
  END IF;

  -- Create the share record (no points awarded - just tracking)
  INSERT INTO waitlist_shares (
    waitlist_entry_id,
    platform,
    referral_clicked,
    referral_converted
  ) VALUES (
    p_entry_id,
    p_platform,
    false,
    false
  )
  RETURNING id INTO v_new_share_id;

  -- Return success (no points awarded)
  RETURN json_build_object(
    'success', true,
    'share_id', v_new_share_id,
    'platform', p_platform,
    'points_awarded', 0
  );
END;
$$;

-- ALTER FUNCTION "public"."track_waitlist_link_share"("p_entry_id" "uuid", "p_platform" "text") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."trigger_all_task_notifications"() RETURNS json
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  upcoming_result JSON;
  overdue_result JSON;
BEGIN
  -- Send upcoming deadline notifications
  SELECT notify_upcoming_task_deadlines() INTO upcoming_result;

  -- Send overdue task notifications
  SELECT notify_overdue_tasks() INTO overdue_result;

  RETURN json_build_object(
    'success', true,
    'upcoming_deadlines', upcoming_result,
    'overdue_tasks', overdue_result,
    'timestamp', NOW()
  );
END;
$$;

-- ALTER FUNCTION "public"."trigger_all_task_notifications"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."trigger_all_task_notifications"() IS 'Manual trigger: Run all task notification checks (for testing)';

-- ALTER FUNCTION "public"."trigger_auto_record_for_new_event"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."trigger_auto_record_for_new_event"() IS 'Trigger function that auto-deploys recording bots for new calendar events.
-- Fires on INSERT and UPDATE (when meeting_url changes).

-- Conditions for triggering:
-- 1. Event has a meeting URL
-- 2. Event is in the future (within 60 minutes)
-- 3. Auto-record is enabled for the org
-- 4. If external-only is set, event has external attendees
--
-- Requires service_role_key in vault for API calls.
-- See: supabase/functions/deploy-recording-bot/index.ts';

CREATE OR REPLACE FUNCTION "public"."trigger_fathom_hourly_sync"() RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  supabase_url TEXT;
  service_role_key TEXT;
  http_response JSONB;
BEGIN
  -- Get Supabase configuration from environment
  -- Note: These would be set via ALTER DATABASE SET or vault
  supabase_url := current_setting('app.supabase_url', true);
  service_role_key := current_setting('app.supabase_service_role_key', true);

  -- If not configured, log warning and exit
  IF supabase_url IS NULL OR service_role_key IS NULL THEN
    RAISE WARNING 'Supabase configuration not set for cron sync';

    -- INSERT INTO public.cron_job_logs (
    --   job_name,     -- Name of the cron job
    --   status,       -- Status to indicate error
    --   message,      -- Error message describing the issue
    --   created_at    -- Timestamp for when the log entry is created
    -- ) VALUES (
    --   'fathom_hourly_sync',                 -- Job name
    --   'error',                              -- Status
    --   'Supabase configuration missing',      -- Error message
    --   NOW()                                 -- Current timestamp
    -- );

    RETURN;
  END IF;

  -- Call the Edge Function using HTTP extension (requires http extension)
  -- Note: Install with: CREATE EXTENSION IF NOT EXISTS http;
  -- For now, we'll use a simpler approach with pg_net (Supabase's async HTTP)

  BEGIN
    -- Use pg_net.http_post to call the Edge Function asynchronously
    -- This requires pg_net extension (available in Supabase)
    PERFORM net.http_post(
      url := supabase_url || '/functions/v1/fathom-cron-sync',
      headers := jsonb_build_object(
        'Content-Type', 'application/json',
        'Authorization', 'Bearer ' || service_role_key
      ),
      body := '{}'::jsonb
    );

    -- Log the trigger
    -- Log the successful invocation of the cron sync Edge Function
    -- INSERT INTO public.cron_job_logs (
    --   job_name,
    --   status,
    --   message,
    --   created_at
    -- ) VALUES (
    --   'fathom_hourly_sync',
    --   'triggered',
    --   'Cron sync Edge Function invoked',
    --   NOW()
    -- );

  -- EXCEPTION WHEN OTHERS THEN
  --   -- Log error
  --   INSERT INTO public.cron_job_logs (
  --     job_name,
  --     status,
  --     message,
  --     error_details,
  --     created_at
  --   ) VALUES (
  --     'fathom_hourly_sync',
  --     'error',
  --     'Failed to invoke Edge Function',
  --     SQLERRM,
  --     NOW()
  --   );
  -- END;

  RAISE NOTICE 'Fathom cron sync Edge Function invoked';
END;
$$;

-- ALTER FUNCTION "public"."trigger_fathom_hourly_sync"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."trigger_fathom_hourly_sync"() IS 'Triggers hourly incremental sync for all active Fathom integrations during working hours (8am-3pm weekdays)';

CREATE OR REPLACE FUNCTION "public"."trigger_recalculate_clarity_on_plan_change"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    PERFORM upsert_deal_clarity_score(OLD.deal_id, OLD.org_id);
    RETURN OLD;
  ELSE
    PERFORM upsert_deal_clarity_score(NEW.deal_id, NEW.org_id);
    RETURN NEW;
  END IF;
END;
$$;

-- ALTER FUNCTION "public"."trigger_recalculate_clarity_on_plan_change"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."trigger_recalculate_clarity_on_truth_change"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    PERFORM upsert_deal_clarity_score(OLD.deal_id, OLD.org_id);
    RETURN OLD;
  ELSE
    PERFORM upsert_deal_clarity_score(NEW.deal_id, NEW.org_id);
    RETURN NEW;
  END IF;
END;
$$;

-- ALTER FUNCTION "public"."trigger_recalculate_clarity_on_truth_change"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."trigger_recalculate_deal_risk"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    PERFORM calculate_deal_risk_aggregate(OLD.deal_id);
    RETURN OLD;
  ELSE
    PERFORM calculate_deal_risk_aggregate(NEW.deal_id);
    RETURN NEW;
  END IF;
END;
$$;

-- ALTER FUNCTION "public"."trigger_recalculate_deal_risk"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."trigger_roadmap_sync_webhook"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
DECLARE
  webhook_url TEXT;
  payload JSONB;
  record_data JSONB;
BEGIN
  -- Get webhook URL from app_settings with EXPLICIT schema qualification
  SELECT value INTO webhook_url
  FROM public.app_settings
  WHERE key = 'roadmap_webhook_url';

  -- If no webhook configured, skip
  IF webhook_url IS NULL OR webhook_url = '' THEN
    IF TG_OP = 'DELETE' THEN
      RETURN OLD;
    ELSE
      RETURN NEW;
    END IF;
  END IF;

  -- Build record data based on operation
  IF TG_OP = 'DELETE' THEN
    record_data := to_jsonb(OLD);
  ELSE
    record_data := to_jsonb(NEW);
  END IF;

  -- Build notification payload
  payload := jsonb_build_object(
    'event', TG_OP,
    'table', TG_TABLE_NAME,
    'schema', TG_TABLE_SCHEMA,
    'record', record_data,
    'timestamp', now()
  );

  -- Send async HTTP request via pg_net if available
  BEGIN
    PERFORM net.http_post(
      url := webhook_url,
      headers := jsonb_build_object(
        'Content-Type', 'application/json'
      ),
      body := payload::text
    );
  EXCEPTION WHEN OTHERS THEN
    -- Log error but don't fail the transaction
    RAISE WARNING 'Failed to send roadmap sync webhook: %', SQLERRM;
  END;

  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  ELSE
    RETURN NEW;
  END IF;
END;
$$;

-- ALTER FUNCTION "public"."trigger_roadmap_sync_webhook"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."trigger_suggest_next_actions_for_activity"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Only generate suggestions for certain activity types
  IF TG_OP = 'INSERT' AND NEW.type IN ('email', 'proposal', 'call', 'demo') THEN

    -- Check if activity has details (not notes - activities table uses 'details' field)
    IF NEW.details IS NOT NULL AND LENGTH(NEW.details) > 50 THEN

      -- Call Edge Function asynchronously
      PERFORM call_suggest_next_actions_async(
        NEW.id,
        'activity',
        NEW.user_id
      );

    END IF;

  END IF;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."trigger_suggest_next_actions_for_activity"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."trigger_suggest_next_actions_for_activity"() IS 'Trigger function to auto-generate suggestions for important activities (email, proposal, call, demo)';

CREATE OR REPLACE FUNCTION "public"."trigger_suggest_next_actions_for_meeting"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Only generate suggestions for new meetings with transcript or summary
  IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND OLD.transcript_text IS NULL AND NEW.transcript_text IS NOT NULL) THEN

    -- Check if meeting has sufficient context for analysis
    IF NEW.transcript_text IS NOT NULL OR NEW.summary IS NOT NULL THEN

      -- Skip if suggestions were already generated recently (within last hour)
      IF NEW.next_actions_generated_at IS NULL OR
         NEW.next_actions_generated_at < NOW() - INTERVAL '1 hour' THEN

        -- Call Edge Function asynchronously
        PERFORM call_suggest_next_actions_async(
          NEW.id,
          'meeting',
          NEW.owner_user_id
        );

      END IF;

    END IF;

  END IF;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."trigger_suggest_next_actions_for_meeting"() OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."trigger_suggest_next_actions_for_meeting"() IS 'Trigger function to auto-generate suggestions for new meetings with transcript/summary';

CREATE OR REPLACE FUNCTION "public"."trigger_sync_action_item_to_task"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Only sync if assignee is internal (checked in sync function)
  PERFORM sync_action_item_to_task(NEW.id);
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."trigger_sync_action_item_to_task"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."trigger_sync_task_to_action_item"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  IF NEW.meeting_action_item_id IS NOT NULL THEN
    PERFORM sync_task_to_action_item(NEW.id);
  END IF;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."trigger_sync_task_to_action_item"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."trigger_update_meeting_insights"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Only trigger on synced meetings
  IF NEW.sync_status = 'synced' THEN
    -- Update contact insights for all linked contacts
    PERFORM aggregate_contact_meeting_insights(mc.contact_id)
    FROM meeting_contacts mc
    WHERE mc.meeting_id = NEW.id;

    -- Update company insights if linked
    IF NEW.company_id IS NOT NULL THEN
      PERFORM aggregate_company_meeting_insights(NEW.company_id);
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."trigger_update_meeting_insights"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_ai_preferences_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_ai_preferences_timestamp"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_app_settings_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_app_settings_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_branding_settings_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_branding_settings_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_clerk_mapping_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_clerk_mapping_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_clients_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
  BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
  END;
  $$;

-- ALTER FUNCTION "public"."update_clients_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_coaching_scorecard_templates_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_coaching_scorecard_templates_timestamp"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_contact_meeting_stats"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Update total_meetings_count for the contact
  UPDATE contacts
  SET
    total_meetings_count = (
      SELECT COUNT(*)
      FROM meeting_contacts
      WHERE contact_id = NEW.contact_id
    ),
    last_interaction_at = (
      SELECT MAX(m.meeting_start)
      FROM meetings m
      JOIN meeting_contacts mc ON m.id = mc.meeting_id
      WHERE mc.contact_id = NEW.contact_id
    )
  WHERE id = NEW.contact_id;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_contact_meeting_stats"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_contact_meeting_stats_on_delete"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Update total_meetings_count for the contact
  UPDATE public.contacts
  SET
    total_meetings_count = (
      SELECT COUNT(*)
      FROM public.meeting_contacts
      WHERE contact_id = OLD.contact_id
    ),
    last_interaction_at = (
      SELECT MAX(m.meeting_start)
      FROM public.meetings m
      JOIN public.meeting_contacts mc ON m.id = mc.meeting_id
      WHERE mc.contact_id = OLD.contact_id
    )
  WHERE id = OLD.contact_id;

  RETURN OLD;
END;
$$;

-- ALTER FUNCTION "public"."update_contact_meeting_stats_on_delete"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_copilot_conversation_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE copilot_conversations
  SET updated_at = now()
  WHERE id = NEW.conversation_id;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_copilot_conversation_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_deal_clarity_scores_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_deal_clarity_scores_timestamp"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_deal_close_plan_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  -- Auto-set completed_at when status changes to completed
  IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
    NEW.completed_at = NOW();
  END IF;
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_deal_close_plan_timestamp"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_deal_revenue_calculations"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  -- Auto-calculate total deal value
  NEW.value := calculate_deal_total_value(NEW.one_off_revenue, NEW.monthly_mrr);

  -- Auto-calculate annual value
  NEW.annual_value := calculate_deal_annual_value(NEW.one_off_revenue, NEW.monthly_mrr);

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_deal_revenue_calculations"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_deal_risk_tables_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_deal_risk_tables_timestamp"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_deal_split_amounts_on_deal_change"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Update all split amounts for this deal when deal value changes
  UPDATE deal_splits 
  SET amount = calculate_split_amount(NEW.id, percentage),
      updated_at = NOW()
  WHERE deal_id = NEW.id;
  
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_deal_split_amounts_on_deal_change"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_deal_truth_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.last_updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_deal_truth_timestamp"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_fathom_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_fathom_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_fathom_user_mappings_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_fathom_user_mappings_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_google_tasks_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_google_tasks_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_hitl_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_hitl_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_intervention_templates_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_intervention_templates_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_interventions_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_interventions_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_last_login"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
  BEGIN
    -- Use public.profiles instead of just profiles
    UPDATE public.profiles
    SET last_login_at = NEW.last_sign_in_at
    WHERE id = NEW.id;
    RETURN NEW;
  END;
  $$;

-- ALTER FUNCTION "public"."update_last_login"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_launch_checklist_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_launch_checklist_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_meeting_structured_summaries_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_meeting_structured_summaries_timestamp"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_meetingbaas_calendars_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_meetingbaas_calendars_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_next_actions_count"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Update count based on activity type
  IF TG_OP = 'INSERT' THEN
    IF NEW.activity_type = 'meeting' THEN
      UPDATE meetings
      SET
        next_actions_count = COALESCE(next_actions_count, 0) + 1,
        next_actions_generated_at = NOW()
      WHERE id = NEW.activity_id;
    ELSIF NEW.activity_type = 'activity' THEN
      UPDATE activities
      SET
        next_actions_count = COALESCE(next_actions_count, 0) + 1,
        next_actions_generated_at = NOW()
      WHERE id = NEW.activity_id;
    END IF;
  ELSIF TG_OP = 'DELETE' THEN
    IF OLD.activity_type = 'meeting' THEN
      UPDATE meetings
      SET next_actions_count = GREATEST(0, COALESCE(next_actions_count, 0) - 1)
      WHERE id = OLD.activity_id;
    ELSIF OLD.activity_type = 'activity' THEN
      UPDATE activities
      SET next_actions_count = GREATEST(0, COALESCE(next_actions_count, 0) - 1)
      WHERE id = OLD.activity_id;
    END IF;
  END IF;

  RETURN COALESCE(NEW, OLD);
END;
$$;

-- ALTER FUNCTION "public"."update_next_actions_count"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_notification_interaction"("p_interaction_id" "uuid", "p_action" "text", "p_action_taken" "text" DEFAULT NULL::"text", "p_feedback_rating" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_now TIMESTAMPTZ := NOW();
  v_delivered_at TIMESTAMPTZ;
  v_user_id UUID;
BEGIN
  -- Get delivery time for calculating response time
  SELECT delivered_at, user_id INTO v_delivered_at, v_user_id
  FROM notification_interactions
  WHERE id = p_interaction_id;

  UPDATE notification_interactions
  SET
    seen_at = CASE WHEN p_action = 'seen' AND seen_at IS NULL THEN v_now ELSE seen_at END,
    clicked_at = CASE WHEN p_action = 'clicked' THEN v_now ELSE clicked_at END,
    dismissed_at = CASE WHEN p_action = 'dismissed' THEN v_now ELSE dismissed_at END,
    action_taken = COALESCE(p_action_taken, action_taken),
    time_to_interaction_seconds = CASE
      WHEN p_action IN ('clicked', 'dismissed') AND time_to_interaction_seconds IS NULL
      THEN EXTRACT(EPOCH FROM (v_now - v_delivered_at))::INTEGER
      ELSE time_to_interaction_seconds
    END,
    feedback_rating = COALESCE(p_feedback_rating, feedback_rating),
    feedback_at = CASE WHEN p_feedback_rating IS NOT NULL THEN v_now ELSE feedback_at END
  WHERE id = p_interaction_id;

  -- Update engagement metrics if notification was clicked
  IF p_action = 'clicked' THEN
    UPDATE user_engagement_metrics
    SET last_notification_clicked_at = v_now
    WHERE user_id = v_user_id;
  END IF;
END;
$$;

-- ALTER FUNCTION "public"."update_notification_interaction"("p_interaction_id" "uuid", "p_action" "text", "p_action_taken" "text", "p_feedback_rating" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."update_notification_interaction"("p_interaction_id" "uuid", "p_action" "text", "p_action_taken" "text", "p_feedback_rating" "text") IS 'Updates interaction status when user clicks, dismisses, or provides feedback';

CREATE OR REPLACE FUNCTION "public"."update_onboarding_progress_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_onboarding_progress_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_org_call_types_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_org_call_types_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_partial_signups_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_partial_signups_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_pipeline_rules_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_pipeline_rules_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_pm_workflows_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_pm_workflows_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_process_maps_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_process_maps_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_relationship_health_scores_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_relationship_health_scores_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_sentiment_alerts_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_sentiment_alerts_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_sentry_bridge_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_sentry_bridge_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_slack_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_slack_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_split_amount"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.amount := calculate_split_amount(NEW.deal_id, NEW.percentage);
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_split_amount"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_subscription_facts"("p_subscription_id" "uuid", "p_recurring_amount_cents" integer, "p_interval" "text", "p_interval_count" integer DEFAULT 1, "p_discount_info" "jsonb" DEFAULT '{}'::"jsonb", "p_customer_country" "text" DEFAULT NULL::"text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
BEGIN
  UPDATE organization_subscriptions
  SET
    current_recurring_amount_cents = p_recurring_amount_cents,
    recurring_interval = p_interval,
    interval_count = p_interval_count,
    discount_info = p_discount_info,
    customer_country = COALESCE(p_customer_country, customer_country),
    updated_at = NOW()
  WHERE id = p_subscription_id;
END;
$$;

-- ALTER FUNCTION "public"."update_subscription_facts"("p_subscription_id" "uuid", "p_recurring_amount_cents" integer, "p_interval" "text", "p_interval_count" integer, "p_discount_info" "jsonb", "p_customer_country" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."update_subscription_facts"("p_subscription_id" "uuid", "p_recurring_amount_cents" integer, "p_interval" "text", "p_interval_count" integer, "p_discount_info" "jsonb", "p_customer_country" "text") IS 'Updates subscription facts from Stripe subscription data';

CREATE OR REPLACE FUNCTION "public"."update_suggestion_on_task_creation"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  IF NEW.created_task_id IS NOT NULL AND OLD.created_task_id IS NULL THEN
    NEW.status := 'accepted';
    NEW.accepted_at := NOW();
  END IF;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_suggestion_on_task_creation"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_suggestion_votes_count"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE roadmap_suggestions 
    SET votes_count = votes_count + 1,
        updated_at = NOW()
    WHERE id = NEW.suggestion_id;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE roadmap_suggestions 
    SET votes_count = votes_count - 1,
        updated_at = NOW()
    WHERE id = OLD.suggestion_id;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$;

-- ALTER FUNCTION "public"."update_suggestion_votes_count"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_system_config_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_system_config_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_task_sync_status"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- When a task is created or updated, mark it as pending sync if it has a Google mapping
  IF NEW.google_task_id IS NOT NULL AND OLD IS DISTINCT FROM NULL THEN
    NEW.sync_status = 'pending_sync';
  END IF;
  
  -- Update last_synced_at when sync_status changes to 'synced'
  IF NEW.sync_status = 'synced' AND (OLD IS NULL OR OLD.sync_status != 'synced') THEN
    NEW.last_synced_at = NOW();
  END IF;
  
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_task_sync_status"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_template_performance"("template_id_param" "uuid", "opened" boolean DEFAULT false, "clicked" boolean DEFAULT false, "replied" boolean DEFAULT false, "recovered" boolean DEFAULT false, "response_time_hours" numeric DEFAULT NULL::numeric) RETURNS "void"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  current_template RECORD;
  new_response_rate INTEGER;
  new_recovery_rate INTEGER;
  new_avg_response_time NUMERIC;
BEGIN
  -- Get current template metrics
  SELECT * INTO current_template FROM intervention_templates WHERE id = template_id_param;

  IF NOT FOUND THEN
    RETURN;
  END IF;

  -- Update last_used_at
  UPDATE intervention_templates
  SET last_used_at = NOW()
  WHERE id = template_id_param;

  -- Increment counters
  UPDATE intervention_templates
  SET
    times_sent = times_sent + 1,
    times_opened = CASE WHEN opened THEN times_opened + 1 ELSE times_opened END,
    times_clicked = CASE WHEN clicked THEN times_clicked + 1 ELSE times_clicked END,
    times_replied = CASE WHEN replied THEN times_replied + 1 ELSE times_replied END,
    times_recovered = CASE WHEN recovered THEN times_recovered + 1 ELSE times_recovered END
  WHERE id = template_id_param;

  -- Recalculate rates
  SELECT
    CASE WHEN times_sent > 0 THEN ROUND((times_replied::NUMERIC / times_sent::NUMERIC) * 100) ELSE 0 END,
    CASE WHEN times_sent > 0 THEN ROUND((times_recovered::NUMERIC / times_sent::NUMERIC) * 100) ELSE 0 END
  INTO new_response_rate, new_recovery_rate
  FROM intervention_templates
  WHERE id = template_id_param;

  -- Calculate new average response time if provided
  IF response_time_hours IS NOT NULL THEN
    SELECT
      CASE
        WHEN avg_response_time_hours IS NULL THEN response_time_hours
        ELSE ((avg_response_time_hours * (times_replied - 1)) + response_time_hours) / times_replied
      END
    INTO new_avg_response_time
    FROM intervention_templates
    WHERE id = template_id_param;

    UPDATE intervention_templates
    SET avg_response_time_hours = new_avg_response_time
    WHERE id = template_id_param;
  END IF;

  -- Update rates
  UPDATE intervention_templates
  SET
    response_rate_percent = new_response_rate,
    recovery_rate_percent = new_recovery_rate
  WHERE id = template_id_param;
END;
$$;

-- ALTER FUNCTION "public"."update_template_performance"("template_id_param" "uuid", "opened" boolean, "clicked" boolean, "replied" boolean, "recovered" boolean, "response_time_hours" numeric) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_template_performance_on_intervention_change"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Only update if we have a template_id
  IF NEW.template_id IS NULL THEN
    RETURN NEW;
  END IF;

  -- Update based on status changes
  IF OLD.status <> NEW.status THEN
    -- Opened
    IF NEW.status = 'opened' AND OLD.status <> 'opened' THEN
      PERFORM update_template_performance(NEW.template_id, opened => TRUE);
    END IF;

    -- Clicked
    IF NEW.status = 'clicked' AND OLD.status <> 'clicked' THEN
      PERFORM update_template_performance(NEW.template_id, clicked => TRUE);
    END IF;

    -- Replied
    IF NEW.status = 'replied' AND OLD.status <> 'replied' THEN
      -- Calculate response time if we have sent_at and replied_at
      IF NEW.sent_at IS NOT NULL AND NEW.replied_at IS NOT NULL THEN
        PERFORM update_template_performance(
          NEW.template_id,
          replied => TRUE,
          response_time_hours => EXTRACT(EPOCH FROM (NEW.replied_at - NEW.sent_at)) / 3600
        );
      ELSE
        PERFORM update_template_performance(NEW.template_id, replied => TRUE);
      END IF;
    END IF;

    -- Recovered
    IF NEW.status = 'recovered' AND OLD.status <> 'recovered' THEN
      PERFORM update_template_performance(NEW.template_id, recovered => TRUE);
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_template_performance_on_intervention_change"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_thread_metadata"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
     BEGIN
         UPDATE email_threads
         SET
             last_message_at = NEW.received_at,
             message_count = message_count + 1,
             is_read = CASE WHEN NEW.is_read THEN is_read ELSE false END
         WHERE id = NEW.thread_id;
         RETURN NEW;
     END;
     $$;

-- ALTER FUNCTION "public"."update_thread_metadata"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_transcript_retry_job_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_transcript_retry_job_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_user_ai_feature_settings_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_user_ai_feature_settings_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_user_coaching_preferences_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_user_coaching_preferences_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_user_engagement_metrics_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_user_engagement_metrics_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_user_sync_status_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_user_sync_status_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_user_timezone"("p_user_id" "uuid", "p_timezone" "text") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
BEGIN
  -- Update user_settings preferences
  INSERT INTO user_settings (user_id, preferences)
  VALUES (p_user_id, jsonb_build_object('timezone', p_timezone))
  ON CONFLICT (user_id) 
  DO UPDATE SET 
    preferences = user_settings.preferences || jsonb_build_object('timezone', p_timezone),
    updated_at = NOW();
  
  -- Also update calendar_calendars if primary calendar exists
  UPDATE calendar_calendars
  SET timezone = p_timezone
  WHERE user_id = p_user_id
    AND external_id = 'primary';
END;
$$;

-- ALTER FUNCTION "public"."update_user_timezone"("p_user_id" "uuid", "p_timezone" "text") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."update_user_timezone"("p_user_id" "uuid", "p_timezone" "text") IS 'Updates user timezone preference in user_settings and calendar_calendars';

CREATE OR REPLACE FUNCTION "public"."update_waitlist_email_template_timestamp"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_waitlist_email_template_timestamp"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_workflow_results_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public'
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."update_workflow_results_updated_at"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."update_workflow_statistics"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
     BEGIN
       -- Only update on INSERT or when status changes to success/failed
       IF TG_OP = 'INSERT' OR
          (TG_OP = 'UPDATE' AND OLD.status != NEW.status AND
           NEW.status IN ('success', 'failed')) THEN

         UPDATE user_automation_rules
         SET
           execution_count = execution_count + 1,
           success_count = CASE
             WHEN NEW.status = 'success' THEN success_count + 1
             ELSE success_count
           END,
           failure_count = CASE
             WHEN NEW.status = 'failed' THEN failure_count + 1
             ELSE failure_count
           END,
           last_execution_at = COALESCE(NEW.executed_at, NOW()),
           last_execution_status = NEW.status,
           last_error_message = CASE
             WHEN NEW.status = 'failed' THEN NEW.error_message
             ELSE NULL
           END,
           avg_execution_time_ms = (
             SELECT AVG(execution_time_ms)::INTEGER
             FROM automation_executions
             WHERE rule_id = NEW.rule_id
             AND status IN ('success', 'failed')
             AND execution_time_ms IS NOT NULL
           ),
           updated_at = NOW()
         WHERE id = NEW.rule_id;
       END IF;

       RETURN NEW;
     END;
     $$;

-- ALTER FUNCTION "public"."update_workflow_statistics"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."upsert_deal_clarity_score"("p_deal_id" "uuid", "p_org_id" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_clarity RECORD;
  v_plan RECORD;
  v_momentum INTEGER;
BEGIN
  -- Calculate clarity
  SELECT * INTO v_clarity FROM calculate_deal_clarity_score(p_deal_id);

  -- Calculate close plan progress
  SELECT * INTO v_plan FROM calculate_close_plan_progress(p_deal_id);

  -- Calculate momentum
  v_momentum := calculate_deal_momentum_score(p_deal_id);

  -- Upsert
  INSERT INTO deal_clarity_scores (
    deal_id, org_id, clarity_score,
    next_step_score, economic_buyer_score, champion_score,
    success_metric_score, risks_score,
    close_plan_completed, close_plan_total, close_plan_overdue,
    momentum_score, last_calculated_at
  )
  VALUES (
    p_deal_id, p_org_id, v_clarity.clarity_score,
    v_clarity.next_step_score, v_clarity.economic_buyer_score, v_clarity.champion_score,
    v_clarity.success_metric_score, v_clarity.risks_score,
    v_plan.completed, v_plan.total, v_plan.overdue,
    v_momentum, NOW()
  )
  ON CONFLICT (deal_id) DO UPDATE SET
    clarity_score = EXCLUDED.clarity_score,
    next_step_score = EXCLUDED.next_step_score,
    economic_buyer_score = EXCLUDED.economic_buyer_score,
    champion_score = EXCLUDED.champion_score,
    success_metric_score = EXCLUDED.success_metric_score,
    risks_score = EXCLUDED.risks_score,
    close_plan_completed = EXCLUDED.close_plan_completed,
    close_plan_total = EXCLUDED.close_plan_total,
    close_plan_overdue = EXCLUDED.close_plan_overdue,
    momentum_score = EXCLUDED.momentum_score,
    last_calculated_at = NOW(),
    updated_at = NOW();
END;
$$;

-- ALTER FUNCTION "public"."upsert_deal_clarity_score"("p_deal_id" "uuid", "p_org_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."upsert_organization_context"("p_org_id" "uuid", "p_context_key" "text", "p_value" "jsonb", "p_value_type" "text", "p_source" "text", "p_confidence" numeric DEFAULT 1.00) RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    AS $$
DECLARE
  v_result_id UUID;
BEGIN
  INSERT INTO organization_context (
    organization_id,
    context_key,
    value,
    value_type,
    source,
    confidence
  )
  VALUES (
    p_org_id,
    p_context_key,
    p_value,
    p_value_type,
    p_source,
    p_confidence
  )
  ON CONFLICT (organization_id, context_key)
  DO UPDATE SET
    value = EXCLUDED.value,
    value_type = EXCLUDED.value_type,
    source = EXCLUDED.source,
    confidence = EXCLUDED.confidence,
    updated_at = now()
  RETURNING id INTO v_result_id;

  RETURN v_result_id;
END;
$$;

-- ALTER FUNCTION "public"."upsert_organization_context"("p_org_id" "uuid", "p_context_key" "text", "p_value" "jsonb", "p_value_type" "text", "p_source" "text", "p_confidence" numeric) OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."user_org_ids"("p_user_id" "uuid") RETURNS SETOF "uuid"
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
    SELECT org_id FROM organization_memberships WHERE user_id = p_user_id;
  $$;

-- ALTER FUNCTION "public"."user_org_ids"("p_user_id" "uuid") OWNER TO "postgres";

-- ALTER FUNCTION "public"."user_owns_execution"("p_execution_id" "uuid") OWNER TO "postgres";

-- ALTER FUNCTION "public"."user_owns_workflow"("p_workflow_id" "uuid") OWNER TO "postgres";

-- ALTER FUNCTION "public"."user_shares_org_with"("target_user_id" "uuid") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."users_share_organization"("user_a" "uuid", "user_b" "uuid") RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.organization_memberships om_a
    INNER JOIN public.organization_memberships om_b
      ON om_a.org_id = om_b.org_id
    WHERE om_a.user_id = user_a
      AND om_b.user_id = user_b
      AND om_a.user_id != om_b.user_id
  );
$$;

-- ALTER FUNCTION "public"."users_share_organization"("user_a" "uuid", "user_b" "uuid") OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."users_share_organization"("user_a" "uuid", "user_b" "uuid") IS 'Returns true if two users share at least one organization (SECURITY DEFINER to bypass RLS)';

CREATE OR REPLACE FUNCTION "public"."validate_api_key"("params" "jsonb") RETURNS TABLE("is_valid" boolean, "user_id" "uuid", "permissions" "text"[], "rate_limit" integer, "is_expired" boolean, "is_active" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  key_text_param TEXT;
  validation_result RECORD;
  perm_array TEXT[];
BEGIN
  -- Extract key_text from the JSONB parameter
  key_text_param := params->>'key_text';
  
  -- Call the text version
  SELECT * INTO validation_result FROM validate_api_key(key_text_param) LIMIT 1;
  
  -- Convert JSONB permissions to TEXT array
  IF validation_result.permissions IS NOT NULL THEN
    SELECT array(SELECT jsonb_array_elements_text(validation_result.permissions)) INTO perm_array;
  ELSE
    perm_array := ARRAY[]::TEXT[];
  END IF;
  
  -- Return with TEXT array permissions
  RETURN QUERY SELECT 
    validation_result.is_valid,
    validation_result.user_id,
    perm_array,
    validation_result.rate_limit,
    validation_result.is_expired,
    validation_result.is_active;
END $$;

-- ALTER FUNCTION "public"."validate_api_key"("params" "jsonb") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."validate_api_key"("key_text" "text") RETURNS TABLE("is_valid" boolean, "user_id" "uuid", "permissions" "jsonb", "rate_limit" integer, "is_expired" boolean, "is_active" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  key_record RECORD;
  key_hash_computed TEXT;
BEGIN
  -- Compute hash of provided key
  key_hash_computed := encode(digest(key_text, 'sha256'), 'hex');
  
  -- Look up the API key using qualified column names
  SELECT 
    ak.id,
    ak.name,
    ak.key_hash,
    ak.user_id,
    ak.permissions,
    ak.rate_limit,
    ak.expires_at,
    ak.is_active
  INTO key_record 
  FROM api_keys ak
  WHERE ak.key_hash = key_hash_computed 
    AND ak.is_active = true;
  
  IF NOT FOUND THEN
    -- Invalid key
    RETURN QUERY SELECT false, NULL::UUID, NULL::JSONB, 0, false, false;
    RETURN;
  END IF;
  
  -- Check expiration
  IF key_record.expires_at IS NOT NULL AND key_record.expires_at < NOW() THEN
    -- Expired key
    RETURN QUERY SELECT false, key_record.user_id, key_record.permissions, key_record.rate_limit, true, key_record.is_active;
    RETURN;
  END IF;
  
  -- Valid key
  RETURN QUERY SELECT true, key_record.user_id, key_record.permissions, key_record.rate_limit, false, key_record.is_active;
END $$;

-- ALTER FUNCTION "public"."validate_api_key"("key_text" "text") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."validate_api_key_simple"("key_text" "text") RETURNS TABLE("is_valid" boolean, "user_id" "uuid", "permissions" "jsonb", "rate_limit" integer, "is_expired" boolean, "is_active" boolean)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
     DECLARE
       key_hash_value TEXT;
       api_key_record RECORD;
     BEGIN
       -- Validate input
       IF key_text IS NULL OR key_text = '' THEN
         RETURN QUERY SELECT FALSE, NULL::UUID, '[]'::JSONB, 0, FALSE, FALSE;
         RETURN;
       END IF;

       -- Calculate hash
       key_hash_value := encode(digest(key_text, 'sha256'), 'hex');

       -- Look up the API key
       SELECT INTO api_key_record
         ak.user_id,
         ak.rate_limit,
         ak.permissions,
         ak.is_active,
         ak.expires_at
       FROM api_keys ak
       WHERE ak.key_hash = key_hash_value;

       IF NOT FOUND THEN
         RETURN QUERY SELECT FALSE, NULL::UUID, '[]'::JSONB, 0, FALSE, FALSE;
         RETURN;
       END IF;

       -- Check if key is active
       IF NOT api_key_record.is_active THEN
         RETURN QUERY SELECT FALSE, api_key_record.user_id, api_key_record.permissions, COALESCE(api_key_record.rate_limit, 0), FALSE, FALSE;
         RETURN;
       END IF;

       -- Return success
       RETURN QUERY SELECT
         TRUE,
         api_key_record.user_id,
         COALESCE(api_key_record.permissions, '[]'::jsonb),
         COALESCE(api_key_record.rate_limit, 1000),
         FALSE,
         TRUE;
     END $$;

-- ALTER FUNCTION "public"."validate_api_key_simple"("key_text" "text") OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."validate_deal_split_percentages"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO ''
    AS $$
DECLARE
  total_percentage DECIMAL(5,2);
BEGIN
  -- Calculate total percentage for this deal (excluding the current row if updating)
  SELECT COALESCE(SUM(percentage), 0) INTO total_percentage
  FROM deal_splits 
  WHERE deal_id = NEW.deal_id 
    AND (TG_OP = 'INSERT' OR id != NEW.id);
  
  -- Add the new/updated percentage
  total_percentage := total_percentage + NEW.percentage;
  
  -- Check if total exceeds 100%
  IF total_percentage > 100 THEN
    RAISE EXCEPTION 'Total split percentages cannot exceed 100%%. Current total would be: %', total_percentage;
  END IF;
  
  RETURN NEW;
END;
$$;

-- ALTER FUNCTION "public"."validate_deal_split_percentages"() OWNER TO "postgres";

CREATE OR REPLACE FUNCTION "public"."validate_org_access"("p_org_id" "uuid", "p_require_write" boolean DEFAULT false) RETURNS boolean
    LANGUAGE "plpgsql" STABLE SECURITY DEFINER
    AS $$
BEGIN
  IF p_org_id IS NULL THEN
    RAISE EXCEPTION 'Organization ID is required';
  END IF;

  IF p_require_write THEN
    IF NOT can_write_to_org(p_org_id) THEN
      RAISE EXCEPTION 'Write access denied to organization %', p_org_id;
    END IF;
  ELSE
    IF NOT can_access_org_data(p_org_id) THEN
      RAISE EXCEPTION 'Read access denied to organization %', p_org_id;
    END IF;
  END IF;

  RETURN true;
END;
$$;

-- ALTER FUNCTION "public"."validate_org_access"("p_org_id" "uuid", "p_require_write" boolean) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."validate_org_access"("p_org_id" "uuid", "p_require_write" boolean) IS 'Validates user has access to organization, throws exception if not';

CREATE OR REPLACE FUNCTION "public"."was_email_sent"("p_user_id" "uuid", "p_email_type" "text", "p_hours_window" integer DEFAULT 24) RETURNS boolean
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM email_sends
    WHERE user_id = p_user_id
    AND email_type = p_email_type
    AND sent_at >= NOW() - (p_hours_window || ' hours')::INTERVAL
    AND status = 'sent'
  );
END;
$$;

-- ALTER FUNCTION "public"."was_email_sent"("p_user_id" "uuid", "p_email_type" "text", "p_hours_window" integer) OWNER TO "postgres";

-- COMMENT ON FUNCTION "public"."was_email_sent"("p_user_id" "uuid", "p_email_type" "text", "p_hours_window" integer) IS 'Check if an email was already sent to a user within a time window';

CREATE TABLE IF NOT EXISTS "public"."action_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "contact_id" "uuid",
    "deal_id" "uuid",
    "meeting_id" "uuid",
    "user_id" "uuid" NOT NULL,
    "assignee_id" "uuid",
    "text" "text" NOT NULL,
    "completed" boolean DEFAULT false,
    "due_date" timestamp with time zone,
    "priority" "text" DEFAULT 'medium'::"text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "action_items_priority_check" CHECK (("priority" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text"])))
);

-- ALTER TABLE "public"."action_items" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."user_activation_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid",
    "event_type" "text" NOT NULL,
    "event_data" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."user_activation_events" OWNER TO "postgres";

COMMENT ON TABLE "public"."user_activation_events" IS 'Detailed activation event log for tracking user journey milestones';

CREATE TABLE IF NOT EXISTS "public"."user_onboarding_progress" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "onboarding_step" "text" DEFAULT 'welcome'::"text",
    "onboarding_completed_at" timestamp with time zone,
    "skipped_onboarding" boolean DEFAULT false,
    "fathom_connected" boolean DEFAULT false,
    "first_meeting_synced" boolean DEFAULT false,
    "first_proposal_generated" boolean DEFAULT false,
    "features_discovered" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "first_summary_viewed" boolean DEFAULT false,
    "first_summary_viewed_at" timestamp with time zone,
    "activation_completed_at" timestamp with time zone
);

-- ALTER TABLE "public"."user_onboarding_progress" OWNER TO "postgres";

COMMENT ON TABLE "public"."user_onboarding_progress" IS 'Tracks user onboarding progress through the Meetings feature setup flow';

COMMENT ON COLUMN "public"."user_onboarding_progress"."first_summary_viewed" IS 'NORTH STAR: True when user views their first meeting summary';

COMMENT ON COLUMN "public"."user_onboarding_progress"."first_summary_viewed_at" IS 'Timestamp of first summary view - key activation metric';

COMMENT ON COLUMN "public"."user_onboarding_progress"."activation_completed_at" IS 'When user completed full activation funnel';

CREATE OR REPLACE VIEW "public"."activation_funnel_metrics" WITH ("security_invoker"='true') AS
 SELECT ( SELECT "count"(*) AS "count"
           FROM "public"."profiles") AS "total_users",
    ( SELECT "count"(*) AS "count"
           FROM "public"."user_onboarding_progress") AS "users_with_progress",
    ( SELECT "count"(*) AS "count"
           FROM "public"."user_onboarding_progress"
          WHERE ("user_onboarding_progress"."fathom_connected" = true)) AS "fathom_connected_count",
    ( SELECT "count"(*) AS "count"
           FROM "public"."user_onboarding_progress"
          WHERE ("user_onboarding_progress"."first_meeting_synced" = true)) AS "first_meeting_synced_count",
    ( SELECT "count"(*) AS "count"
           FROM "public"."user_onboarding_progress"
          WHERE ("user_onboarding_progress"."first_summary_viewed" = true)) AS "first_summary_viewed_count",
    ( SELECT "count"(*) AS "count"
           FROM "public"."user_onboarding_progress"
          WHERE ("user_onboarding_progress"."first_proposal_generated" = true)) AS "first_proposal_generated_count",
    ( SELECT "count"(*) AS "count"
           FROM "public"."user_onboarding_progress"
          WHERE ("user_onboarding_progress"."activation_completed_at" IS NOT NULL)) AS "fully_activated_count",
    ( SELECT "count"(*) AS "count"
           FROM "public"."user_onboarding_progress"
          WHERE ("user_onboarding_progress"."onboarding_completed_at" IS NOT NULL)) AS "onboarding_completed_count",
    ( SELECT "count"(*) AS "count"
           FROM "public"."user_onboarding_progress"
          WHERE ("user_onboarding_progress"."skipped_onboarding" = true)) AS "skipped_onboarding_count",
    ( SELECT "count"(*) AS "count"
           FROM "public"."user_activation_events"
          WHERE ("user_activation_events"."created_at" >= CURRENT_DATE)) AS "activations_today",
    ( SELECT "count"(*) AS "count"
           FROM "public"."user_activation_events"
          WHERE ("user_activation_events"."created_at" >= (CURRENT_DATE - '7 days'::interval))) AS "activations_this_week";

-- ALTER VIEW "public"."activation_funnel_metrics" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."activities" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "type" "text" NOT NULL,
    "status" "text" DEFAULT 'completed'::"text" NOT NULL,
    "priority" "text" DEFAULT 'medium'::"text" NOT NULL,
    "client_name" "text" NOT NULL,
    "sales_rep" "text" NOT NULL,
    "details" "text",
    "amount" numeric(12,2),
    "date" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "avatar_url" "text",
    "quantity" integer DEFAULT 1 NOT NULL,
    "contact_identifier" "text",
    "contact_identifier_type" "text",
    "is_processed" boolean DEFAULT false,
    "deal_id" "uuid",
    "is_split" boolean DEFAULT false,
    "original_activity_id" "uuid",
    "split_percentage" numeric(5,2),
    "owner_id" "uuid",
    "contact_id" "uuid",
    "company_id" "uuid",
    "subject" "text",
    "auto_matched" boolean DEFAULT false,
    "outbound_type" "text",
    "proposal_date" "date",
    "is_rebooking" boolean DEFAULT false,
    "is_self_generated" boolean DEFAULT false,
    "sale_date" "date",
    "execution_order" integer DEFAULT 0,
    "meeting_id" "uuid",
    "next_actions_generated_at" timestamp with time zone,
    "next_actions_count" integer DEFAULT 0,
    "savvycal_booking_id" "text",
    "savvycal_link_id" "text",
    "clerk_org_id" "text",
    CONSTRAINT "activities_outbound_type_check" CHECK (("outbound_type" = ANY (ARRAY['email'::"text", 'linkedin'::"text", 'call'::"text"]))),
    CONSTRAINT "activities_priority_check" CHECK (("priority" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text"]))),
    CONSTRAINT "activities_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'completed'::"text", 'cancelled'::"text", 'no_show'::"text"]))),
    CONSTRAINT "activities_type_check" CHECK (("type" = ANY (ARRAY['sale'::"text", 'outbound'::"text", 'meeting'::"text", 'proposal'::"text"])))
);

-- ALTER TABLE "public"."activities" OWNER TO "postgres";

COMMENT ON COLUMN "public"."activities"."quantity" IS 'Number of activities performed (default 1)';

COMMENT ON COLUMN "public"."activities"."contact_identifier" IS 'Contact email, phone, or name associated with the activity';

COMMENT ON COLUMN "public"."activities"."contact_identifier_type" IS 'Type of contact identifier (email, phone, name)';

COMMENT ON COLUMN "public"."activities"."deal_id" IS 'Links activity to a specific deal';

COMMENT ON COLUMN "public"."activities"."is_split" IS 'Indicates if this activity is a split from another activity due to deal splitting';

COMMENT ON COLUMN "public"."activities"."original_activity_id" IS 'Reference to the original activity this was split from';

COMMENT ON COLUMN "public"."activities"."split_percentage" IS 'The percentage of the deal split assigned to this user';

COMMENT ON COLUMN "public"."activities"."outbound_type" IS 'Type of outbound activity: email, linkedin, or call';

COMMENT ON COLUMN "public"."activities"."proposal_date" IS 'Date when proposal was sent';

COMMENT ON COLUMN "public"."activities"."is_rebooking" IS 'Whether this meeting was rebooked from a previous no-show or 
  cancellation';

COMMENT ON COLUMN "public"."activities"."is_self_generated" IS 'Whether this meeting was self-generated by the sales rep';

COMMENT ON COLUMN "public"."activities"."sale_date" IS 'Actual date of sale completion (separate from activity date)';

COMMENT ON COLUMN "public"."activities"."meeting_id" IS 'Foreign key to meetings table for Fathom meeting integration';

COMMENT ON COLUMN "public"."activities"."savvycal_booking_id" IS 'SavvyCal event ID (from CSV id column)';

COMMENT ON COLUMN "public"."activities"."savvycal_link_id" IS 'SavvyCal booking link ID (from CSV link_id column) for source mapping';

COMMENT ON CONSTRAINT "activities_status_check" ON "public"."activities" IS 'Ensures activities status is one of: pending, completed, cancelled, no_show';

CREATE OR REPLACE VIEW "public"."activities_with_profile" WITH ("security_invoker"='true') AS
 SELECT "a"."id",
    "a"."user_id",
    "a"."type",
    "a"."status",
    "a"."priority",
    "a"."client_name",
    "a"."sales_rep",
    "a"."details",
    "a"."amount",
    "a"."date",
    "a"."created_at",
    "a"."updated_at",
    "a"."avatar_url",
    "a"."quantity",
    "a"."contact_identifier",
    "a"."contact_identifier_type",
    "a"."is_processed",
    "a"."deal_id",
    "a"."is_split",
    "a"."original_activity_id",
    "a"."split_percentage",
    "a"."owner_id",
    "a"."contact_id",
    "a"."company_id",
    "a"."subject",
    "a"."auto_matched",
    "a"."outbound_type",
    "a"."proposal_date",
    "a"."is_rebooking",
    "a"."is_self_generated",
    "a"."sale_date",
    "a"."execution_order",
    "a"."meeting_id",
    "a"."next_actions_generated_at",
    "a"."next_actions_count",
    "a"."savvycal_booking_id",
    "a"."savvycal_link_id",
    "a"."clerk_org_id",
    "p"."id" AS "profile_id",
    COALESCE((("p"."first_name" || ' '::"text") || "p"."last_name"), "p"."email") AS "profile_full_name",
    "p"."avatar_url" AS "profile_avatar_url"
   FROM ("public"."activities" "a"
     LEFT JOIN "public"."profiles" "p" ON (("a"."user_id" = "p"."id")));

-- ALTER VIEW "public"."activities_with_profile" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."activity_sync_rules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "activity_type" "text" NOT NULL,
    "min_priority" "text" DEFAULT 'medium'::"text",
    "auto_create_deal" boolean DEFAULT false,
    "target_stage_name" "text",
    "owner_id" "uuid" NOT NULL,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "activity_sync_rules_activity_type_check" CHECK (("activity_type" = ANY (ARRAY['sale'::"text", 'outbound'::"text", 'meeting'::"text", 'proposal'::"text"]))),
    CONSTRAINT "activity_sync_rules_min_priority_check" CHECK (("min_priority" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text"])))
);

-- ALTER TABLE "public"."activity_sync_rules" OWNER TO "postgres";

COMMENT ON TABLE "public"."activity_sync_rules" IS 'Rules for automatically creating and managing deals from activities';

CREATE TABLE IF NOT EXISTS "public"."ai_cost_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid",
    "user_id" "uuid",
    "provider" "text" NOT NULL,
    "model" "text" NOT NULL,
    "feature" "text",
    "input_tokens" integer NOT NULL,
    "output_tokens" integer NOT NULL,
    "estimated_cost" numeric(10,6) NOT NULL,
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "ai_cost_events_provider_check" CHECK (("provider" = ANY (ARRAY['anthropic'::"text", 'gemini'::"text"])))
);

-- ALTER TABLE "public"."ai_cost_events" OWNER TO "postgres";

COMMENT ON TABLE "public"."ai_cost_events" IS 'Log of all AI API calls with token usage and estimated costs';

COMMENT ON COLUMN "public"."ai_cost_events"."feature" IS 'Feature/use case that triggered this API call (e.g., transcript_analysis, copilot)';

COMMENT ON COLUMN "public"."ai_cost_events"."metadata" IS 'Additional context about the API call (workflow_id, meeting_id, etc.)';

CREATE TABLE IF NOT EXISTS "public"."ai_feedback" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "suggestion_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "action" "text" NOT NULL,
    "original_content" "text",
    "edited_content" "text",
    "edit_delta" "jsonb",
    "action_type" "text" NOT NULL,
    "confidence_at_generation" numeric(5,2) NOT NULL,
    "context_quality_at_generation" numeric(5,2),
    "outcome_measured" boolean DEFAULT false,
    "outcome_positive" boolean,
    "outcome_type" "text",
    "time_to_decision_seconds" numeric(10,2),
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "ai_feedback_action_check" CHECK (("action" = ANY (ARRAY['approved'::"text", 'edited'::"text", 'rejected'::"text", 'ignored'::"text"]))),
    CONSTRAINT "valid_action_type" CHECK (("action_type" = ANY (ARRAY['send_email'::"text", 'draft_follow_up'::"text", 'create_task'::"text", 'log_activity'::"text", 'update_deal'::"text", 'schedule_meeting'::"text", 'send_slack_message'::"text"])))
);

-- ALTER TABLE "public"."ai_feedback" OWNER TO "postgres";

COMMENT ON TABLE "public"."ai_feedback" IS 'Records all feedback on AI suggestions for learning loop';

COMMENT ON COLUMN "public"."ai_feedback"."edit_delta" IS 'JSON object containing analysis of what the user changed: tone_shift, length_change, added_cta, etc.';

COMMENT ON COLUMN "public"."ai_feedback"."outcome_measured" IS 'Whether we have measured the outcome of this suggestion (e.g., reply received)';

CREATE TABLE IF NOT EXISTS "public"."ai_insights" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "contact_id" "uuid",
    "deal_id" "uuid",
    "user_id" "uuid" NOT NULL,
    "insight_type" "text" NOT NULL,
    "insight_text" "text" NOT NULL,
    "priority" "text" DEFAULT 'medium'::"text" NOT NULL,
    "suggested_actions" "jsonb" DEFAULT '[]'::"jsonb",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "expires_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "ai_insights_contact_or_deal" CHECK (((("contact_id" IS NOT NULL) AND ("deal_id" IS NULL)) OR (("contact_id" IS NULL) AND ("deal_id" IS NOT NULL)) OR (("contact_id" IS NOT NULL) AND ("deal_id" IS NOT NULL)))),
    CONSTRAINT "ai_insights_insight_type_check" CHECK (("insight_type" = ANY (ARRAY['engagement'::"text", 'risk'::"text", 'opportunity'::"text", 'custom'::"text"]))),
    CONSTRAINT "ai_insights_priority_check" CHECK (("priority" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text"])))
);

-- ALTER TABLE "public"."ai_insights" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."ai_prompt_template_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "template_id" "uuid",
    "system_prompt" "text",
    "user_prompt" "text",
    "model" "text",
    "temperature" numeric(3,2),
    "max_tokens" integer,
    "version" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "change_reason" "text"
);

-- ALTER TABLE "public"."ai_prompt_template_history" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."ai_prompt_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid",
    "user_id" "uuid",
    "category" "text" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "system_prompt" "text",
    "user_prompt" "text",
    "model" "text" DEFAULT 'claude-haiku-4-5-20251001'::"text",
    "temperature" numeric(3,2) DEFAULT 0.7,
    "max_tokens" integer DEFAULT 2048,
    "is_public" boolean DEFAULT false,
    "is_default" boolean DEFAULT false,
    "version" integer DEFAULT 1,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    CONSTRAINT "has_content" CHECK ((("system_prompt" IS NOT NULL) OR ("user_prompt" IS NOT NULL))),
    CONSTRAINT "valid_max_tokens" CHECK ((("max_tokens" > 0) AND ("max_tokens" <= 128000))),
    CONSTRAINT "valid_temperature" CHECK ((("temperature" >= (0)::numeric) AND ("temperature" <= (2)::numeric)))
);

-- ALTER TABLE "public"."ai_prompt_templates" OWNER TO "postgres";

COMMENT ON TABLE "public"."ai_prompt_templates" IS 'Stores customizable AI prompt templates for various features. Supports user overrides, org defaults, and system templates.';

COMMENT ON COLUMN "public"."ai_prompt_templates"."category" IS 'Feature key matching promptLoader.ts categories (e.g., email_analysis, transcript_analysis)';

COMMENT ON COLUMN "public"."ai_prompt_templates"."is_public" IS 'If true, this template is visible to all users in the organization';

COMMENT ON COLUMN "public"."ai_prompt_templates"."is_default" IS 'If true, this is the default template for the org (overrides system default)';

CREATE TABLE IF NOT EXISTS "public"."ai_usage_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "workflow_id" "uuid",
    "provider" character varying(50),
    "model" character varying(100),
    "prompt_tokens" integer,
    "completion_tokens" integer,
    "total_tokens" integer,
    "cost_estimate" numeric(10,6),
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"())
);

-- ALTER TABLE "public"."ai_usage_logs" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."api_key_usage" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "api_key_id" "uuid" NOT NULL,
    "endpoint" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "ip_address" "inet",
    "user_agent" "text"
);

-- ALTER TABLE "public"."api_key_usage" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."api_keys" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "key_hash" "text" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "permissions" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "rate_limit" integer DEFAULT 1000 NOT NULL,
    "last_used_at" timestamp with time zone,
    "expires_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "key_preview" "text" DEFAULT 'preview'::"text",
    "usage_count" integer DEFAULT 0,
    "last_used" timestamp with time zone,
    "is_active" boolean DEFAULT true NOT NULL
);

-- ALTER TABLE "public"."api_keys" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."api_monitor_improvements" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" "text" NOT NULL,
    "description" "text" NOT NULL,
    "shipped_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "expected_delta_requests_per_day" integer,
    "expected_delta_error_rate" numeric(5,2),
    "actual_delta_requests_per_day" integer,
    "actual_delta_error_rate" numeric(5,2),
    "actual_delta_requests_per_user_per_day" numeric(10,2),
    "before_window_start" timestamp with time zone,
    "before_window_end" timestamp with time zone,
    "after_window_start" timestamp with time zone,
    "after_window_end" timestamp with time zone,
    "code_changes" "jsonb" DEFAULT '[]'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

-- ALTER TABLE "public"."api_monitor_improvements" OWNER TO "postgres";

COMMENT ON TABLE "public"."api_monitor_improvements" IS 'Log of API optimizations. Actual deltas are computed by comparing rollups before/after shipped_at using compute_improvement_deltas() function.';

CREATE TABLE IF NOT EXISTS "public"."api_monitor_rollups_daily" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "date" "date" NOT NULL,
    "user_id" "uuid",
    "total_requests" integer DEFAULT 0 NOT NULL,
    "total_errors" integer DEFAULT 0 NOT NULL,
    "error_rate" numeric(5,2) DEFAULT 0 NOT NULL,
    "top_endpoints" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "error_breakdown" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

-- ALTER TABLE "public"."api_monitor_rollups_daily" OWNER TO "postgres";

COMMENT ON TABLE "public"."api_monitor_rollups_daily" IS 'Daily per-user and total API request rollups. Used for before/after comparisons.';

CREATE TABLE IF NOT EXISTS "public"."api_monitor_snapshots" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "snapshot_time" timestamp with time zone DEFAULT "now"() NOT NULL,
    "time_bucket_start" timestamp with time zone NOT NULL,
    "time_bucket_end" timestamp with time zone NOT NULL,
    "bucket_type" "text" NOT NULL,
    "total_requests" integer DEFAULT 0 NOT NULL,
    "total_errors" integer DEFAULT 0 NOT NULL,
    "error_rate" numeric(5,2) DEFAULT 0 NOT NULL,
    "top_endpoints" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "top_errors" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "top_callers" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "suspected_bursts" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "source" "text" NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "api_monitor_snapshots_bucket_type_check" CHECK (("bucket_type" = ANY (ARRAY['5m'::"text", '1h'::"text", '1d'::"text"]))),
    CONSTRAINT "api_monitor_snapshots_source_check" CHECK (("source" = ANY (ARRAY['supabase_logs'::"text", 'app_instrumented'::"text"])))
);

-- ALTER TABLE "public"."api_monitor_snapshots" OWNER TO "postgres";

COMMENT ON TABLE "public"."api_monitor_snapshots" IS 'Aggregated API metrics by time bucket (5m/1h/1d). Retained for 7 days.';

CREATE TABLE IF NOT EXISTS "public"."api_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "api_key_id" "uuid",
    "endpoint" "text" NOT NULL,
    "method" "text" NOT NULL,
    "status_code" integer,
    "response_time_ms" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "user_id" "uuid"
);

-- ALTER TABLE "public"."api_requests" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."app_settings" (
    "key" "text" NOT NULL,
    "value" "text" NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "description" "text"
);

-- ALTER TABLE "public"."app_settings" OWNER TO "postgres";

COMMENT ON TABLE "public"."app_settings" IS 'Application-wide configuration settings (key-value store). Includes platform defaults for MeetingBaaS bot branding.';

COMMENT ON COLUMN "public"."app_settings"."key" IS 'Unique setting key/name';

COMMENT ON COLUMN "public"."app_settings"."value" IS 'Setting value stored as text (can be JSON for complex values)';

COMMENT ON COLUMN "public"."app_settings"."updated_at" IS 'Timestamp of last update';

CREATE TABLE IF NOT EXISTS "public"."organization_memberships" (
    "org_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "role" "text" DEFAULT 'member'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "organization_memberships_role_check" CHECK (("role" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'member'::"text", 'readonly'::"text"])))
);

-- ALTER TABLE "public"."organization_memberships" OWNER TO "postgres";

COMMENT ON TABLE "public"."organization_memberships" IS 'Links users to organizations with roles';

CREATE TABLE IF NOT EXISTS "public"."organizations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_active" boolean DEFAULT true,
    "onboarding_completed_at" timestamp with time zone,
    "currency_code" "text" DEFAULT 'GBP'::"text" NOT NULL,
    "currency_locale" "text" DEFAULT 'en-GB'::"text" NOT NULL,
    "company_domain" "text",
    "company_website" "text",
    "company_country_code" "text",
    "company_timezone" "text",
    "company_industry" "text",
    "company_size" "text",
    "company_bio" "text",
    "company_linkedin_url" "text",
    "company_enrichment_status" "text" DEFAULT 'not_started'::"text" NOT NULL,
    "company_enriched_at" timestamp with time zone,
    "company_enrichment_confidence" numeric,
    "company_enrichment_raw" "jsonb",
    "onboarding_version" "text" DEFAULT 'v1'::"text",
    "recording_settings" "jsonb" DEFAULT '{"bot_name": "60 Notetaker", "bot_image_url": null, "entry_message": "Hi! I''m here to take notes so {rep_name} can focus on our conversation. ðŸ“", "recordings_enabled": false, "auto_record_enabled": false, "entry_message_enabled": true, "auto_record_external_only": true, "auto_record_lead_time_minutes": 2, "default_transcription_provider": "gladia"}'::"jsonb",
    "notification_settings" "jsonb" DEFAULT '{"hitl_required": {"email": false, "slack": true, "in_app": true}, "recording_ready": {"email": false, "slack": true, "in_app": true}, "recording_failed": {"email": true, "slack": true, "in_app": true}, "recording_started": {"email": false, "slack": true, "in_app": true}}'::"jsonb",
    CONSTRAINT "organizations_company_enrichment_status_valid" CHECK (("company_enrichment_status" = ANY (ARRAY['not_started'::"text", 'pending'::"text", 'completed'::"text", 'failed'::"text"]))),
    CONSTRAINT "organizations_currency_code_not_empty" CHECK (("length"(TRIM(BOTH FROM "currency_code")) > 0)),
    CONSTRAINT "organizations_currency_locale_not_empty" CHECK (("length"(TRIM(BOTH FROM "currency_locale")) > 0)),
    CONSTRAINT "organizations_name_not_empty" CHECK (("length"(TRIM(BOTH FROM "name")) > 0))
);

-- ALTER TABLE "public"."organizations" OWNER TO "postgres";

COMMENT ON TABLE "public"."organizations" IS 'Organizations (tenants) in the multi-tenant system';

COMMENT ON COLUMN "public"."organizations"."onboarding_completed_at" IS 'When org completed onboarding - meetings after this are "new" meetings';

COMMENT ON COLUMN "public"."organizations"."currency_code" IS 'ISO 4217 currency code for org-wide money display (display preference only).';

COMMENT ON COLUMN "public"."organizations"."currency_locale" IS 'Locale for org-wide money formatting (e.g., en-GB).';

COMMENT ON COLUMN "public"."organizations"."company_domain" IS 'Primary email/web domain for the organization (used for enrichment).';

COMMENT ON COLUMN "public"."organizations"."company_bio" IS 'AI-generated or human-edited company bio for org context.';

COMMENT ON COLUMN "public"."organizations"."company_enrichment_status" IS 'Org enrichment state: not_started|pending|completed|failed.';

CREATE OR REPLACE VIEW "public"."at_risk_users" WITH ("security_invoker"='true') AS
 SELECT "p"."id" AS "user_id",
    "p"."email",
    COALESCE(NULLIF(TRIM(BOTH FROM ((COALESCE("p"."first_name", ''::"text") || ' '::"text") || COALESCE("p"."last_name", ''::"text"))), ''::"text"), "p"."email") AS "full_name",
    "uop"."created_at" AS "signup_date",
    (EXTRACT(epoch FROM ("now"() - "uop"."created_at")) / (3600)::numeric) AS "hours_since_signup",
    COALESCE("uop"."fathom_connected", false) AS "fathom_connected",
    COALESCE("uop"."first_meeting_synced", false) AS "first_meeting_synced",
    COALESCE("uop"."first_summary_viewed", false) AS "first_summary_viewed",
    "uop"."activation_completed_at",
        CASE
            WHEN ((NOT COALESCE("uop"."fathom_connected", false)) AND ("uop"."created_at" < ("now"() - '48:00:00'::interval))) THEN 'high'::"text"
            WHEN (COALESCE("uop"."fathom_connected", false) AND (NOT COALESCE("uop"."first_meeting_synced", false)) AND ("uop"."created_at" < ("now"() - '24:00:00'::interval))) THEN 'medium'::"text"
            WHEN (COALESCE("uop"."first_meeting_synced", false) AND (NOT COALESCE("uop"."first_summary_viewed", false)) AND ("uop"."created_at" < ("now"() - '12:00:00'::interval))) THEN 'low'::"text"
            ELSE 'on_track'::"text"
        END AS "risk_level",
        CASE
            WHEN ((NOT COALESCE("uop"."fathom_connected", false)) AND ("uop"."created_at" < ("now"() - '48:00:00'::interval))) THEN 'Send Fathom connection reminder email'::"text"
            WHEN (COALESCE("uop"."fathom_connected", false) AND (NOT COALESCE("uop"."first_meeting_synced", false)) AND ("uop"."created_at" < ("now"() - '24:00:00'::interval))) THEN 'Check if user has meetings to sync'::"text"
            WHEN (COALESCE("uop"."first_meeting_synced", false) AND (NOT COALESCE("uop"."first_summary_viewed", false)) AND ("uop"."created_at" < ("now"() - '12:00:00'::interval))) THEN 'Prompt user to view meeting insights'::"text"
            ELSE 'No action needed'::"text"
        END AS "suggested_action",
    "uop"."updated_at" AS "last_onboarding_update",
    "om"."org_id",
    "o"."name" AS "org_name"
   FROM ((("public"."user_onboarding_progress" "uop"
     JOIN "public"."profiles" "p" ON (("p"."id" = "uop"."user_id")))
     LEFT JOIN "public"."organization_memberships" "om" ON (("om"."user_id" = "uop"."user_id")))
     LEFT JOIN "public"."organizations" "o" ON (("o"."id" = "om"."org_id")))
  WHERE (("uop"."activation_completed_at" IS NULL) AND ("uop"."created_at" >= ("now"() - '14 days'::interval)) AND ("p"."email" !~~ '%@sixtyapp.com'::"text") AND ("p"."email" !~~ '%test%'::"text"))
  ORDER BY
        CASE
            WHEN ((NOT COALESCE("uop"."fathom_connected", false)) AND ("uop"."created_at" < ("now"() - '48:00:00'::interval))) THEN 1
            WHEN (COALESCE("uop"."fathom_connected", false) AND (NOT COALESCE("uop"."first_meeting_synced", false)) AND ("uop"."created_at" < ("now"() - '24:00:00'::interval))) THEN 2
            WHEN (COALESCE("uop"."first_meeting_synced", false) AND (NOT COALESCE("uop"."first_summary_viewed", false)) AND ("uop"."created_at" < ("now"() - '12:00:00'::interval))) THEN 3
            ELSE 4
        END, "uop"."created_at" DESC;

-- ALTER VIEW "public"."at_risk_users" OWNER TO "postgres";

-- ALTER TABLE "public"."audit_logs" OWNER TO "postgres";

--COMMENT ON TABLE "public"."audit_logs" IS 'Comprehensive audit trail for all data changes. Tracks who changed what, when, and the before/after values.';

-- ALTER TABLE "public"."automation_executions" OWNER TO "postgres";

--COMMENT ON TABLE "public"."automation_executions" IS 'Audit log of all automation rule executions with detailed results';

CREATE TABLE IF NOT EXISTS "public"."billing_event_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "provider" "text" NOT NULL,
    "provider_event_id" "text" NOT NULL,
    "event_type" "text" NOT NULL,
    "occurred_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "org_id" "uuid",
    "payload" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "processed_at" timestamp with time zone,
    "processing_error" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "billing_event_log_provider_check" CHECK (("provider" = ANY (ARRAY['stripe'::"text", 'apple'::"text", 'google'::"text", 'revenuecat'::"text"])))
);

-- ALTER TABLE "public"."billing_event_log" OWNER TO "postgres";

COMMENT ON TABLE "public"."billing_event_log" IS 'Provider-agnostic append-only log of all billing events for analytics';

COMMENT ON COLUMN "public"."billing_event_log"."provider" IS 'Billing provider: stripe, apple, google, revenuecat';

COMMENT ON COLUMN "public"."billing_event_log"."provider_event_id" IS 'Provider-specific event ID for idempotency';

COMMENT ON COLUMN "public"."billing_event_log"."event_type" IS 'Normalized event type (subscription_created, payment_received, etc.)';

COMMENT ON COLUMN "public"."billing_event_log"."payload" IS 'Raw event payload from provider for audit/debugging';

COMMENT ON COLUMN "public"."billing_event_log"."metadata" IS 'Extracted fields for easier querying (e.g., amount, currency, plan_id)';

CREATE TABLE IF NOT EXISTS "public"."billing_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "subscription_id" "uuid",
    "event_type" "text" NOT NULL,
    "amount" integer NOT NULL,
    "currency" "text" DEFAULT 'USD'::"text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "description" "text",
    "stripe_invoice_id" "text",
    "stripe_payment_intent_id" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "stripe_charge_id" "text",
    "stripe_refund_id" "text",
    "receipt_url" "text",
    "hosted_invoice_url" "text",
    "pdf_url" "text",
    "period_start" timestamp with time zone,
    "period_end" timestamp with time zone
);

-- ALTER TABLE "public"."billing_history" OWNER TO "postgres";

COMMENT ON TABLE "public"."billing_history" IS 'Billing events and payment history';

CREATE TABLE IF NOT EXISTS "public"."booking_sources" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "category" "text",
    "icon" "text",
    "color" "text",
    "is_active" boolean DEFAULT true,
    "sort_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "api_name" "text" NOT NULL
);

-- ALTER TABLE "public"."booking_sources" OWNER TO "postgres";

COMMENT ON TABLE "public"."booking_sources" IS 'Predefined list of booking sources for standardization';

COMMENT ON COLUMN "public"."booking_sources"."category" IS 'Category grouping: paid, organic, referral, marketing, outbound, other';

COMMENT ON COLUMN "public"."booking_sources"."api_name" IS 'API-friendly identifier for programmatic access (e.g., "facebook_ads", "linkedin_ads"). Must be unique and stable.';

CREATE TABLE IF NOT EXISTS "public"."bot_deployments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "recording_id" "uuid",
    "bot_id" "text" NOT NULL,
    "status" "text" DEFAULT 'scheduled'::"text",
    "status_history" "jsonb" DEFAULT '[]'::"jsonb",
    "meeting_url" "text" NOT NULL,
    "scheduled_join_time" timestamp with time zone,
    "actual_join_time" timestamp with time zone,
    "leave_time" timestamp with time zone,
    "bot_name" "text",
    "bot_image_url" "text",
    "entry_message" "text",
    "error_code" "text",
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "bot_deployments_status_check" CHECK (("status" = ANY (ARRAY['scheduled'::"text", 'joining'::"text", 'in_meeting'::"text", 'leaving'::"text", 'completed'::"text", 'failed'::"text", 'cancelled'::"text"])))
);

-- ALTER TABLE "public"."bot_deployments" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."branding_settings" (
    "id" "uuid" DEFAULT '00000000-0000-0000-0000-000000000000'::"uuid" NOT NULL,
    "logo_light_url" "text",
    "logo_dark_url" "text",
    "icon_url" "text",
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "org_id" "uuid"
);

-- ALTER TABLE "public"."branding_settings" OWNER TO "postgres";

-- COMMENT ON TABLE "public"."branding_settings" IS 'Organization branding settings for logos and icons. Supports per-org branding with fallback to global defaults.';

-- COMMENT ON COLUMN "public"."branding_settings"."org_id" IS 'Organization ID for org-specific branding. NULL for global/default branding.';

-- -- ALTER TABLE "public"."calendar_attendees" OWNER TO "postgres";

-- -- ALTER TABLE "public"."calendar_calendars" OWNER TO "postgres";

-- -- COMMENT ON COLUMN "public"."calendar_calendars"."timezone" IS 'IANA timezone string (e.g., Europe/London) detected from Google Calendar. Automatically handles daylight savings.';

-- COMMENT ON COLUMN "public"."calendar_calendars"."last_sync_token" IS 'Google Calendar sync token for incremental updates';

-- COMMENT ON COLUMN "public"."calendar_calendars"."org_id" IS 'Organization that owns this calendar connection - required for webhook sync';

-- -- ALTER TABLE "public"."calendar_events" OWNER TO "postgres";

-- COMMENT ON COLUMN "public"."calendar_events"."external_updated_at" IS 'Last modification time from Google Calendar';

-- COMMENT ON COLUMN "public"."calendar_events"."sync_status" IS 'Current synchronization status of the event';

-- COMMENT ON COLUMN "public"."calendar_events"."etag" IS 'Google Calendar ETag for detecting changes';

-- COMMENT ON COLUMN "public"."calendar_events"."synced_at" IS 'Timestamp when this event was last synced from Google Calendar';

-- COMMENT ON COLUMN "public"."calendar_events"."org_id" IS 'Organization ID for future multi-tenancy support. Currently optional as single-tenant mode is active. No FK constraint as organizations table does not exist yet.';

-- COMMENT ON COLUMN "public"."calendar_events"."attendees" IS 'JSONB array of event attendees from Google Calendar API. Used by auto-record trigger to detect external participants.';

CREATE TABLE IF NOT EXISTS "public"."companies" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "domain" "text",
    "industry" "text",
    "size" "text",
    "website" "text",
    "address" "text",
    "phone" "text",
    "description" "text",
    "linkedin_url" "text",
    "owner_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "source" "text" DEFAULT 'manual'::"text",
    "first_seen_at" timestamp with time zone DEFAULT "now"(),
    "clerk_org_id" "text",
    CONSTRAINT "companies_size_check" CHECK (("size" = ANY (ARRAY['startup'::"text", 'small'::"text", 'medium'::"text", 'large'::"text", 'enterprise'::"text"])))
);

-- ALTER TABLE "public"."companies" OWNER TO "postgres";

-- COMMENT ON COLUMN "public"."companies"."source" IS 'Source of company discovery: manual, fathom_meeting, enrichment, import, etc.';

-- COMMENT ON COLUMN "public"."companies"."first_seen_at" IS 'Timestamp when company was first discovered in the system';

-- -- ALTER TABLE "public"."contacts" OWNER TO "postgres";

-- COMMENT ON COLUMN "public"."contacts"."first_seen_at" IS 'Timestamp when contact was first discovered (e.g., via Fathom sync)';

-- COMMENT ON COLUMN "public"."contacts"."last_interaction_at" IS 'Timestamp of most recent interaction (meeting, activity, etc.)';

-- COMMENT ON COLUMN "public"."contacts"."total_meetings_count" IS 'Total number of meetings attended by this contact';

CREATE OR REPLACE VIEW "public"."calendar_events_with_contacts" WITH ("security_invoker"='true') AS
 SELECT "ce"."id",
    "ce"."external_id",
    "ce"."calendar_id",
    "ce"."user_id",
    "ce"."mcp_connection_id",
    "ce"."title",
    "ce"."description",
    "ce"."location",
    "ce"."start_time",
    "ce"."end_time",
    "ce"."all_day",
    "ce"."recurrence_rule",
    "ce"."recurrence_id",
    "ce"."meeting_url",
    "ce"."meeting_provider",
    "ce"."meeting_id",
    "ce"."status",
    "ce"."visibility",
    "ce"."busy_status",
    "ce"."ai_generated",
    "ce"."ai_suggested_time",
    "ce"."meeting_prep",
    "ce"."deal_id",
    "ce"."workflow_id",
    "ce"."color",
    "ce"."reminders",
    "ce"."attendees_count",
    "ce"."response_status",
    "ce"."created_at",
    "ce"."updated_at",
    "ce"."external_updated_at",
    "ce"."sync_status",
    "ce"."sync_error",
    "ce"."contact_id",
    "ce"."company_id",
    "ce"."original_start_time",
    "ce"."etag",
    "ce"."html_link",
    "ce"."hangout_link",
    "ce"."creator_email",
    "ce"."organizer_email",
    "ce"."transparency",
    "ce"."raw_data",
    "ce"."clerk_org_id",
    "ce"."synced_at",
    "ce"."org_id",
    COALESCE("c"."full_name", "concat"("c"."first_name", ' ', "c"."last_name")) AS "contact_name",
    "c"."email" AS "contact_email",
    "c"."phone" AS "contact_phone",
    "co"."name" AS "company_name",
    "co"."domain" AS "company_domain"
   FROM (("public"."calendar_events" "ce"
     LEFT JOIN "public"."contacts" "c" ON (("ce"."contact_id" = "c"."id")))
     LEFT JOIN "public"."companies" "co" ON (("ce"."company_id" = "co"."id")));

-- ALTER VIEW "public"."calendar_events_with_contacts" OWNER TO "postgres";

COMMENT ON VIEW "public"."calendar_events_with_contacts" IS 'Calendar events with contact/company info (security_invoker enabled)';

-- ALTER TABLE "public"."calendar_reminders" OWNER TO "postgres";

-- ALTER TABLE "public"."calendar_sync_logs" OWNER TO "postgres";

COMMENT ON TABLE "public"."calendar_sync_logs" IS 'Tracks calendar synchronization history and statistics';

CREATE TABLE IF NOT EXISTS "public"."call_action_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "call_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "assignee_name" "text",
    "assignee_email" "text",
    "priority" "text" DEFAULT 'medium'::"text",
    "category" "text",
    "deadline_at" timestamp with time zone,
    "importance" "text",
    "confidence_score" numeric(3,2),
    "ai_generated" boolean DEFAULT true NOT NULL,
    "timestamp_seconds" numeric,
    "playback_url" "text",
    "linked_task_id" "uuid",
    "synced_to_task" boolean DEFAULT false NOT NULL,
    "sync_status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "sync_error" "text",
    "synced_at" timestamp with time zone,
    "completed" boolean DEFAULT false NOT NULL,
    "completed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "call_action_items_confidence_score_check" CHECK ((("confidence_score" >= (0)::numeric) AND ("confidence_score" <= (1)::numeric))),
    CONSTRAINT "call_action_items_importance_check" CHECK (("importance" = ANY (ARRAY['high'::"text", 'medium'::"text", 'low'::"text"]))),
    CONSTRAINT "call_action_items_priority_check" CHECK (("priority" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'urgent'::"text"]))),
    CONSTRAINT "call_action_items_sync_status_check" CHECK (("sync_status" = ANY (ARRAY['pending'::"text", 'synced'::"text", 'failed'::"text", 'excluded'::"text"])))
);

-- ALTER TABLE "public"."call_action_items" OWNER TO "postgres";

COMMENT ON TABLE "public"."call_action_items" IS 'AI-extracted action items from call transcripts (Calls equivalent of meeting_action_items)';

CREATE TABLE IF NOT EXISTS "public"."call_file_search_index" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "call_id" "uuid" NOT NULL,
    "owner_user_id" "uuid",
    "store_name" "text" NOT NULL,
    "file_name" "text",
    "content_hash" "text",
    "indexed_at" timestamp with time zone DEFAULT "now"(),
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "error_message" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    CONSTRAINT "call_file_search_index_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'indexing'::"text", 'indexed'::"text", 'failed'::"text"])))
);

-- ALTER TABLE "public"."call_file_search_index" OWNER TO "postgres";

COMMENT ON TABLE "public"."call_file_search_index" IS 'Index tracking for calls indexed into File Search';

CREATE TABLE IF NOT EXISTS "public"."call_index_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "call_id" "uuid" NOT NULL,
    "owner_user_id" "uuid",
    "priority" integer DEFAULT 0 NOT NULL,
    "attempts" integer DEFAULT 0 NOT NULL,
    "max_attempts" integer DEFAULT 3 NOT NULL,
    "last_attempt_at" timestamp with time zone,
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."call_index_queue" OWNER TO "postgres";

COMMENT ON TABLE "public"."call_index_queue" IS 'Async queue for indexing call transcripts into File Search';

CREATE TABLE IF NOT EXISTS "public"."call_transcript_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "call_id" "uuid" NOT NULL,
    "priority" integer DEFAULT 0 NOT NULL,
    "attempts" integer DEFAULT 0 NOT NULL,
    "max_attempts" integer DEFAULT 10 NOT NULL,
    "last_attempt_at" timestamp with time zone,
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."call_transcript_queue" OWNER TO "postgres";

COMMENT ON TABLE "public"."call_transcript_queue" IS 'Async retry queue for fetching call transcripts';

CREATE TABLE IF NOT EXISTS "public"."calls" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "provider" "text" DEFAULT 'justcall'::"text" NOT NULL,
    "external_id" "text" NOT NULL,
    "direction" "text" DEFAULT 'unknown'::"text" NOT NULL,
    "status" "text",
    "started_at" timestamp with time zone,
    "ended_at" timestamp with time zone,
    "duration_seconds" integer,
    "from_number" "text",
    "to_number" "text",
    "justcall_agent_id" "text",
    "agent_email" "text",
    "owner_user_id" "uuid",
    "owner_email" "text",
    "recording_url" "text",
    "recording_mime" "text",
    "has_recording" boolean DEFAULT false NOT NULL,
    "transcript_text" "text",
    "transcript_json" "jsonb",
    "transcript_status" "text" DEFAULT 'missing'::"text" NOT NULL,
    "transcript_fetch_attempts" integer DEFAULT 0 NOT NULL,
    "last_transcript_fetch_at" timestamp with time zone,
    "contact_id" "uuid",
    "company_id" "uuid",
    "deal_id" "uuid",
    "summary" "text",
    "sentiment_score" numeric,
    "sentiment_reasoning" "text",
    "last_synced_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "calls_direction_check" CHECK (("direction" = ANY (ARRAY['inbound'::"text", 'outbound'::"text", 'internal'::"text", 'unknown'::"text"]))),
    CONSTRAINT "calls_sentiment_score_check" CHECK ((("sentiment_score" >= ('-1'::integer)::numeric) AND ("sentiment_score" <= (1)::numeric))),
    CONSTRAINT "calls_transcript_status_check" CHECK (("transcript_status" = ANY (ARRAY['missing'::"text", 'queued'::"text", 'processing'::"text", 'ready'::"text", 'failed'::"text"])))
);

-- ALTER TABLE "public"."calls" OWNER TO "postgres";

COMMENT ON TABLE "public"."calls" IS 'Audio calls imported from dialers (JustCall initially)';

-- ALTER TABLE "public"."challenge_features" OWNER TO "postgres";

-- ALTER TABLE "public"."challenges" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."clerk_sync_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "event_type" "text" NOT NULL,
    "clerk_id" "text" NOT NULL,
    "event_data" "jsonb",
    "synced_at" timestamp with time zone DEFAULT "now"(),
    "success" boolean DEFAULT true,
    "error_message" "text"
);

-- ALTER TABLE "public"."clerk_sync_log" OWNER TO "postgres";

COMMENT ON TABLE "public"."clerk_sync_log" IS 'Logs de synchronisation entre Clerk et Supabase';

CREATE TABLE IF NOT EXISTS "public"."clerk_user_mappings" (
    "clerk_user_id" "text" NOT NULL,
    "supabase_user_id" "uuid" NOT NULL,
    "email" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."clerk_user_mappings" OWNER TO "postgres";

COMMENT ON TABLE "public"."clerk_user_mappings" IS 'Maps Clerk user IDs to Supabase profile UUIDs for dual-auth support';

COMMENT ON COLUMN "public"."clerk_user_mappings"."clerk_user_id" IS 'Clerk user ID from JWT sub claim (e.g., user_2abc123...)';

COMMENT ON COLUMN "public"."clerk_user_mappings"."supabase_user_id" IS 'UUID from profiles table, used for all FK relationships';

COMMENT ON COLUMN "public"."clerk_user_mappings"."email" IS 'User email for lookup and debugging purposes';

CREATE TABLE IF NOT EXISTS "public"."clients" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_name" "text" NOT NULL,
    "contact_name" "text",
    "contact_email" "text",
    "subscription_amount" numeric(12,2) DEFAULT 0,
    "status" "public"."client_status" DEFAULT 'active'::"public"."client_status" NOT NULL,
    "deal_id" "uuid",
    "owner_id" "uuid" NOT NULL,
    "subscription_start_date" "date",
    "churn_date" "date",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "notice_given_date" "date",
    "final_billing_date" "date",
    "churn_reason" "text",
    "clerk_org_id" "text",
    CONSTRAINT "check_churn_date_only_when_churned" CHECK (((("status" = 'churned'::"public"."client_status") AND ("churn_date" IS NOT NULL)) OR (("status" <> 'churned'::"public"."client_status") AND ("churn_date" IS NULL)))),
    CONSTRAINT "clients_subscription_amount_check" CHECK (("subscription_amount" >= (0)::numeric))
);

-- ALTER TABLE "public"."clients" OWNER TO "postgres";

COMMENT ON COLUMN "public"."clients"."notice_given_date" IS 'Date when client gave notice to terminate subscription';

COMMENT ON COLUMN "public"."clients"."final_billing_date" IS 'Date of final billing before subscription ends';

COMMENT ON COLUMN "public"."clients"."churn_reason" IS 'Reason provided for churning (optional)';

CREATE OR REPLACE VIEW "public"."client_churn_analytics" WITH ("security_invoker"='true') AS
 SELECT "id",
    "company_name",
    "status",
    "subscription_amount",
    "notice_given_date",
    "final_billing_date",
    "churn_date",
    "churn_reason",
    "public"."get_days_until_churn"("final_billing_date") AS "days_until_final_billing",
        CASE
            WHEN (("status" = 'notice_given'::"public"."client_status") AND ("final_billing_date" IS NOT NULL)) THEN
            CASE
                WHEN ("final_billing_date" > CURRENT_DATE) THEN 'Active - Notice Period'::"text"
                WHEN ("final_billing_date" = CURRENT_DATE) THEN 'Final Billing Today'::"text"
                ELSE 'Should Be Churned'::"text"
            END
            WHEN ("status" = 'churned'::"public"."client_status") THEN 'Churned'::"text"
            WHEN ("status" = 'active'::"public"."client_status") THEN 'Active'::"text"
            ELSE ("status")::"text"
        END AS "churn_status",
        CASE
            WHEN (("status" = 'notice_given'::"public"."client_status") AND ("final_billing_date" > CURRENT_DATE)) THEN ("subscription_amount" * "ceil"(((("final_billing_date" - CURRENT_DATE))::numeric / (30)::numeric)))
            ELSE (0)::numeric
        END AS "remaining_revenue_estimate"
   FROM "public"."clients" "c";

-- ALTER VIEW "public"."client_churn_analytics" OWNER TO "postgres";

COMMENT ON VIEW "public"."client_churn_analytics" IS 'View for analyzing client churn patterns (security_invoker enabled)';

CREATE TABLE IF NOT EXISTS "public"."coaching_scorecard_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "meeting_type" "text" NOT NULL,
    "metrics" "jsonb" DEFAULT '[{"id": "talk_ratio", "name": "Talk-to-Listen Ratio", "weight": 25, "enabled": true, "description": "Percentage of time rep speaks vs prospect", "ideal_range": {"max": 45, "min": 30}}, {"id": "discovery_questions", "name": "Discovery Questions", "weight": 25, "enabled": true, "description": "Number of open-ended questions asked", "ideal_range": {"max": 15, "min": 5}}, {"id": "next_steps", "name": "Next Steps Established", "weight": 25, "enabled": true, "description": "Whether clear next steps were agreed upon"}, {"id": "monologue_detection", "name": "Monologue Avoidance", "weight": 25, "enabled": true, "description": "Number of times rep spoke for over 60 seconds", "ideal_range": {"max": 2, "min": 0}}]'::"jsonb" NOT NULL,
    "checklist_items" "jsonb" DEFAULT '[]'::"jsonb",
    "script_flow" "jsonb" DEFAULT '[]'::"jsonb",
    "passing_score" integer DEFAULT 70,
    "excellence_score" integer DEFAULT 90,
    "is_active" boolean DEFAULT true,
    "is_default" boolean DEFAULT false,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "call_type_id" "uuid",
    CONSTRAINT "coaching_scorecard_templates_meeting_type_check" CHECK (("meeting_type" = ANY (ARRAY['discovery'::"text", 'demo'::"text", 'negotiation'::"text", 'closing'::"text", 'follow_up'::"text", 'general'::"text"])))
);

-- ALTER TABLE "public"."coaching_scorecard_templates" OWNER TO "postgres";

COMMENT ON TABLE "public"."coaching_scorecard_templates" IS 'Admin-configurable scorecard templates with metrics, checklists, and script flows per meeting type';

COMMENT ON COLUMN "public"."coaching_scorecard_templates"."call_type_id" IS 'Link template to specific call type for automatic selection during scorecard generation';

-- ALTER TABLE "public"."communication_events" OWNER TO "postgres";

COMMENT ON TABLE "public"."communication_events" IS 'Tracks all communication interactions for pattern analysis and ghost detection';

COMMENT ON COLUMN "public"."communication_events"."response_time_hours" IS 'For inbound events, hours since the last outbound message';

COMMENT ON COLUMN "public"."communication_events"."sentiment_score" IS 'Sentiment analysis score from -1 (very negative) to 1 (very positive)';

COMMENT ON COLUMN "public"."communication_events"."thread_id" IS 'Unique identifier for email/message threads to track conversation flow';

COMMENT ON COLUMN "public"."communication_events"."external_id" IS 'Gmail message ID for deduplication';

COMMENT ON COLUMN "public"."communication_events"."email_thread_id" IS 'Gmail thread ID for grouping related emails';

COMMENT ON COLUMN "public"."communication_events"."ai_analyzed" IS 'Whether Claude Haiku 4.5 has analyzed this email';

COMMENT ON COLUMN "public"."communication_events"."ai_model" IS 'AI model used for analysis (e.g., claude-haiku-4-5-20251001)';

COMMENT ON COLUMN "public"."communication_events"."key_topics" IS 'AI-extracted key topics from email (JSONB array)';

COMMENT ON COLUMN "public"."communication_events"."action_items" IS 'AI-extracted action items from email (JSONB array)';

COMMENT ON COLUMN "public"."communication_events"."urgency" IS 'AI-determined urgency level (low, medium, high)';

COMMENT ON COLUMN "public"."communication_events"."response_required" IS 'Whether AI determined a response is required';

COMMENT ON COLUMN "public"."communication_events"."sync_source" IS 'Source of the communication event (gmail, manual, calendar, fathom)';

CREATE TABLE IF NOT EXISTS "public"."company_meeting_insights" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "company_id" "uuid" NOT NULL,
    "total_meetings" integer DEFAULT 0,
    "total_contacts_met" integer DEFAULT 0,
    "last_meeting_date" timestamp with time zone,
    "avg_sentiment_score" numeric,
    "sentiment_trend" "text",
    "engagement_score" integer,
    "meeting_frequency_days" numeric,
    "inferred_deal_stage" "text",
    "deal_probability" integer,
    "key_topics" "text"[],
    "pain_points" "text"[],
    "decision_makers" "text"[],
    "competitors_mentioned" "text"[],
    "buying_committee_size" integer,
    "decision_timeline_days" integer,
    "last_updated_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "insights_summary" "text",
    CONSTRAINT "company_meeting_insights_avg_sentiment_score_check" CHECK ((("avg_sentiment_score" >= ('-1'::integer)::numeric) AND ("avg_sentiment_score" <= (1)::numeric))),
    CONSTRAINT "company_meeting_insights_deal_probability_check" CHECK ((("deal_probability" >= 0) AND ("deal_probability" <= 100))),
    CONSTRAINT "company_meeting_insights_engagement_score_check" CHECK ((("engagement_score" >= 0) AND ("engagement_score" <= 100))),
    CONSTRAINT "company_meeting_insights_inferred_deal_stage_check" CHECK (("inferred_deal_stage" = ANY (ARRAY['research'::"text", 'evaluation'::"text", 'negotiation'::"text", 'decision'::"text", 'unknown'::"text"]))),
    CONSTRAINT "company_meeting_insights_sentiment_trend_check" CHECK (("sentiment_trend" = ANY (ARRAY['improving'::"text", 'stable'::"text", 'declining'::"text", 'unknown'::"text"])))
);

-- ALTER TABLE "public"."company_meeting_insights" OWNER TO "postgres";

COMMENT ON TABLE "public"."company_meeting_insights" IS 'Aggregated meeting intelligence per company';

COMMENT ON COLUMN "public"."company_meeting_insights"."engagement_score" IS 'Overall company engagement score (0-100)';

COMMENT ON COLUMN "public"."company_meeting_insights"."inferred_deal_stage" IS 'Deal stage inferred from meeting patterns';

COMMENT ON COLUMN "public"."company_meeting_insights"."deal_probability" IS 'Estimated probability of closing deal (0-100)';

COMMENT ON COLUMN "public"."company_meeting_insights"."decision_makers" IS 'Identified decision makers from meeting analysis';

CREATE TABLE IF NOT EXISTS "public"."contact_meeting_insights" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "contact_id" "uuid" NOT NULL,
    "total_meetings" integer DEFAULT 0,
    "last_meeting_date" timestamp with time zone,
    "next_suggested_followup" timestamp with time zone,
    "avg_sentiment_score" numeric,
    "sentiment_trend" "text",
    "avg_talk_time_customer_pct" numeric,
    "engagement_score" integer,
    "response_rate" numeric,
    "key_topics" "text"[],
    "pain_points" "text"[],
    "objections" "text"[],
    "decision_criteria" "text"[],
    "competitors_mentioned" "text"[],
    "last_updated_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "insights_summary" "text",
    CONSTRAINT "contact_meeting_insights_avg_sentiment_score_check" CHECK ((("avg_sentiment_score" >= ('-1'::integer)::numeric) AND ("avg_sentiment_score" <= (1)::numeric))),
    CONSTRAINT "contact_meeting_insights_avg_talk_time_customer_pct_check" CHECK ((("avg_talk_time_customer_pct" >= (0)::numeric) AND ("avg_talk_time_customer_pct" <= (100)::numeric))),
    CONSTRAINT "contact_meeting_insights_engagement_score_check" CHECK ((("engagement_score" >= 0) AND ("engagement_score" <= 100))),
    CONSTRAINT "contact_meeting_insights_response_rate_check" CHECK ((("response_rate" >= (0)::numeric) AND ("response_rate" <= (100)::numeric))),
    CONSTRAINT "contact_meeting_insights_sentiment_trend_check" CHECK (("sentiment_trend" = ANY (ARRAY['improving'::"text", 'stable'::"text", 'declining'::"text", 'unknown'::"text"])))
);

-- ALTER TABLE "public"."contact_meeting_insights" OWNER TO "postgres";

COMMENT ON TABLE "public"."contact_meeting_insights" IS 'Aggregated meeting intelligence per contact';

COMMENT ON COLUMN "public"."contact_meeting_insights"."sentiment_trend" IS 'Trend of sentiment over recent meetings';

COMMENT ON COLUMN "public"."contact_meeting_insights"."engagement_score" IS 'Overall engagement score (0-100) based on meeting frequency, sentiment, and response rate';

COMMENT ON COLUMN "public"."contact_meeting_insights"."key_topics" IS 'Array of key topics discussed across meetings';

COMMENT ON COLUMN "public"."contact_meeting_insights"."pain_points" IS 'Array of pain points mentioned in meetings';

COMMENT ON COLUMN "public"."contact_meeting_insights"."decision_criteria" IS 'Array of decision criteria mentioned';

-- ALTER TABLE "public"."contact_notes" OWNER TO "postgres";

COMMENT ON TABLE "public"."contact_notes" IS 'Stores notes and annotations related to contacts for team collaboration';

COMMENT ON COLUMN "public"."contact_notes"."contact_id" IS 'Reference to the contact this note belongs to';

COMMENT ON COLUMN "public"."contact_notes"."title" IS 'Short descriptive title for the note';

COMMENT ON COLUMN "public"."contact_notes"."content" IS 'Main content of the note (supports rich text)';

COMMENT ON COLUMN "public"."contact_notes"."created_by" IS 'User who created this note';

COMMENT ON COLUMN "public"."contact_notes"."is_pinned" IS 'Whether this note is pinned for quick access';

COMMENT ON COLUMN "public"."contact_notes"."tags" IS 'Array of tags for categorizing notes';

-- ALTER TABLE "public"."content" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."content_topic_links" (
    "content_id" "uuid" NOT NULL,
    "topic_index" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "content_topic_links_topic_index_check" CHECK (("topic_index" >= 0))
);

-- ALTER TABLE "public"."content_topic_links" OWNER TO "postgres";

COMMENT ON TABLE "public"."content_topic_links" IS 'Junction table linking generated content to specific topics';

COMMENT ON COLUMN "public"."content_topic_links"."topic_index" IS 'Index of topic in meeting_content_topics.topics JSONB array';

CREATE TABLE IF NOT EXISTS "public"."copilot_analytics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "conversation_id" "uuid",
    "request_type" "text" NOT NULL,
    "message_length" integer DEFAULT 0,
    "response_length" integer DEFAULT 0,
    "response_time_ms" integer DEFAULT 0,
    "claude_api_time_ms" integer DEFAULT 0,
    "tool_execution_time_ms" integer DEFAULT 0,
    "tool_iterations" integer DEFAULT 0,
    "tools_used" "jsonb" DEFAULT '[]'::"jsonb",
    "tools_success_count" integer DEFAULT 0,
    "tools_error_count" integer DEFAULT 0,
    "estimated_cost_cents" numeric(10,4) DEFAULT 0,
    "input_tokens" integer DEFAULT 0,
    "output_tokens" integer DEFAULT 0,
    "status" "text" DEFAULT 'success'::"text" NOT NULL,
    "error_type" "text",
    "error_message" "text",
    "has_context" boolean DEFAULT false,
    "context_type" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "copilot_analytics_request_type_check" CHECK (("request_type" = ANY (ARRAY['chat'::"text", 'draft_email'::"text", 'get_conversation'::"text"]))),
    CONSTRAINT "copilot_analytics_status_check" CHECK (("status" = ANY (ARRAY['success'::"text", 'error'::"text", 'timeout'::"text", 'rate_limited'::"text"])))
);

-- ALTER TABLE "public"."copilot_analytics" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."copilot_conversations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "title" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "org_id" "uuid"
);

-- ALTER TABLE "public"."copilot_conversations" OWNER TO "postgres";

COMMENT ON TABLE "public"."copilot_conversations" IS 'Stores CoPilot conversation sessions for each user';

COMMENT ON COLUMN "public"."copilot_conversations"."title" IS 'Auto-generated or user-defined title for the conversation';

CREATE TABLE IF NOT EXISTS "public"."copilot_messages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "conversation_id" "uuid" NOT NULL,
    "role" "text" NOT NULL,
    "content" "text" NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "copilot_messages_role_check" CHECK (("role" = ANY (ARRAY['user'::"text", 'assistant'::"text"])))
);

-- ALTER TABLE "public"."copilot_messages" OWNER TO "postgres";

COMMENT ON TABLE "public"."copilot_messages" IS 'Stores individual messages within CoPilot conversations';

COMMENT ON COLUMN "public"."copilot_messages"."role" IS 'Message sender: user or assistant';

COMMENT ON COLUMN "public"."copilot_messages"."metadata" IS 'Additional data like response type, action data, etc.';

CREATE TABLE IF NOT EXISTS "public"."cost_rates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "provider" "text" NOT NULL,
    "model" "text" NOT NULL,
    "input_cost_per_million" numeric(10,4) NOT NULL,
    "output_cost_per_million" numeric(10,4) NOT NULL,
    "effective_from" timestamp with time zone DEFAULT "now"(),
    "effective_to" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "cost_rates_provider_check" CHECK (("provider" = ANY (ARRAY['anthropic'::"text", 'gemini'::"text", 'supabase'::"text"])))
);

-- ALTER TABLE "public"."cost_rates" OWNER TO "postgres";

COMMENT ON TABLE "public"."cost_rates" IS 'Configurable cost rates per AI model/provider';

CREATE TABLE IF NOT EXISTS "public"."cron_job_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "job_name" "text" NOT NULL,
    "user_id" "uuid",
    "status" "text" NOT NULL,
    "message" "text",
    "error_details" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "cron_job_logs_status_check" CHECK (("status" = ANY (ARRAY['triggered'::"text", 'success'::"text", 'error'::"text"])))
);

-- ALTER TABLE "public"."cron_job_logs" OWNER TO "postgres";

COMMENT ON TABLE "public"."cron_job_logs" IS 'Audit trail for cron job executions';

CREATE TABLE IF NOT EXISTS "public"."cron_job_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "job_name" "text" NOT NULL,
    "display_name" "text",
    "description" "text",
    "category" "text" DEFAULT 'general'::"text",
    "is_monitored" boolean DEFAULT true NOT NULL,
    "alert_on_failure" boolean DEFAULT true NOT NULL,
    "alert_after_consecutive_failures" integer DEFAULT 1,
    "max_runtime_seconds" integer DEFAULT 300,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

-- ALTER TABLE "public"."cron_job_settings" OWNER TO "postgres";

--
--
-- ALTER VIEW "public"."cron_jobs_status" OWNER TO "postgres";

--
--
-- CREATE TABLE IF NOT EXISTS "public"."cron_notification_subscribers" (
--     "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
--     "email" "text" NOT NULL,
--     "name" "text",
--     "is_active" boolean DEFAULT true NOT NULL,
--     "notify_on_failure" boolean DEFAULT true NOT NULL,
--     "notify_on_success" boolean DEFAULT false NOT NULL,
--     "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
--     "created_by" "uuid"
-- );

--
--
-- ALTER TABLE "public"."cron_notification_subscribers" OWNER TO "postgres";

--
--
-- CREATE TABLE IF NOT EXISTS "public"."cron_notifications_log" (
--     "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
--     "job_name" "text" NOT NULL,
--     "job_id" bigint,
--     "run_id" bigint,
--     "notification_type" "text" NOT NULL,
--     "status" "text" NOT NULL,
--     "recipients" "text"[] NOT NULL,
--     "subject" "text",
--     "message" "text",
--     "error_details" "text",
--     "sent_at" timestamp with time zone,
--     "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
--     CONSTRAINT "cron_notifications_log_notification_type_check" CHECK (("notification_type" = ANY (ARRAY['failure'::"text", 'success'::"text", 'warning'::"text"]))),
--     CONSTRAINT "cron_notifications_log_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'sent'::"text", 'failed'::"text"])))
-- );

--
--
-- ALTER TABLE "public"."cron_notifications_log" OWNER TO "postgres";

-- "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    -- CONSTRAINT "cron_notifications_log_notification_type_check" CHECK (("notification_type" = ANY (ARRAY['failure'::"text", 'success'::"text", 'warning'::"text"]))),
    -- CONSTRAINT "cron_notifications_log_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'sent'::"text", 'failed'::"text"])))
-- );

-- ALTER TABLE "public"."cron_notifications_log" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."csv_mapping_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "column_mappings" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "source_hint" "text",
    "usage_count" integer DEFAULT 0,
    "last_used_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."csv_mapping_templates" OWNER TO "postgres";

COMMENT ON TABLE "public"."csv_mapping_templates" IS 'Stores reusable CSV column-to-lead-field mappings for the generic CSV import feature';

COMMENT ON COLUMN "public"."csv_mapping_templates"."column_mappings" IS 'JSONB mapping of CSV column names to lead table field names';

COMMENT ON COLUMN "public"."csv_mapping_templates"."source_hint" IS 'Human-readable hint about what CSV source this template is for (e.g., "HubSpot Export")';

COMMENT ON COLUMN "public"."csv_mapping_templates"."usage_count" IS 'Number of times this template has been used';

COMMENT ON COLUMN "public"."csv_mapping_templates"."last_used_at" IS 'Timestamp of when this template was last used for an import';

-- ALTER TABLE "public"."deal_activities" OWNER TO "postgres";

CREATE OR REPLACE VIEW "public"."deal_activities_with_profile" WITH ("security_invoker"='true') AS
 SELECT "da"."id",
    "da"."deal_id",
    "da"."user_id",
    "da"."activity_type",
    "da"."notes",
    "da"."due_date",
    "da"."completed",
    "da"."created_at",
    "da"."updated_at",
    "da"."contact_email",
    "da"."is_matched",
    "p"."id" AS "profile_id",
    COALESCE((("p"."first_name" || ' '::"text") || "p"."last_name"), "p"."email") AS "profile_full_name",
    "p"."avatar_url" AS "profile_avatar_url"
   FROM ("public"."deal_activities" "da"
     LEFT JOIN "public"."profiles" "p" ON (("da"."user_id" = "p"."id")));

-- ALTER VIEW "public"."deal_activities_with_profile" OWNER TO "postgres";

COMMENT ON VIEW "public"."deal_activities_with_profile" IS 'Deal activities with user profile information (security_invoker enabled)';

CREATE TABLE IF NOT EXISTS "public"."deal_clarity_scores" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "deal_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "clarity_score" integer,
    "next_step_score" integer DEFAULT 0,
    "economic_buyer_score" integer DEFAULT 0,
    "champion_score" integer DEFAULT 0,
    "success_metric_score" integer DEFAULT 0,
    "risks_score" integer DEFAULT 0,
    "close_plan_completed" integer DEFAULT 0,
    "close_plan_total" integer DEFAULT 6,
    "close_plan_overdue" integer DEFAULT 0,
    "momentum_score" integer,
    "last_calculated_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "deal_clarity_scores_clarity_score_check" CHECK ((("clarity_score" >= 0) AND ("clarity_score" <= 100))),
    CONSTRAINT "deal_clarity_scores_momentum_score_check" CHECK ((("momentum_score" >= 0) AND ("momentum_score" <= 100)))
);

-- ALTER TABLE "public"."deal_clarity_scores" OWNER TO "postgres";

COMMENT ON TABLE "public"."deal_clarity_scores" IS 'Denormalized clarity and momentum scores for fast dashboard queries';

CREATE TABLE IF NOT EXISTS "public"."deal_close_plan_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "deal_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "milestone_key" "text" NOT NULL,
    "title" "text" NOT NULL,
    "owner_id" "uuid",
    "due_date" "date",
    "status" "text" DEFAULT 'pending'::"text",
    "blocker_note" "text",
    "linked_task_id" "uuid",
    "sort_order" integer DEFAULT 0,
    "completed_at" timestamp with time zone,
    "completed_by" "uuid",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "deal_close_plan_items_milestone_key_check" CHECK (("milestone_key" = ANY (ARRAY['success_criteria'::"text", 'stakeholders_mapped'::"text", 'solution_fit'::"text", 'commercials_aligned'::"text", 'legal_procurement'::"text", 'signature_kickoff'::"text"]))),
    CONSTRAINT "deal_close_plan_items_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'in_progress'::"text", 'completed'::"text", 'blocked'::"text", 'skipped'::"text"])))
);

-- ALTER TABLE "public"."deal_close_plan_items" OWNER TO "postgres";

COMMENT ON TABLE "public"."deal_close_plan_items" IS 'Lightweight execution tracker with 6 standard milestones per deal';

CREATE TABLE IF NOT EXISTS "public"."deal_health_alerts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "deal_id" "uuid" NOT NULL,
    "health_score_id" "uuid",
    "user_id" "uuid" NOT NULL,
    "alert_type" "text" NOT NULL,
    "severity" "text" DEFAULT 'warning'::"text",
    "title" "text" NOT NULL,
    "message" "text" NOT NULL,
    "suggested_actions" "text"[],
    "action_priority" "text" DEFAULT 'medium'::"text",
    "status" "text" DEFAULT 'active'::"text",
    "acknowledged_at" timestamp with time zone,
    "acknowledged_by" "uuid",
    "resolved_at" timestamp with time zone,
    "dismissed_at" timestamp with time zone,
    "notification_id" "uuid",
    "notification_sent" boolean DEFAULT false,
    "notification_sent_at" timestamp with time zone,
    "metadata" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "active_alert_check" CHECK ((("status" = 'active'::"text") OR (("status" = 'acknowledged'::"text") AND ("acknowledged_at" IS NOT NULL)) OR (("status" = 'resolved'::"text") AND ("resolved_at" IS NOT NULL)) OR (("status" = 'dismissed'::"text") AND ("dismissed_at" IS NOT NULL)))),
    CONSTRAINT "deal_health_alerts_action_priority_check" CHECK (("action_priority" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'urgent'::"text"]))),
    CONSTRAINT "deal_health_alerts_alert_type_check" CHECK (("alert_type" = ANY (ARRAY['stage_stall'::"text", 'sentiment_drop'::"text", 'engagement_decline'::"text", 'no_activity'::"text", 'missed_follow_up'::"text", 'close_date_approaching'::"text", 'high_risk'::"text"]))),
    CONSTRAINT "deal_health_alerts_severity_check" CHECK (("severity" = ANY (ARRAY['info'::"text", 'warning'::"text", 'critical'::"text"]))),
    CONSTRAINT "deal_health_alerts_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'acknowledged'::"text", 'resolved'::"text", 'dismissed'::"text"])))
);

-- ALTER TABLE "public"."deal_health_alerts" OWNER TO "postgres";

COMMENT ON TABLE "public"."deal_health_alerts" IS 'Active and historical alerts for at-risk deals';

COMMENT ON COLUMN "public"."deal_health_alerts"."suggested_actions" IS 'AI-generated action recommendations for the rep';

COMMENT ON COLUMN "public"."deal_health_alerts"."metadata" IS 'Additional context like previous values, changes, specific meeting data';

CREATE TABLE IF NOT EXISTS "public"."deal_health_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "deal_id" "uuid" NOT NULL,
    "overall_health_score" integer,
    "stage_velocity_score" integer,
    "sentiment_score" integer,
    "engagement_score" integer,
    "activity_score" integer,
    "snapshot_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."deal_health_history" OWNER TO "postgres";

COMMENT ON TABLE "public"."deal_health_history" IS 'Historical snapshots of deal health scores for trend analysis';

CREATE TABLE IF NOT EXISTS "public"."deal_health_rules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "rule_name" "text" NOT NULL,
    "rule_type" "text" NOT NULL,
    "description" "text",
    "threshold_value" numeric NOT NULL,
    "threshold_operator" "text" DEFAULT '>'::"text",
    "threshold_unit" "text",
    "alert_severity" "text" DEFAULT 'warning'::"text",
    "alert_message_template" "text",
    "suggested_action_template" "text",
    "conditions" "jsonb",
    "is_active" boolean DEFAULT true,
    "is_system_rule" boolean DEFAULT false,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "deal_health_rules_alert_severity_check" CHECK (("alert_severity" = ANY (ARRAY['info'::"text", 'warning'::"text", 'critical'::"text"]))),
    CONSTRAINT "deal_health_rules_rule_type_check" CHECK (("rule_type" = ANY (ARRAY['stage_velocity'::"text", 'sentiment'::"text", 'engagement'::"text", 'activity'::"text", 'response_time'::"text"]))),
    CONSTRAINT "deal_health_rules_threshold_operator_check" CHECK (("threshold_operator" = ANY (ARRAY['>'::"text", '<'::"text", '>='::"text", '<='::"text", '='::"text"])))
);

-- ALTER TABLE "public"."deal_health_rules" OWNER TO "postgres";

COMMENT ON TABLE "public"."deal_health_rules" IS 'Configurable thresholds and rules for health monitoring (admin-managed)';

COMMENT ON COLUMN "public"."deal_health_rules"."conditions" IS 'JSONB conditions for when rule applies (e.g., stage, deal value, etc.)';

COMMENT ON COLUMN "public"."deal_health_rules"."is_system_rule" IS 'System rules cannot be deleted, only deactivated';

CREATE TABLE IF NOT EXISTS "public"."deal_health_scores" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "deal_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "overall_health_score" integer,
    "health_status" "text" DEFAULT 'healthy'::"text",
    "stage_velocity_score" integer,
    "sentiment_score" integer,
    "engagement_score" integer,
    "activity_score" integer,
    "response_time_score" integer,
    "days_in_current_stage" integer DEFAULT 0,
    "days_since_last_meeting" integer,
    "days_since_last_activity" integer,
    "avg_sentiment_last_3_meetings" numeric,
    "sentiment_trend" "text",
    "meeting_count_last_30_days" integer DEFAULT 0,
    "activity_count_last_30_days" integer DEFAULT 0,
    "avg_response_time_hours" numeric,
    "risk_factors" "text"[],
    "risk_level" "text" DEFAULT 'low'::"text",
    "predicted_close_probability" integer,
    "predicted_days_to_close" integer,
    "last_calculated_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "deal_health_scores_activity_score_check" CHECK ((("activity_score" >= 0) AND ("activity_score" <= 100))),
    CONSTRAINT "deal_health_scores_engagement_score_check" CHECK ((("engagement_score" >= 0) AND ("engagement_score" <= 100))),
    CONSTRAINT "deal_health_scores_health_status_check" CHECK (("health_status" = ANY (ARRAY['healthy'::"text", 'warning'::"text", 'critical'::"text", 'stalled'::"text"]))),
    CONSTRAINT "deal_health_scores_overall_health_score_check" CHECK ((("overall_health_score" >= 0) AND ("overall_health_score" <= 100))),
    CONSTRAINT "deal_health_scores_predicted_close_probability_check" CHECK ((("predicted_close_probability" >= 0) AND ("predicted_close_probability" <= 100))),
    CONSTRAINT "deal_health_scores_response_time_score_check" CHECK ((("response_time_score" >= 0) AND ("response_time_score" <= 100))),
    CONSTRAINT "deal_health_scores_risk_level_check" CHECK (("risk_level" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'critical'::"text"]))),
    CONSTRAINT "deal_health_scores_sentiment_score_check" CHECK ((("sentiment_score" >= 0) AND ("sentiment_score" <= 100))),
    CONSTRAINT "deal_health_scores_sentiment_trend_check" CHECK (("sentiment_trend" = ANY (ARRAY['improving'::"text", 'stable'::"text", 'declining'::"text", 'unknown'::"text"]))),
    CONSTRAINT "deal_health_scores_stage_velocity_score_check" CHECK ((("stage_velocity_score" >= 0) AND ("stage_velocity_score" <= 100)))
);

-- ALTER TABLE "public"."deal_health_scores" OWNER TO "postgres";

COMMENT ON TABLE "public"."deal_health_scores" IS 'Stores calculated health metrics for deals using multi-signal analysis';

COMMENT ON COLUMN "public"."deal_health_scores"."overall_health_score" IS 'Composite health score (0-100) based on all signals';

COMMENT ON COLUMN "public"."deal_health_scores"."sentiment_trend" IS 'Trend direction based on last 3-5 meetings';

COMMENT ON COLUMN "public"."deal_health_scores"."risk_factors" IS 'Array of identified risk factors (e.g., ["sentiment_declining", "no_meetings"])';

CREATE TABLE IF NOT EXISTS "public"."deal_migration_reviews" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "deal_id" "uuid" NOT NULL,
    "reason" "text" NOT NULL,
    "original_company" "text",
    "original_contact_name" "text",
    "original_contact_email" "text",
    "suggested_company_id" "uuid",
    "suggested_contact_id" "uuid",
    "resolution_notes" "text",
    "status" "text" DEFAULT 'pending'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "resolved_at" timestamp with time zone,
    "resolved_by" "uuid",
    CONSTRAINT "deal_migration_reviews_reason_check" CHECK (("reason" = ANY (ARRAY['no_email'::"text", 'invalid_email'::"text", 'fuzzy_match_uncertainty'::"text", 'entity_creation_failed'::"text"]))),
    CONSTRAINT "deal_migration_reviews_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'resolved'::"text", 'archived'::"text"])))
);

-- ALTER TABLE "public"."deal_migration_reviews" OWNER TO "postgres";

-- ALTER TABLE "public"."deals" OWNER TO "postgres";

COMMENT ON COLUMN "public"."deals"."value" IS 'Total deal value: one_off + (mrr * 3) - auto-calculated';

COMMENT ON COLUMN "public"."deals"."expected_close_date" IS 'Expected date when the deal will close';

COMMENT ON COLUMN "public"."deals"."one_off_revenue" IS 'One-time payment amount';

COMMENT ON COLUMN "public"."deals"."monthly_mrr" IS 'Monthly Recurring Revenue amount';

COMMENT ON COLUMN "public"."deals"."annual_value" IS 'Calculated annual value: one_off + (mrr * 12) - auto-updated';

COMMENT ON COLUMN "public"."deals"."savvycal_booking_id" IS 'SavvyCal event ID (from CSV id column)';

COMMENT ON COLUMN "public"."deals"."savvycal_link_id" IS 'SavvyCal booking link ID (from CSV link_id column) for source mapping';

COMMENT ON COLUMN "public"."deals"."clerk_org_id" IS 'Clerk Organization ID - links to Clerk Organizations API';

CREATE OR REPLACE VIEW "public"."deal_migration_review_details" WITH ("security_invoker"='true') AS
 SELECT "dmr"."id" AS "review_id",
    "dmr"."deal_id",
    "dmr"."reason",
    "dmr"."status",
    "dmr"."original_company",
    "dmr"."original_contact_name",
    "dmr"."original_contact_email",
    "dmr"."suggested_company_id",
    "dmr"."suggested_contact_id",
    "dmr"."resolution_notes",
    "dmr"."created_at" AS "flagged_at",
    "dmr"."resolved_at",
    "d"."name" AS "deal_name",
    "d"."value" AS "deal_value",
    "d"."owner_id",
    "p"."email" AS "owner_email",
    "sc"."name" AS "suggested_company_name",
    "sct"."full_name" AS "suggested_contact_name"
   FROM (((("public"."deal_migration_reviews" "dmr"
     JOIN "public"."deals" "d" ON (("dmr"."deal_id" = "d"."id")))
     LEFT JOIN "public"."profiles" "p" ON (("d"."owner_id" = "p"."id")))
     LEFT JOIN "public"."companies" "sc" ON (("dmr"."suggested_company_id" = "sc"."id")))
     LEFT JOIN "public"."contacts" "sct" ON (("dmr"."suggested_contact_id" = "sct"."id")))
  WHERE ("dmr"."status" = 'pending'::"text")
  ORDER BY "dmr"."created_at" DESC;

-- ALTER VIEW "public"."deal_migration_review_details" OWNER TO "postgres";

-- ALTER TABLE "public"."deal_notes" OWNER TO "postgres";

COMMENT ON TABLE "public"."deal_notes" IS 'Stores notes and annotations related to deals for team collaboration';

COMMENT ON COLUMN "public"."deal_notes"."deal_id" IS 'Reference to the deal this note belongs to';

COMMENT ON COLUMN "public"."deal_notes"."title" IS 'Short descriptive title for the note';

COMMENT ON COLUMN "public"."deal_notes"."content" IS 'Main content of the note (supports rich text)';

COMMENT ON COLUMN "public"."deal_notes"."created_by" IS 'User who created this note';

COMMENT ON COLUMN "public"."deal_notes"."is_pinned" IS 'Whether this note is pinned for quick access';

COMMENT ON COLUMN "public"."deal_notes"."tags" IS 'Array of tags for categorizing notes';

CREATE TABLE IF NOT EXISTS "public"."deal_risk_aggregates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "deal_id" "uuid",
    "org_id" "uuid" NOT NULL,
    "overall_risk_level" "text",
    "risk_score" integer,
    "active_signals_count" integer DEFAULT 0,
    "critical_signals_count" integer DEFAULT 0,
    "high_signals_count" integer DEFAULT 0,
    "medium_signals_count" integer DEFAULT 0,
    "low_signals_count" integer DEFAULT 0,
    "signal_breakdown" "jsonb" DEFAULT '{}'::"jsonb",
    "sentiment_trend" "text",
    "avg_sentiment_last_3_meetings" numeric,
    "sentiment_change_pct" numeric,
    "days_since_last_meeting" integer,
    "days_since_champion_contact" integer,
    "meeting_frequency_trend" "text",
    "last_forward_movement_at" timestamp with time zone,
    "days_without_forward_movement" integer,
    "recommended_actions" "jsonb" DEFAULT '[]'::"jsonb",
    "risk_summary" "text",
    "last_calculated_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "deal_risk_aggregates_meeting_frequency_trend_check" CHECK (("meeting_frequency_trend" = ANY (ARRAY['increasing'::"text", 'stable'::"text", 'decreasing'::"text", 'unknown'::"text"]))),
    CONSTRAINT "deal_risk_aggregates_overall_risk_level_check" CHECK (("overall_risk_level" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'critical'::"text"]))),
    CONSTRAINT "deal_risk_aggregates_risk_score_check" CHECK ((("risk_score" >= 0) AND ("risk_score" <= 100))),
    CONSTRAINT "deal_risk_aggregates_sentiment_trend_check" CHECK (("sentiment_trend" = ANY (ARRAY['improving'::"text", 'stable'::"text", 'declining'::"text", 'unknown'::"text"])))
);

-- ALTER TABLE "public"."deal_risk_aggregates" OWNER TO "postgres";

COMMENT ON TABLE "public"."deal_risk_aggregates" IS 'Aggregated risk summary per deal for fast dashboard queries';

CREATE TABLE IF NOT EXISTS "public"."deal_risk_signals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "deal_id" "uuid",
    "org_id" "uuid" NOT NULL,
    "signal_type" "text" NOT NULL,
    "severity" "text" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text" NOT NULL,
    "evidence" "jsonb" DEFAULT '{}'::"jsonb",
    "source_meeting_id" "uuid",
    "confidence_score" numeric,
    "is_resolved" boolean DEFAULT false,
    "resolved_at" timestamp with time zone,
    "resolved_by" "uuid",
    "resolution_notes" "text",
    "resolution_action" "text",
    "auto_dismissed" boolean DEFAULT false,
    "dismissed_reason" "text",
    "detected_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "deal_risk_signals_confidence_score_check" CHECK ((("confidence_score" >= (0)::numeric) AND ("confidence_score" <= (1)::numeric))),
    CONSTRAINT "deal_risk_signals_severity_check" CHECK (("severity" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'critical'::"text"]))),
    CONSTRAINT "deal_risk_signals_signal_type_check" CHECK (("signal_type" = ANY (ARRAY['timeline_slip'::"text", 'budget_concern'::"text", 'competitor_mention'::"text", 'champion_silent'::"text", 'sentiment_decline'::"text", 'stalled_deal'::"text", 'objection_unresolved'::"text", 'stakeholder_concern'::"text", 'scope_creep'::"text", 'decision_delay'::"text"])))
);

-- ALTER TABLE "public"."deal_risk_signals" OWNER TO "postgres";

COMMENT ON TABLE "public"."deal_risk_signals" IS 'Individual risk signals detected from meeting analysis';

CREATE OR REPLACE VIEW "public"."deal_sentiment_trends" WITH ("security_invoker"='true') AS
 WITH "deal_meeting_data" AS (
         SELECT DISTINCT "a"."deal_id",
            "m"."id" AS "meeting_id",
            "m"."sentiment_score",
            "m"."meeting_start",
            "m"."talk_time_rep_pct",
            "m"."coach_rating"
           FROM ("public"."activities" "a"
             JOIN "public"."meetings" "m" ON (("m"."id" = "a"."meeting_id")))
          WHERE (("a"."deal_id" IS NOT NULL) AND ("a"."meeting_id" IS NOT NULL) AND ("m"."sentiment_score" IS NOT NULL))
        ), "ranked_meetings" AS (
         SELECT "deal_meeting_data"."deal_id",
            "deal_meeting_data"."meeting_id",
            "deal_meeting_data"."sentiment_score",
            "deal_meeting_data"."meeting_start",
            "deal_meeting_data"."talk_time_rep_pct",
            "deal_meeting_data"."coach_rating",
            "row_number"() OVER (PARTITION BY "deal_meeting_data"."deal_id" ORDER BY "deal_meeting_data"."meeting_start" DESC NULLS LAST) AS "rn"
           FROM "deal_meeting_data"
        ), "aggregated" AS (
         SELECT "ranked_meetings"."deal_id",
            ("avg"("ranked_meetings"."sentiment_score"))::numeric(4,3) AS "avg_sentiment",
            ("min"("ranked_meetings"."sentiment_score"))::numeric(4,3) AS "min_sentiment",
            ("max"("ranked_meetings"."sentiment_score"))::numeric(4,3) AS "max_sentiment",
            ("count"(DISTINCT "ranked_meetings"."meeting_id"))::integer AS "meeting_count",
            "max"("ranked_meetings"."meeting_start") AS "last_meeting_at",
            ("avg"(
                CASE
                    WHEN ("ranked_meetings"."rn" <= 3) THEN "ranked_meetings"."sentiment_score"
                    ELSE NULL::numeric
                END))::numeric(4,3) AS "recent_avg",
            ("avg"(
                CASE
                    WHEN (("ranked_meetings"."rn" > 3) AND ("ranked_meetings"."rn" <= 6)) THEN "ranked_meetings"."sentiment_score"
                    ELSE NULL::numeric
                END))::numeric(4,3) AS "previous_avg",
            ("avg"("ranked_meetings"."talk_time_rep_pct"))::numeric(5,2) AS "avg_talk_time_rep_pct",
            ("avg"("ranked_meetings"."coach_rating"))::numeric(4,2) AS "avg_coach_rating",
            ARRAY( SELECT "rm2"."sentiment_score"
                   FROM "ranked_meetings" "rm2"
                  WHERE (("rm2"."deal_id" = "ranked_meetings"."deal_id") AND ("rm2"."rn" <= 6))
                  ORDER BY "rm2"."rn" DESC) AS "sentiment_history"
           FROM "ranked_meetings"
          GROUP BY "ranked_meetings"."deal_id"
        )
 SELECT "deal_id",
    "avg_sentiment",
    "min_sentiment",
    "max_sentiment",
    "meeting_count",
    "last_meeting_at",
    "recent_avg",
    "previous_avg",
    "avg_talk_time_rep_pct",
    "avg_coach_rating",
    "sentiment_history",
        CASE
            WHEN ("previous_avg" IS NULL) THEN 'insufficient_data'::"text"
            WHEN (("recent_avg" - "previous_avg") > 0.1) THEN 'improving'::"text"
            WHEN (("recent_avg" - "previous_avg") < '-0.1'::numeric) THEN 'declining'::"text"
            ELSE 'stable'::"text"
        END AS "trend_direction",
        CASE
            WHEN ("previous_avg" IS NULL) THEN (0)::numeric
            ELSE (("recent_avg" - "previous_avg"))::numeric(4,3)
        END AS "trend_delta"
   FROM "aggregated";

-- ALTER VIEW "public"."deal_sentiment_trends" OWNER TO "postgres";

-- ALTER TABLE "public"."deal_splits" OWNER TO "postgres";

CREATE OR REPLACE VIEW "public"."deal_splits_with_users" WITH ("security_invoker"='true') AS
 SELECT "ds"."id",
    "ds"."deal_id",
    "ds"."user_id",
    "ds"."percentage",
    "ds"."amount",
    "ds"."notes",
    "ds"."created_at",
    "ds"."updated_at",
    "ds"."clerk_org_id",
    "p"."first_name",
    "p"."last_name",
    "p"."email",
    (("p"."first_name" || ' '::"text") || "p"."last_name") AS "full_name",
    "d"."name" AS "deal_name",
    "d"."value" AS "deal_value",
    "d"."owner_id" AS "deal_owner_id"
   FROM (("public"."deal_splits" "ds"
     JOIN "public"."profiles" "p" ON (("ds"."user_id" = "p"."id")))
     JOIN "public"."deals" "d" ON (("ds"."deal_id" = "d"."id")));

-- ALTER VIEW "public"."deal_splits_with_users" OWNER TO "postgres";

COMMENT ON VIEW "public"."deal_splits_with_users" IS 'Deal splits with user profile information (security_invoker enabled)';

-- ALTER TABLE "public"."deal_stage_history" OWNER TO "postgres";

COMMENT ON TABLE "public"."deal_stage_history" IS 'Tracks deal stage transitions for pipeline analytics';

-- ALTER TABLE "public"."deal_stages" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."deal_truth_fields" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "deal_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "field_key" "text" NOT NULL,
    "value" "text",
    "confidence" numeric(3,2) DEFAULT 0.50,
    "source" "text",
    "source_id" "uuid",
    "contact_id" "uuid",
    "champion_strength" "text",
    "next_step_date" "date",
    "last_updated_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "deal_truth_fields_champion_strength_check" CHECK (("champion_strength" = ANY (ARRAY['strong'::"text", 'moderate'::"text", 'weak'::"text", 'unknown'::"text"]))),
    CONSTRAINT "deal_truth_fields_confidence_check" CHECK ((("confidence" >= (0)::numeric) AND ("confidence" <= (1)::numeric))),
    CONSTRAINT "deal_truth_fields_field_key_check" CHECK (("field_key" = ANY (ARRAY['pain'::"text", 'success_metric'::"text", 'champion'::"text", 'economic_buyer'::"text", 'next_step'::"text", 'top_risks'::"text"]))),
    CONSTRAINT "deal_truth_fields_source_check" CHECK (("source" = ANY (ARRAY['meeting_transcript'::"text", 'email'::"text", 'crm_sync'::"text", 'manual'::"text", 'ai_inferred'::"text"])))
);

-- ALTER TABLE "public"."deal_truth_fields" OWNER TO "postgres";

COMMENT ON TABLE "public"."deal_truth_fields" IS 'Core deal truth fields (pain, champion, EB, next step, etc.) with confidence scoring';

-- ALTER TABLE "public"."email_attachments" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."email_categorizations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid",
    "external_id" "text" NOT NULL,
    "thread_id" "text",
    "direction" "text" NOT NULL,
    "received_at" timestamp with time zone,
    "category" "text" NOT NULL,
    "category_confidence" numeric,
    "signals" "jsonb" DEFAULT '{}'::"jsonb",
    "source" "text" NOT NULL,
    "communication_event_id" "uuid",
    "gmail_label_applied" boolean DEFAULT false,
    "gmail_label_applied_at" timestamp with time zone,
    "processed_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "email_categorizations_category_check" CHECK (("category" = ANY (ARRAY['to_respond'::"text", 'fyi'::"text", 'marketing'::"text", 'calendar_related'::"text", 'automated'::"text", 'uncategorized'::"text"]))),
    CONSTRAINT "email_categorizations_category_confidence_check" CHECK ((("category_confidence" >= (0)::numeric) AND ("category_confidence" <= (1)::numeric))),
    CONSTRAINT "email_categorizations_direction_check" CHECK (("direction" = ANY (ARRAY['inbound'::"text", 'outbound'::"text"]))),
    CONSTRAINT "email_categorizations_source_check" CHECK (("source" = ANY (ARRAY['ai'::"text", 'rules'::"text", 'label_map'::"text", 'user_override'::"text"])))
);

-- ALTER TABLE "public"."email_categorizations" OWNER TO "postgres";

COMMENT ON TABLE "public"."email_categorizations" IS 'Fyxer-style email categorizations with AI/rules-derived categories and sales signals';

COMMENT ON COLUMN "public"."email_categorizations"."category" IS 'Fyxer-style category: to_respond, fyi, marketing, calendar_related, automated, uncategorized';

COMMENT ON COLUMN "public"."email_categorizations"."signals" IS 'JSONB with sales signals: response_required, urgency, deal_id, contact_id, sentiment, ghost_risk, etc.';

COMMENT ON COLUMN "public"."email_categorizations"."source" IS 'How this categorization was determined: ai, rules, label_map, user_override';

CREATE TABLE IF NOT EXISTS "public"."email_journeys" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "journey_name" "text" NOT NULL,
    "trigger_event" "text" NOT NULL,
    "delay_minutes" integer DEFAULT 0,
    "email_template_id" "text",
    "email_type" "text" NOT NULL,
    "conditions" "jsonb" DEFAULT '{}'::"jsonb",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."email_journeys" OWNER TO "postgres";

COMMENT ON TABLE "public"."email_journeys" IS 'Email journey definitions that map events to email sends';

CREATE TABLE IF NOT EXISTS "public"."email_label_map" (
    "email_id" "uuid" NOT NULL,
    "label_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."email_label_map" OWNER TO "postgres";

-- ALTER TABLE "public"."email_labels" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."email_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "email_type" "text" NOT NULL,
    "to_email" "text" NOT NULL,
    "user_id" "uuid",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "error" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "sent_via" "text" DEFAULT 'encharge'::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."email_logs" OWNER TO "postgres";

COMMENT ON TABLE "public"."email_logs" IS 'Logs all transactional and marketing emails sent via Encharge.io';

CREATE TABLE IF NOT EXISTS "public"."email_sends" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "journey_id" "uuid",
    "email_type" "text" NOT NULL,
    "status" "text" DEFAULT 'sent'::"text",
    "encharge_message_id" "text",
    "to_email" "text" NOT NULL,
    "sent_at" timestamp with time zone DEFAULT "now"(),
    "opened_at" timestamp with time zone,
    "clicked_at" timestamp with time zone,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);

-- ALTER TABLE "public"."email_sends" OWNER TO "postgres";

COMMENT ON TABLE "public"."email_sends" IS 'Tracks all email sends for deduplication and analytics';

-- ALTER TABLE "public"."email_templates" OWNER TO "postgres";

-- ALTER TABLE "public"."email_threads" OWNER TO "postgres";

-- ALTER TABLE "public"."emails" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."encharge_email_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "template_name" "text" NOT NULL,
    "template_type" "text" NOT NULL,
    "subject_line" "text" NOT NULL,
    "html_body" "text" NOT NULL,
    "text_body" "text",
    "variables" "jsonb" DEFAULT '{}'::"jsonb",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."encharge_email_templates" OWNER TO "postgres";

COMMENT ON TABLE "public"."encharge_email_templates" IS 'Email templates for Encharge email journeys - includes waitlist welcome and magic link templates';

COMMENT ON COLUMN "public"."encharge_email_templates"."variables" IS 'JSON object describing available template variables';

CREATE TABLE IF NOT EXISTS "public"."execution_checkpoints" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "execution_id" "uuid" NOT NULL,
    "workflow_id" "uuid" NOT NULL,
    "checkpoint_name" "text" NOT NULL,
    "node_id" "text" NOT NULL,
    "state" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "variables" "jsonb" DEFAULT '{}'::"jsonb",
    "node_outputs" "jsonb" DEFAULT '{}'::"jsonb",
    "can_resume" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."execution_checkpoints" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."execution_snapshots" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "execution_id" "uuid" NOT NULL,
    "workflow_id" "uuid" NOT NULL,
    "node_id" "text" NOT NULL,
    "sequence_number" integer NOT NULL,
    "snapshot_type" "text",
    "state" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "variables" "jsonb" DEFAULT '{}'::"jsonb",
    "node_outputs" "jsonb" DEFAULT '{}'::"jsonb",
    "http_requests" "jsonb" DEFAULT '[]'::"jsonb",
    "error_details" "jsonb",
    "memory_usage" integer,
    "cpu_time" integer,
    "timestamp" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "execution_snapshots_snapshot_type_check" CHECK (("snapshot_type" = ANY (ARRAY['before'::"text", 'after'::"text", 'error'::"text"])))
);

-- ALTER TABLE "public"."execution_snapshots" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."fathom_integrations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "access_token" "text" NOT NULL,
    "refresh_token" "text" NOT NULL,
    "token_expires_at" timestamp with time zone NOT NULL,
    "fathom_user_id" "text",
    "fathom_user_email" "text",
    "scopes" "text"[] DEFAULT ARRAY['calls:read'::"text", 'analytics:read'::"text", 'highlights:write'::"text"],
    "is_active" boolean DEFAULT true,
    "last_sync_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."fathom_integrations" OWNER TO "postgres";

COMMENT ON TABLE "public"."fathom_integrations" IS 'Per-user Fathom integrations. Each user connects their own Fathom account because OAuth tokens only grant access to recordings owned by the authenticated user.';

CREATE TABLE IF NOT EXISTS "public"."fathom_oauth_states" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "state" "text" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "expires_at" timestamp with time zone NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "org_id" "uuid"
);

-- ALTER TABLE "public"."fathom_oauth_states" OWNER TO "postgres";

COMMENT ON TABLE "public"."fathom_oauth_states" IS 'Stores OAuth state parameters for CSRF protection during Fathom OAuth flow';

CREATE TABLE IF NOT EXISTS "public"."fathom_org_credentials" (
    "org_id" "uuid" NOT NULL,
    "access_token" "text" NOT NULL,
    "refresh_token" "text" NOT NULL,
    "token_expires_at" timestamp with time zone NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."fathom_org_credentials" OWNER TO "postgres";

COMMENT ON TABLE "public"."fathom_org_credentials" IS 'Org-scoped Fathom OAuth credentials (service-role-only).';

CREATE TABLE IF NOT EXISTS "public"."fathom_org_integrations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "connected_by_user_id" "uuid",
    "fathom_user_id" "text",
    "fathom_user_email" "text",
    "scopes" "text"[] DEFAULT ARRAY['public_api'::"text"],
    "is_active" boolean DEFAULT true,
    "last_sync_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."fathom_org_integrations" OWNER TO "postgres";

COMMENT ON TABLE "public"."fathom_org_integrations" IS 'DEPRECATED: Org-scoped Fathom integrations. Kept for data preservation. New integrations should use per-user fathom_integrations table.';

CREATE TABLE IF NOT EXISTS "public"."fathom_org_sync_state" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "integration_id" "uuid" NOT NULL,
    "sync_status" "text" DEFAULT 'idle'::"text" NOT NULL,
    "cursor_position" "text",
    "last_successful_sync" timestamp with time zone,
    "last_sync_started_at" timestamp with time zone,
    "last_sync_completed_at" timestamp with time zone,
    "error_message" "text",
    "error_count" integer DEFAULT 0,
    "last_error_at" timestamp with time zone,
    "meetings_synced" integer DEFAULT 0,
    "total_meetings_found" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "fathom_org_sync_state_sync_status_check" CHECK (("sync_status" = ANY (ARRAY['idle'::"text", 'syncing'::"text", 'error'::"text"])))
);

-- ALTER TABLE "public"."fathom_org_sync_state" OWNER TO "postgres";

COMMENT ON TABLE "public"."fathom_org_sync_state" IS 'Tracks org-level Fathom sync progress and metrics.';

CREATE TABLE IF NOT EXISTS "public"."fathom_sync_state" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "integration_id" "uuid" NOT NULL,
    "last_successful_sync" timestamp with time zone,
    "cursor_position" "text",
    "sync_status" "text" DEFAULT 'idle'::"text" NOT NULL,
    "last_sync_error" "text",
    "error_count" integer DEFAULT 0,
    "last_error_at" timestamp with time zone,
    "meetings_synced" integer DEFAULT 0,
    "total_meetings_found" integer DEFAULT 0,
    "sync_date_range_start" timestamp with time zone,
    "sync_date_range_end" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "last_sync_started_at" timestamp with time zone,
    "last_sync_completed_at" timestamp with time zone,
    CONSTRAINT "fathom_sync_state_sync_status_check" CHECK (("sync_status" = ANY (ARRAY['idle'::"text", 'syncing'::"text", 'error'::"text"])))
);

-- ALTER TABLE "public"."fathom_sync_state" OWNER TO "postgres";

COMMENT ON TABLE "public"."fathom_sync_state" IS 'Tracks sync progress and status for each user Fathom integration';

COMMENT ON COLUMN "public"."fathom_sync_state"."last_sync_error" IS 'Error message from the most recent sync (if any)';

COMMENT ON COLUMN "public"."fathom_sync_state"."last_sync_started_at" IS 'Timestamp when the most recent sync started';

COMMENT ON COLUMN "public"."fathom_sync_state"."last_sync_completed_at" IS 'Timestamp when the most recent sync completed';

CREATE TABLE IF NOT EXISTS "public"."fathom_transcript_retry_jobs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "recording_id" "text" NOT NULL,
    "attempt_count" integer DEFAULT 0 NOT NULL,
    "max_attempts" integer DEFAULT 5 NOT NULL,
    "next_retry_at" timestamp with time zone NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "last_error" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "completed_at" timestamp with time zone,
    CONSTRAINT "fathom_transcript_retry_jobs_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text"])))
);

-- ALTER TABLE "public"."fathom_transcript_retry_jobs" OWNER TO "postgres";

COMMENT ON TABLE "public"."fathom_transcript_retry_jobs" IS 'Queue for retrying transcript fetches with 5Ã—5min backoff';

COMMENT ON COLUMN "public"."fathom_transcript_retry_jobs"."attempt_count" IS 'Number of retry attempts made (starts at 1 after initial webhook attempt)';

COMMENT ON COLUMN "public"."fathom_transcript_retry_jobs"."max_attempts" IS 'Maximum number of retry attempts (default: 5)';

COMMENT ON COLUMN "public"."fathom_transcript_retry_jobs"."next_retry_at" IS 'When to retry next (5 minutes after last attempt)';

COMMENT ON COLUMN "public"."fathom_transcript_retry_jobs"."status" IS 'Job status: pending, processing, completed, failed';

CREATE TABLE IF NOT EXISTS "public"."fathom_user_mappings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "fathom_user_email" "text" NOT NULL,
    "fathom_user_name" "text",
    "sixty_user_id" "uuid",
    "is_auto_matched" boolean DEFAULT false,
    "last_seen_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."fathom_user_mappings" OWNER TO "postgres";

COMMENT ON TABLE "public"."fathom_user_mappings" IS 'Maps Fathom users (by email) to Sixty users for meeting ownership attribution';

COMMENT ON COLUMN "public"."fathom_user_mappings"."fathom_user_email" IS 'Lowercased email from Fathom (recorded_by.email, host_email, etc.)';

COMMENT ON COLUMN "public"."fathom_user_mappings"."sixty_user_id" IS 'The Sixty user this Fathom user maps to. NULL if not yet mapped.';

COMMENT ON COLUMN "public"."fathom_user_mappings"."is_auto_matched" IS 'True if mapping was created automatically because emails matched';

COMMENT ON COLUMN "public"."fathom_user_mappings"."last_seen_at" IS 'Updated each time a meeting is synced with this Fathom user';

-- ALTER TABLE "public"."ghost_detection_signals" OWNER TO "postgres";

COMMENT ON TABLE "public"."ghost_detection_signals" IS 'Tracks specific behavioral signals that indicate ghosting risk';

COMMENT ON COLUMN "public"."ghost_detection_signals"."signal_context" IS 'Human-readable description of why this signal was detected';

COMMENT ON COLUMN "public"."ghost_detection_signals"."signal_data" IS 'JSONB containing raw data that triggered the signal (baseline vs current values, etc.)';

COMMENT ON COLUMN "public"."ghost_detection_signals"."resolved_at" IS 'Timestamp when signal was resolved (e.g., prospect responded, meeting rescheduled)';

CREATE TABLE IF NOT EXISTS "public"."global_topic_sources" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "global_topic_id" "uuid" NOT NULL,
    "meeting_id" "uuid" NOT NULL,
    "topic_index" integer NOT NULL,
    "topic_title" "text" NOT NULL,
    "topic_description" "text",
    "timestamp_seconds" integer,
    "fathom_url" "text",
    "meeting_date" timestamp with time zone,
    "company_id" "uuid",
    "contact_id" "uuid",
    "similarity_score" numeric(5,4) DEFAULT 1.0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

-- ALTER TABLE "public"."global_topic_sources" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."global_topics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "canonical_title" "text" NOT NULL,
    "canonical_description" "text",
    "source_count" integer DEFAULT 1 NOT NULL,
    "first_seen_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "last_seen_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "frequency_score" numeric(5,4) DEFAULT 0.0 NOT NULL,
    "recency_score" numeric(5,4) DEFAULT 0.0 NOT NULL,
    "relevance_score" numeric(5,4) DEFAULT 0.0 NOT NULL,
    "is_archived" boolean DEFAULT false NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "deleted_at" timestamp with time zone
);

-- ALTER TABLE "public"."global_topics" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."gmail_label_mappings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid",
    "category_key" "text" NOT NULL,
    "gmail_label_id" "text" NOT NULL,
    "gmail_label_name" "text" NOT NULL,
    "is_sixty_managed" boolean DEFAULT false,
    "sync_direction" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "gmail_label_mappings_category_key_check" CHECK (("category_key" = ANY (ARRAY['to_respond'::"text", 'fyi'::"text", 'marketing'::"text", 'calendar_related'::"text", 'automated'::"text"]))),
    CONSTRAINT "gmail_label_mappings_sync_direction_check" CHECK (("sync_direction" = ANY (ARRAY['gmail_to_sixty'::"text", 'sixty_to_gmail'::"text", 'bidirectional'::"text", 'none'::"text"])))
);

-- ALTER TABLE "public"."gmail_label_mappings" OWNER TO "postgres";

COMMENT ON TABLE "public"."gmail_label_mappings" IS 'Maps Gmail labels to Sixty categories for bidirectional sync';

COMMENT ON COLUMN "public"."gmail_label_mappings"."is_sixty_managed" IS 'True if Sixty created this label in Gmail (vs user mapping existing label)';

COMMENT ON COLUMN "public"."gmail_label_mappings"."sync_direction" IS 'Direction of sync: gmail_to_sixty, sixty_to_gmail, bidirectional, none';

CREATE TABLE IF NOT EXISTS "public"."google_calendar_channels" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "channel_id" "text" NOT NULL,
    "resource_id" "text" NOT NULL,
    "calendar_id" "text" DEFAULT 'primary'::"text" NOT NULL,
    "webhook_url" "text" NOT NULL,
    "expiration_time" timestamp with time zone NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "last_notification_at" timestamp with time zone,
    "notification_count" integer DEFAULT 0 NOT NULL,
    "sync_token" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "last_message_number" bigint DEFAULT 0
);

-- ALTER TABLE "public"."google_calendar_channels" OWNER TO "postgres";

COMMENT ON TABLE "public"."google_calendar_channels" IS 'Tracks Google Calendar push notification webhook subscriptions for real-time calendar sync';

COMMENT ON COLUMN "public"."google_calendar_channels"."last_message_number" IS 'Last processed X-Goog-Message-Number from Google Calendar webhook. Used to prevent processing duplicate or out-of-order notifications.';

CREATE TABLE IF NOT EXISTS "public"."google_calendars" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "integration_id" "uuid" NOT NULL,
    "calendar_id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "time_zone" "text",
    "color_id" "text",
    "is_primary" boolean DEFAULT false,
    "access_role" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."google_calendars" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."google_docs_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "name" "text" NOT NULL,
    "description" "text",
    "template_type" "text" NOT NULL,
    "template_content" "jsonb" NOT NULL,
    "is_global" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."google_docs_templates" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."google_drive_folders" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "integration_id" "uuid" NOT NULL,
    "folder_id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "path" "text",
    "parent_id" "text",
    "mime_type" "text" DEFAULT 'application/vnd.google-apps.folder'::"text",
    "web_view_link" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."google_drive_folders" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."google_email_labels" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "integration_id" "uuid" NOT NULL,
    "label_id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "type" "text",
    "message_list_visibility" "text",
    "label_list_visibility" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."google_email_labels" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."google_oauth_states" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "state" "text" NOT NULL,
    "code_verifier" "text" NOT NULL,
    "code_challenge" "text" NOT NULL,
    "redirect_uri" "text" NOT NULL,
    "expires_at" timestamp with time zone DEFAULT ("now"() + '00:10:00'::interval) NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."google_oauth_states" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."google_service_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "integration_id" "uuid",
    "service" "text" NOT NULL,
    "action" "text" NOT NULL,
    "status" "text" NOT NULL,
    "request_data" "jsonb",
    "response_data" "jsonb",
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."google_service_logs" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."google_task_lists" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "google_list_id" "text" NOT NULL,
    "title" "text" NOT NULL,
    "etag" "text",
    "is_default" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "integration_id" "uuid"
);

-- ALTER TABLE "public"."google_task_lists" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."google_task_mappings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "task_id" "uuid" NOT NULL,
    "google_task_id" "text" NOT NULL,
    "google_list_id" "text" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "etag" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "sync_direction" "text" DEFAULT 'bidirectional'::"text"
);

-- ALTER TABLE "public"."google_task_mappings" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."google_tasks_list_configs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "google_list_id" "text" NOT NULL,
    "list_title" "text" NOT NULL,
    "sync_direction" "text" DEFAULT 'bidirectional'::"text" NOT NULL,
    "is_primary" boolean DEFAULT false,
    "priority_filter" "text"[] DEFAULT '{}'::"text"[],
    "task_categories" "text"[] DEFAULT '{}'::"text"[],
    "status_filter" "text"[] DEFAULT '{}'::"text"[],
    "auto_create_in_list" boolean DEFAULT true,
    "sync_enabled" boolean DEFAULT true,
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "google_tasks_list_configs_sync_direction_check" CHECK (("sync_direction" = ANY (ARRAY['bidirectional'::"text", 'to_google'::"text", 'from_google'::"text"])))
);

-- ALTER TABLE "public"."google_tasks_list_configs" OWNER TO "postgres";

COMMENT ON TABLE "public"."google_tasks_list_configs" IS 'Configuration for syncing tasks with multiple Google Task lists with filtering rules';

COMMENT ON COLUMN "public"."google_tasks_list_configs"."is_primary" IS 'Primary list receives all tasks by default unless filtered to other lists';

COMMENT ON COLUMN "public"."google_tasks_list_configs"."priority_filter" IS 'Array of task priorities that should sync to this list (e.g., {high, critical})';

COMMENT ON COLUMN "public"."google_tasks_list_configs"."task_categories" IS 'Array of task categories to sync to this list';

CREATE TABLE IF NOT EXISTS "public"."google_tasks_sync_conflicts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "task_id" "uuid",
    "google_task_id" "text",
    "google_list_id" "text",
    "conflict_type" "text" NOT NULL,
    "local_data" "jsonb",
    "google_data" "jsonb",
    "resolved" boolean DEFAULT false,
    "resolved_at" timestamp with time zone,
    "resolution_notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "google_tasks_sync_conflicts_conflict_type_check" CHECK (("conflict_type" = ANY (ARRAY['update_conflict'::"text", 'delete_conflict'::"text", 'create_duplicate'::"text"])))
);

-- ALTER TABLE "public"."google_tasks_sync_conflicts" OWNER TO "postgres";

-- ALTER TABLE "public"."google_tasks_sync_status" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."hitl_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "execution_id" "uuid" NOT NULL,
    "sequence_key" "text" NOT NULL,
    "step_index" integer NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "requested_by_user_id" "uuid" NOT NULL,
    "assigned_to_user_id" "uuid",
    "request_type" "text" NOT NULL,
    "prompt" "text" NOT NULL,
    "options" "jsonb" DEFAULT '[]'::"jsonb",
    "default_value" "text",
    "channels" "text"[] DEFAULT ARRAY['in_app'::"text"] NOT NULL,
    "slack_channel_id" "text",
    "slack_message_ts" "text",
    "timeout_minutes" integer DEFAULT 60,
    "timeout_action" "text" DEFAULT 'fail'::"text",
    "expires_at" timestamp with time zone,
    "execution_context" "jsonb" DEFAULT '{}'::"jsonb",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "response_value" "text",
    "response_context" "jsonb" DEFAULT '{}'::"jsonb",
    "responded_by_user_id" "uuid",
    "responded_at" timestamp with time zone,
    "response_channel" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "hitl_requests_request_type_check" CHECK (("request_type" = ANY (ARRAY['confirmation'::"text", 'question'::"text", 'choice'::"text", 'input'::"text"]))),
    CONSTRAINT "hitl_requests_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'responded'::"text", 'expired'::"text", 'cancelled'::"text"]))),
    CONSTRAINT "hitl_requests_timeout_action_check" CHECK (("timeout_action" = ANY (ARRAY['fail'::"text", 'continue'::"text", 'use_default'::"text"])))
);

-- ALTER TABLE "public"."hitl_requests" OWNER TO "postgres";

COMMENT ON TABLE "public"."hitl_requests" IS 'Human-in-the-Loop requests for agent sequence execution pauses';

COMMENT ON COLUMN "public"."hitl_requests"."request_type" IS 'confirmation: yes/no, question: open text, choice: select from options, input: structured input';

COMMENT ON COLUMN "public"."hitl_requests"."channels" IS 'Array of notification channels: slack, in_app';

COMMENT ON COLUMN "public"."hitl_requests"."timeout_action" IS 'What to do on timeout: fail the sequence, continue without response, or use default value';

CREATE TABLE IF NOT EXISTS "public"."http_request_recordings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "execution_id" "uuid" NOT NULL,
    "workflow_id" "uuid" NOT NULL,
    "node_id" "text" NOT NULL,
    "request_sequence" integer NOT NULL,
    "method" "text" NOT NULL,
    "url" "text" NOT NULL,
    "headers" "jsonb" DEFAULT '{}'::"jsonb",
    "body" "jsonb",
    "response_status" integer,
    "response_headers" "jsonb" DEFAULT '{}'::"jsonb",
    "response_body" "jsonb",
    "response_time_ms" integer,
    "error" "text",
    "recorded_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."http_request_recordings" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."hubspot_oauth_states" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "state" "text" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "redirect_uri" "text",
    "expires_at" timestamp with time zone NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "clerk_org_id" "text"
);

-- ALTER TABLE "public"."hubspot_oauth_states" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."hubspot_object_mappings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "object_type" "text" NOT NULL,
    "sixty_id" "uuid",
    "sixty_key" "text",
    "hubspot_id" "text" NOT NULL,
    "last_synced_at" timestamp with time zone,
    "last_seen_hubspot_modified_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "clerk_org_id" "text",
    CONSTRAINT "hubspot_object_mappings_object_type_check" CHECK (("object_type" = ANY (ARRAY['contact'::"text", 'deal'::"text", 'task'::"text", 'note'::"text", 'quote'::"text", 'line_item'::"text", 'custom'::"text", 'form_submission'::"text"])))
);

-- ALTER TABLE "public"."hubspot_object_mappings" OWNER TO "postgres";

COMMENT ON TABLE "public"."hubspot_object_mappings" IS 'Maps Sixty entities to HubSpot objects for bidirectional sync and loop prevention.';

CREATE TABLE IF NOT EXISTS "public"."hubspot_org_credentials" (
    "org_id" "uuid" NOT NULL,
    "access_token" "text" NOT NULL,
    "refresh_token" "text" NOT NULL,
    "token_expires_at" timestamp with time zone NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."hubspot_org_credentials" OWNER TO "postgres";

COMMENT ON TABLE "public"."hubspot_org_credentials" IS 'Org-scoped HubSpot OAuth credentials (service-role-only).';

CREATE TABLE IF NOT EXISTS "public"."hubspot_org_integrations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "connected_by_user_id" "uuid",
    "is_active" boolean DEFAULT true NOT NULL,
    "is_connected" boolean DEFAULT false NOT NULL,
    "connected_at" timestamp with time zone,
    "hubspot_portal_id" "text",
    "hubspot_hub_id" "text",
    "hubspot_account_name" "text",
    "scopes" "text"[] DEFAULT '{}'::"text"[],
    "webhook_token" "text" NOT NULL,
    "webhook_last_received_at" timestamp with time zone,
    "webhook_last_event_id" "text",
    "last_sync_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "clerk_org_id" "text",
    "hubspot_region" "text" DEFAULT 'eu1'::"text"
);

-- ALTER TABLE "public"."hubspot_org_integrations" OWNER TO "postgres";

COMMENT ON TABLE "public"."hubspot_org_integrations" IS 'Org-scoped HubSpot integration metadata (non-sensitive). Stores webhook token for per-org routing.';

COMMENT ON COLUMN "public"."hubspot_org_integrations"."hubspot_region" IS 'HubSpot datacenter region: eu1 for EU, na1 for US/NA. Used to generate correct view URLs.';

CREATE TABLE IF NOT EXISTS "public"."hubspot_org_sync_state" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "cursors" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "last_successful_sync" timestamp with time zone,
    "last_sync_started_at" timestamp with time zone,
    "last_sync_completed_at" timestamp with time zone,
    "sync_status" "text" DEFAULT 'idle'::"text" NOT NULL,
    "error_message" "text",
    "error_count" integer DEFAULT 0 NOT NULL,
    "last_error_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "clerk_org_id" "text",
    CONSTRAINT "hubspot_org_sync_state_sync_status_check" CHECK (("sync_status" = ANY (ARRAY['idle'::"text", 'syncing'::"text", 'error'::"text"])))
);

-- ALTER TABLE "public"."hubspot_org_sync_state" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."hubspot_settings" (
    "org_id" "uuid" NOT NULL,
    "settings" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "clerk_org_id" "text"
);

-- ALTER TABLE "public"."hubspot_settings" OWNER TO "postgres";

COMMENT ON TABLE "public"."hubspot_settings" IS 'Admin-configurable mapping/settings for HubSpot sync.';

CREATE TABLE IF NOT EXISTS "public"."hubspot_webhook_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "event_id" "text" NOT NULL,
    "event_type" "text" NOT NULL,
    "occurred_at" timestamp with time zone,
    "payload_hash" "text" NOT NULL,
    "payload" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "received_at" timestamp with time zone DEFAULT "now"(),
    "processed_at" timestamp with time zone,
    "clerk_org_id" "text"
);

-- ALTER TABLE "public"."hubspot_webhook_events" OWNER TO "postgres";

COMMENT ON TABLE "public"."hubspot_webhook_events" IS 'Idempotency store for HubSpot webhook deliveries.';

CREATE TABLE IF NOT EXISTS "public"."impersonation_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "admin_id" "uuid" NOT NULL,
    "admin_email" "text" NOT NULL,
    "target_user_id" "uuid" NOT NULL,
    "target_user_email" "text" NOT NULL,
    "action" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "impersonation_logs_action_check" CHECK (("action" = ANY (ARRAY['start_impersonation'::"text", 'end_impersonation'::"text"])))
);

-- ALTER TABLE "public"."impersonation_logs" OWNER TO "postgres";

COMMENT ON TABLE "public"."impersonation_logs" IS 'Audit trail for user impersonation actions';

COMMENT ON COLUMN "public"."impersonation_logs"."action" IS 'Type of impersonation action: start_impersonation or end_impersonation';

CREATE TABLE IF NOT EXISTS "public"."integration_alerts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "integration_name" "text" NOT NULL,
    "alert_type" "text" NOT NULL,
    "severity" "text" NOT NULL,
    "title" "text" NOT NULL,
    "message" "text" NOT NULL,
    "test_result_id" "uuid",
    "acknowledged_at" timestamp with time zone,
    "acknowledged_by" "uuid",
    "resolved_at" timestamp with time zone,
    "resolved_by" "uuid",
    "slack_notified_at" timestamp with time zone,
    "email_notified_at" timestamp with time zone,
    CONSTRAINT "integration_alerts_alert_type_check" CHECK (("alert_type" = ANY (ARRAY['failure'::"text", 'recovery'::"text", 'degradation'::"text"]))),
    CONSTRAINT "integration_alerts_severity_check" CHECK (("severity" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'critical'::"text"])))
);

-- ALTER TABLE "public"."integration_alerts" OWNER TO "postgres";

COMMENT ON TABLE "public"."integration_alerts" IS 'Stores alerts generated when integration tests fail';

CREATE TABLE IF NOT EXISTS "public"."integration_test_results" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "integration_name" "text" NOT NULL,
    "test_name" "text" NOT NULL,
    "test_category" "text",
    "status" "text" NOT NULL,
    "duration_ms" integer,
    "message" "text",
    "error_details" "jsonb",
    "response_data" "jsonb",
    "triggered_by" "text" NOT NULL,
    "triggered_by_user_id" "uuid",
    "org_id" "uuid",
    CONSTRAINT "integration_test_results_status_check" CHECK (("status" = ANY (ARRAY['passed'::"text", 'failed'::"text", 'skipped'::"text", 'error'::"text"]))),
    CONSTRAINT "integration_test_results_triggered_by_check" CHECK (("triggered_by" = ANY (ARRAY['manual'::"text", 'scheduled'::"text", 'webhook'::"text", 'onboarding'::"text"])))
);

-- ALTER TABLE "public"."integration_test_results" OWNER TO "postgres";

COMMENT ON TABLE "public"."integration_test_results" IS 'Stores results of integration health tests for monitoring and debugging';

CREATE OR REPLACE VIEW "public"."integration_health_summary" WITH ("security_invoker"='true') AS
 WITH "latest_run_per_integration" AS (
         SELECT "integration_test_results"."integration_name",
            "max"("integration_test_results"."created_at") AS "latest_run_at"
           FROM "public"."integration_test_results"
          GROUP BY "integration_test_results"."integration_name"
        ), "latest_run_tests" AS (
         SELECT "itr"."id",
            "itr"."created_at",
            "itr"."integration_name",
            "itr"."test_name",
            "itr"."test_category",
            "itr"."status",
            "itr"."duration_ms",
            "itr"."message",
            "itr"."error_details",
            "itr"."response_data",
            "itr"."triggered_by",
            "itr"."triggered_by_user_id",
            "itr"."org_id"
           FROM ("public"."integration_test_results" "itr"
             JOIN "latest_run_per_integration" "lrpi" ON ((("itr"."integration_name" = "lrpi"."integration_name") AND ("itr"."created_at" >= ("lrpi"."latest_run_at" - '00:05:00'::interval)))))
        )
 SELECT "integration_name",
    "count"(*) FILTER (WHERE ("status" = 'passed'::"text")) AS "passed_count",
    "count"(*) FILTER (WHERE ("status" = 'failed'::"text")) AS "failed_count",
    "count"(*) FILTER (WHERE ("status" = 'error'::"text")) AS "error_count",
    "count"(*) AS "total_tests",
    "round"(((("count"(*) FILTER (WHERE ("status" = 'passed'::"text")))::numeric / (NULLIF("count"(*), 0))::numeric) * (100)::numeric), 1) AS "pass_rate",
    "max"("created_at") AS "last_test_at",
        CASE
            WHEN ("count"(*) FILTER (WHERE ("status" = ANY (ARRAY['failed'::"text", 'error'::"text"]))) > 0) THEN 'critical'::"text"
            WHEN ("count"(*) FILTER (WHERE ("status" = 'passed'::"text")) = "count"(*)) THEN 'healthy'::"text"
            ELSE 'warning'::"text"
        END AS "health_status"
   FROM "latest_run_tests"
  GROUP BY "integration_name";

-- ALTER VIEW "public"."integration_health_summary" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."integration_sync_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid",
    "user_id" "uuid",
    "integration_name" "text" NOT NULL,
    "operation" "text" NOT NULL,
    "direction" "text",
    "entity_type" "text" NOT NULL,
    "entity_id" "text",
    "entity_name" "text",
    "status" "text" DEFAULT 'success'::"text" NOT NULL,
    "error_message" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "batch_id" "uuid",
    CONSTRAINT "integration_sync_logs_direction_check" CHECK (("direction" = ANY (ARRAY['inbound'::"text", 'outbound'::"text"]))),
    CONSTRAINT "integration_sync_logs_integration_name_check" CHECK (("integration_name" = ANY (ARRAY['hubspot'::"text", 'fathom'::"text", 'google_calendar'::"text", 'google_tasks'::"text", 'savvycal'::"text", 'slack'::"text"]))),
    CONSTRAINT "integration_sync_logs_operation_check" CHECK (("operation" = ANY (ARRAY['sync'::"text", 'create'::"text", 'update'::"text", 'delete'::"text", 'push'::"text", 'pull'::"text", 'webhook'::"text", 'error'::"text"]))),
    CONSTRAINT "integration_sync_logs_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'success'::"text", 'failed'::"text", 'skipped'::"text"])))
);

-- ALTER TABLE "public"."integration_sync_logs" OWNER TO "postgres";

COMMENT ON TABLE "public"."integration_sync_logs" IS 'Item-by-item sync activity logs for all integrations with real-time support';

COMMENT ON COLUMN "public"."integration_sync_logs"."entity_name" IS 'Human-readable description, e.g. "John Doe (john@example.com)"';

COMMENT ON COLUMN "public"."integration_sync_logs"."batch_id" IS 'Groups operations from the same sync run';

CREATE TABLE IF NOT EXISTS "public"."internal_email_domains" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "domain" "text" NOT NULL,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."internal_email_domains" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."internal_users" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "email" "text" NOT NULL,
    "name" "text",
    "added_by" "uuid",
    "reason" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."internal_users" OWNER TO "postgres";

COMMENT ON TABLE "public"."internal_users" IS 'Whitelist of users with internal (full) access.
Test accounts like app@sixtyseconds.video should NOT be in this table to simulate customer experience.';

-- ALTER TABLE "public"."intervention_templates" OWNER TO "postgres";

COMMENT ON TABLE "public"."intervention_templates" IS 'Library of intervention templates for re-engaging ghosting prospects';

COMMENT ON COLUMN "public"."intervention_templates"."personalization_fields" IS 'JSONB fields that AI will personalize (last_meaningful_interaction, personalized_assumption, reconnect_suggestion)';

COMMENT ON COLUMN "public"."intervention_templates"."parent_template_id" IS 'Links A/B test variants to their parent control template';

COMMENT ON COLUMN "public"."intervention_templates"."performance_by_segment" IS 'JSONB breakdown of template effectiveness by persona, industry, and deal stage';

COMMENT ON COLUMN "public"."intervention_templates"."is_system_template" IS 'System templates are read-only defaults provided by the platform';

CREATE TABLE IF NOT EXISTS "public"."justcall_integration_secrets" (
    "integration_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "oauth_access_token" "text",
    "oauth_refresh_token" "text",
    "api_key" "text",
    "api_secret" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."justcall_integration_secrets" OWNER TO "postgres";

COMMENT ON TABLE "public"."justcall_integration_secrets" IS 'Org-wide JustCall integration secrets (admin-only)';

CREATE TABLE IF NOT EXISTS "public"."justcall_integrations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "auth_type" "text" NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "webhook_token" "text" NOT NULL,
    "token_expires_at" timestamp with time zone,
    "last_sync_at" timestamp with time zone,
    "connected_by_user_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "justcall_integrations_auth_type_check" CHECK (("auth_type" = ANY (ARRAY['oauth'::"text", 'api_key'::"text"])))
);

-- ALTER TABLE "public"."justcall_integrations" OWNER TO "postgres";

COMMENT ON TABLE "public"."justcall_integrations" IS 'Org-wide JustCall integration configuration (non-secret fields)';

CREATE TABLE IF NOT EXISTS "public"."justcall_oauth_states" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "state" "text" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "expires_at" timestamp with time zone NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."justcall_oauth_states" OWNER TO "postgres";

COMMENT ON TABLE "public"."justcall_oauth_states" IS 'Temporary storage for JustCall OAuth state parameters (CSRF protection)';

COMMENT ON COLUMN "public"."justcall_oauth_states"."state" IS 'Random state parameter for OAuth flow';

COMMENT ON COLUMN "public"."justcall_oauth_states"."expires_at" IS 'When this state expires (typically 10 minutes)';

CREATE TABLE IF NOT EXISTS "public"."meetings_waitlist" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "email" "text" NOT NULL,
    "full_name" "text" NOT NULL,
    "company_name" "text" NOT NULL,
    "dialer_tool" "text",
    "meeting_recorder_tool" "text",
    "crm_tool" "text",
    "referral_code" "text" NOT NULL,
    "referred_by_code" "text",
    "referral_count" integer DEFAULT 0,
    "signup_position" integer,
    "effective_position" integer,
    "status" "public"."waitlist_status" DEFAULT 'pending'::"public"."waitlist_status" NOT NULL,
    "released_at" timestamp with time zone,
    "released_by" "uuid",
    "admin_notes" "text",
    "utm_source" "text",
    "utm_campaign" "text",
    "utm_medium" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "dialer_other" "text",
    "meeting_recorder_other" "text",
    "crm_other" "text",
    "linkedin_share_claimed" boolean DEFAULT false,
    "linkedin_first_share_at" timestamp with time zone,
    "granted_access_at" timestamp with time zone,
    "granted_by" "uuid",
    "profile_image_url" "text",
    "total_points" integer DEFAULT 0,
    "linkedin_boost_claimed" boolean DEFAULT false,
    "twitter_boost_claimed" boolean DEFAULT false,
    "twitter_first_share_at" timestamp with time zone,
    "user_id" "uuid",
    "converted_at" timestamp with time zone,
    "magic_link_sent_at" timestamp with time zone,
    "magic_link_expires_at" timestamp with time zone,
    "access_granted_by" "uuid",
    "is_seeded" boolean DEFAULT false NOT NULL,
    "display_rank" integer,
    "signup_source" "text",
    "email_boost_claimed" boolean DEFAULT false,
    "email_first_share_at" timestamp with time zone,
    "task_manager_tool" "text",
    "task_manager_other" "text",
    "registration_url" "text",
    "invite_code_used" "text",
    "invited_at" timestamp with time zone,
    "invitation_expires_at" timestamp with time zone,
    "invited_user_id" "uuid",
    "invitation_accepted_at" timestamp with time zone
);

-- ALTER TABLE "public"."meetings_waitlist" OWNER TO "postgres";

COMMENT ON TABLE "public"."meetings_waitlist" IS 'Public waitlist for meetings product with referral tracking';

COMMENT ON COLUMN "public"."meetings_waitlist"."referral_code" IS 'Unique code like MEET-ABC123 for referring others';

COMMENT ON COLUMN "public"."meetings_waitlist"."referred_by_code" IS 'Referral code of person who referred this signup';

COMMENT ON COLUMN "public"."meetings_waitlist"."effective_position" IS 'Calculated position: signup_position - (referral_count * 5), minimum 1';

COMMENT ON COLUMN "public"."meetings_waitlist"."admin_notes" IS 'Admin notes added when granting access';

COMMENT ON COLUMN "public"."meetings_waitlist"."total_points" IS 'Total gamification points earned (referrals + social boosts + achievements)';

COMMENT ON COLUMN "public"."meetings_waitlist"."user_id" IS 'Linked auth user ID after account creation';

COMMENT ON COLUMN "public"."meetings_waitlist"."converted_at" IS 'Timestamp when user successfully created account';

COMMENT ON COLUMN "public"."meetings_waitlist"."magic_link_sent_at" IS 'Timestamp when magic link was sent';

COMMENT ON COLUMN "public"."meetings_waitlist"."magic_link_expires_at" IS 'Timestamp when magic link expires (7 days from send)';

COMMENT ON COLUMN "public"."meetings_waitlist"."access_granted_by" IS 'Admin user who granted access';

COMMENT ON COLUMN "public"."meetings_waitlist"."is_seeded" IS 'Flag to identify seeded/fake users for social proof. These users are
   visible on public waitlist but can be filtered out in admin view.';

COMMENT ON COLUMN "public"."meetings_waitlist"."signup_source" IS 'Tracks which landing page variation led to signup: landing, waitlist, join-popup';

COMMENT ON COLUMN "public"."meetings_waitlist"."task_manager_tool" IS 'Task management tool preference (Monday, Jira, Coda, Asana, Teams, Trello, Other, None)';

COMMENT ON COLUMN "public"."meetings_waitlist"."task_manager_other" IS 'Custom task manager name when task_manager_tool is "Other"';

COMMENT ON COLUMN "public"."meetings_waitlist"."registration_url" IS 'Pathname only, without domain, protocol, or query parameters (e.g., /waitlist).
   Used for analytics and tracking entry points.
   Format: /[path] or NULL if not available';

COMMENT ON COLUMN "public"."meetings_waitlist"."invite_code_used" IS 'The invite code used to sign up. Can be a database code or admin bypass (SIXTY60).';

COMMENT ON COLUMN "public"."meetings_waitlist"."invited_at" IS 'Timestamp when invitation was sent via Supabase admin.inviteUserByEmail()';

COMMENT ON COLUMN "public"."meetings_waitlist"."invitation_expires_at" IS 'Expiration timestamp (7 days from invited_at)';

COMMENT ON COLUMN "public"."meetings_waitlist"."invitation_accepted_at" IS 'Timestamp when user completed password setup and activated account';

CREATE TABLE IF NOT EXISTS "public"."page_views" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "session_id" "text" NOT NULL,
    "visitor_id" "text",
    "landing_page" "text" NOT NULL,
    "full_url" "text",
    "referrer" "text",
    "utm_source" "text",
    "utm_medium" "text",
    "utm_campaign" "text",
    "utm_content" "text",
    "utm_term" "text",
    "utm_id" "text",
    "fbclid" "text",
    "device_type" "text",
    "browser" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "page_views_session_id_check" CHECK (("session_id" <> ''::"text"))
);

-- ALTER TABLE "public"."page_views" OWNER TO "postgres";

COMMENT ON TABLE "public"."page_views" IS 'Landing page view tracking with UTM parameters for Meta/Facebook ads attribution';

CREATE TABLE IF NOT EXISTS "public"."partial_signups" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "email" "text" NOT NULL,
    "session_id" "text" NOT NULL,
    "visitor_id" "text",
    "landing_page" "text" NOT NULL,
    "form_step" "text" DEFAULT 'email'::"text",
    "utm_source" "text",
    "utm_medium" "text",
    "utm_campaign" "text",
    "utm_content" "text",
    "utm_term" "text",
    "fbclid" "text",
    "converted" boolean DEFAULT false,
    "converted_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "partial_signups_email_check" CHECK (("email" ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'::"text"))
);

-- ALTER TABLE "public"."partial_signups" OWNER TO "postgres";

COMMENT ON TABLE "public"."partial_signups" IS 'Tracks partial form submissions (email entered but form not completed) as leads';

CREATE OR REPLACE VIEW "public"."landing_page_analytics" WITH ("security_invoker"='true') AS
 WITH "daily_views" AS (
         SELECT "date"("page_views"."created_at") AS "date",
            "page_views"."landing_page",
            COALESCE("page_views"."utm_source",
                CASE
                    WHEN ("page_views"."fbclid" IS NOT NULL) THEN 'facebook'::"text"
                    ELSE 'direct'::"text"
                END) AS "source",
            "page_views"."utm_campaign",
            "page_views"."utm_content" AS "creative_id",
            "count"(*) AS "page_views",
            "count"(DISTINCT "page_views"."session_id") AS "unique_sessions",
            "count"(DISTINCT "page_views"."visitor_id") AS "unique_visitors"
           FROM "public"."page_views"
          GROUP BY ("date"("page_views"."created_at")), "page_views"."landing_page", COALESCE("page_views"."utm_source",
                CASE
                    WHEN ("page_views"."fbclid" IS NOT NULL) THEN 'facebook'::"text"
                    ELSE 'direct'::"text"
                END), "page_views"."utm_campaign", "page_views"."utm_content"
        ), "daily_partial_signups" AS (
         SELECT "date"("partial_signups"."created_at") AS "date",
            "partial_signups"."landing_page",
            COALESCE("partial_signups"."utm_source",
                CASE
                    WHEN ("partial_signups"."fbclid" IS NOT NULL) THEN 'facebook'::"text"
                    ELSE 'direct'::"text"
                END) AS "source",
            "partial_signups"."utm_campaign",
            "partial_signups"."utm_content" AS "creative_id",
            "count"(*) AS "partial_signups",
            "count"(*) FILTER (WHERE ("partial_signups"."converted" = true)) AS "partial_converted"
           FROM "public"."partial_signups"
          GROUP BY ("date"("partial_signups"."created_at")), "partial_signups"."landing_page", COALESCE("partial_signups"."utm_source",
                CASE
                    WHEN ("partial_signups"."fbclid" IS NOT NULL) THEN 'facebook'::"text"
                    ELSE 'direct'::"text"
                END), "partial_signups"."utm_campaign", "partial_signups"."utm_content"
        ), "daily_conversions" AS (
         SELECT "date"("meetings_waitlist"."created_at") AS "date",
                CASE
                    WHEN (("meetings_waitlist"."registration_url" ~~ '%/intro%'::"text") AND ("meetings_waitlist"."registration_url" !~~ '%/introducing%'::"text") AND ("meetings_waitlist"."registration_url" !~~ '%/introduction%'::"text")) THEN '/intro'::"text"
                    WHEN ("meetings_waitlist"."registration_url" ~~ '%/introducing%'::"text") THEN '/introducing'::"text"
                    WHEN ("meetings_waitlist"."registration_url" ~~ '%/introduction%'::"text") THEN '/introduction'::"text"
                    WHEN ("meetings_waitlist"."registration_url" ~~ '%/waitlist%'::"text") THEN '/waitlist'::"text"
                    WHEN ("meetings_waitlist"."registration_url" ~~ '%/join%'::"text") THEN '/join'::"text"
                    ELSE 'other'::"text"
                END AS "landing_page",
            COALESCE("meetings_waitlist"."utm_source",
                CASE
                    WHEN ("meetings_waitlist"."registration_url" ~~ '%fbclid%'::"text") THEN 'facebook'::"text"
                    ELSE 'direct'::"text"
                END) AS "source",
            "meetings_waitlist"."utm_campaign",
            ("regexp_match"("meetings_waitlist"."registration_url", 'utm_content=([^&]+)'::"text"))[1] AS "creative_id",
            "count"(*) AS "conversions"
           FROM "public"."meetings_waitlist"
          WHERE ("meetings_waitlist"."is_seeded" IS NOT TRUE)
          GROUP BY ("date"("meetings_waitlist"."created_at")),
                CASE
                    WHEN (("meetings_waitlist"."registration_url" ~~ '%/intro%'::"text") AND ("meetings_waitlist"."registration_url" !~~ '%/introducing%'::"text") AND ("meetings_waitlist"."registration_url" !~~ '%/introduction%'::"text")) THEN '/intro'::"text"
                    WHEN ("meetings_waitlist"."registration_url" ~~ '%/introducing%'::"text") THEN '/introducing'::"text"
                    WHEN ("meetings_waitlist"."registration_url" ~~ '%/introduction%'::"text") THEN '/introduction'::"text"
                    WHEN ("meetings_waitlist"."registration_url" ~~ '%/waitlist%'::"text") THEN '/waitlist'::"text"
                    WHEN ("meetings_waitlist"."registration_url" ~~ '%/join%'::"text") THEN '/join'::"text"
                    ELSE 'other'::"text"
                END, COALESCE("meetings_waitlist"."utm_source",
                CASE
                    WHEN ("meetings_waitlist"."registration_url" ~~ '%fbclid%'::"text") THEN 'facebook'::"text"
                    ELSE 'direct'::"text"
                END), "meetings_waitlist"."utm_campaign", ("regexp_match"("meetings_waitlist"."registration_url", 'utm_content=([^&]+)'::"text"))[1]
        )
 SELECT COALESCE("v"."date", "c"."date", "p"."date") AS "date",
    COALESCE("v"."landing_page", "c"."landing_page", "p"."landing_page") AS "landing_page",
    COALESCE("v"."source", "c"."source", "p"."source") AS "source",
    COALESCE("v"."utm_campaign", "c"."utm_campaign", "p"."utm_campaign") AS "campaign",
    COALESCE("v"."creative_id", "c"."creative_id", "p"."creative_id") AS "creative_id",
    COALESCE("v"."page_views", (0)::bigint) AS "page_views",
    COALESCE("v"."unique_sessions", (0)::bigint) AS "unique_sessions",
    COALESCE("v"."unique_visitors", (0)::bigint) AS "unique_visitors",
    COALESCE("p"."partial_signups", (0)::bigint) AS "partial_signups",
    COALESCE("c"."conversions", (0)::bigint) AS "conversions",
        CASE
            WHEN (COALESCE("v"."unique_sessions", (0)::bigint) > 0) THEN "round"((((COALESCE("c"."conversions", (0)::bigint))::numeric / ("v"."unique_sessions")::numeric) * (100)::numeric), 2)
            ELSE (0)::numeric
        END AS "conversion_rate",
        CASE
            WHEN (COALESCE("v"."unique_sessions", (0)::bigint) > 0) THEN "round"((((COALESCE("p"."partial_signups", (0)::bigint))::numeric / ("v"."unique_sessions")::numeric) * (100)::numeric), 2)
            ELSE (0)::numeric
        END AS "lead_capture_rate"
   FROM (("daily_views" "v"
     FULL JOIN "daily_conversions" "c" ON ((("v"."date" = "c"."date") AND ("v"."landing_page" = "c"."landing_page") AND ("v"."source" = "c"."source") AND (COALESCE("v"."utm_campaign", ''::"text") = COALESCE("c"."utm_campaign", ''::"text")) AND (COALESCE("v"."creative_id", ''::"text") = COALESCE("c"."creative_id", ''::"text")))))
     FULL JOIN "daily_partial_signups" "p" ON (((COALESCE("v"."date", "c"."date") = "p"."date") AND (COALESCE("v"."landing_page", "c"."landing_page") = "p"."landing_page") AND (COALESCE("v"."source", "c"."source") = "p"."source") AND (COALESCE("v"."utm_campaign", "c"."utm_campaign", ''::"text") = COALESCE("p"."utm_campaign", ''::"text")) AND (COALESCE("v"."creative_id", "c"."creative_id", ''::"text") = COALESCE("p"."creative_id", ''::"text")))))
  ORDER BY COALESCE("v"."date", "c"."date", "p"."date") DESC, COALESCE("v"."page_views", (0)::bigint) DESC;

-- ALTER VIEW "public"."landing_page_analytics" OWNER TO "postgres";

CREATE OR REPLACE VIEW "public"."latest_integration_test_results" WITH ("security_invoker"='true') AS
 SELECT DISTINCT ON ("integration_name", "test_name") "id",
    "created_at",
    "integration_name",
    "test_name",
    "test_category",
    "status",
    "duration_ms",
    "message",
    "error_details",
    "triggered_by",
    "triggered_by_user_id",
    "org_id"
   FROM "public"."integration_test_results"
  ORDER BY "integration_name", "test_name", "created_at" DESC;

-- ALTER VIEW "public"."latest_integration_test_results" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."launch_checklist_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "task_id" "text" NOT NULL,
    "category" "text" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "effort_hours" "text",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "completed_at" timestamp with time zone,
    "completed_by" "uuid",
    "notes" "text",
    "subtasks" "jsonb" DEFAULT '[]'::"jsonb",
    "order_index" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."launch_checklist_items" OWNER TO "postgres";

-- ALTER TABLE "public"."lead_events" OWNER TO "postgres";

COMMENT ON TABLE "public"."lead_events" IS 'Append-only log of inbound webhook payloads for each lead';

-- ALTER TABLE "public"."lead_prep_notes" OWNER TO "postgres";

COMMENT ON TABLE "public"."lead_prep_notes" IS 'Structured prep insights and tasks generated for reps ahead of meetings';

-- ALTER TABLE "public"."lead_sources" OWNER TO "postgres";

COMMENT ON TABLE "public"."lead_sources" IS 'Catalog of inbound lead sources and marketing channels';

COMMENT ON COLUMN "public"."lead_sources"."source_key" IS 'Stable slug used to map inbound webhook sources (e.g., website, linkedin_ads)';

-- ALTER TABLE "public"."leads" OWNER TO "postgres";

COMMENT ON TABLE "public"."leads" IS 'Inbound lead intake records generated from scheduling tools and manual capture';

COMMENT ON COLUMN "public"."leads"."external_id" IS 'External system identifier (SavvyCal event id)';

COMMENT ON COLUMN "public"."leads"."owner_id" IS 'Sales rep responsible for the lead';

COMMENT ON COLUMN "public"."leads"."tags" IS 'Array of tags for categorizing leads (e.g., "Meeting Booked", source name, owner name)';

CREATE OR REPLACE VIEW "public"."lead_source_summary" WITH ("security_invoker"='true') AS
 SELECT "l"."source_id",
    "ls"."source_key",
    "ls"."name" AS "source_name",
    COALESCE("l"."source_channel", "ls"."channel") AS "channel",
    COALESCE("l"."source_medium", "ls"."utm_medium") AS "medium",
    COALESCE("l"."source_campaign", "ls"."utm_campaign") AS "campaign",
    "l"."owner_id",
    "count"("l"."id") AS "total_leads",
    "count"("l"."id") FILTER (WHERE ("l"."status" = 'converted'::"text")) AS "converted_leads",
    "count"("l"."id") FILTER (WHERE ("l"."status" = 'ready'::"text")) AS "ready_leads",
    "count"("l"."id") FILTER (WHERE ("l"."status" = 'prepping'::"text")) AS "prepping_leads",
    "min"("l"."created_at") AS "first_lead_at",
    "max"("l"."created_at") AS "last_lead_at"
   FROM ("public"."leads" "l"
     LEFT JOIN "public"."lead_sources" "ls" ON (("ls"."id" = "l"."source_id")))
  WHERE ("l"."deleted_at" IS NULL)
  GROUP BY "l"."source_id", "ls"."source_key", "ls"."name", COALESCE("l"."source_channel", "ls"."channel"), COALESCE("l"."source_medium", "ls"."utm_medium"), COALESCE("l"."source_campaign", "ls"."utm_campaign"), "l"."owner_id";

-- ALTER VIEW "public"."lead_source_summary" OWNER TO "postgres";

COMMENT ON VIEW "public"."lead_source_summary" IS 'Aggregated lead metrics by source (security_invoker enabled)';

-- ALTER TABLE "public"."mcp_connections" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."meeting_action_items" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "assignee_name" "text",
    "assignee_email" "text",
    "priority" "text",
    "category" "text",
    "deadline_at" timestamp with time zone,
    "completed" boolean DEFAULT false,
    "ai_generated" boolean DEFAULT false,
    "timestamp_seconds" integer,
    "playback_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "linked_task_id" "uuid",
    "is_sales_rep_task" boolean DEFAULT false,
    "ai_task_type" "text",
    "ai_deadline" "date",
    "ai_confidence_score" numeric(3,2),
    "ai_reasoning" "text",
    "ai_analyzed_at" timestamp with time zone,
    "task_id" "uuid",
    "synced_to_task" boolean DEFAULT false,
    "sync_status" "text" DEFAULT 'pending'::"text",
    "sync_error" "text",
    "synced_at" timestamp with time zone,
    "ai_confidence" numeric(3,2),
    "needs_review" boolean DEFAULT false,
    "assigned_to_name" "text",
    "assigned_to_email" "text",
    "deadline_date" "date",
    "importance" "text",
    CONSTRAINT "meeting_action_items_importance_check" CHECK (("importance" = ANY (ARRAY['high'::"text", 'medium'::"text", 'low'::"text"]))),
    CONSTRAINT "meeting_action_items_sync_status_check" CHECK (("sync_status" = ANY (ARRAY['pending'::"text", 'synced'::"text", 'failed'::"text", 'excluded'::"text"])))
);

-- ALTER TABLE "public"."meeting_action_items" OWNER TO "postgres";

COMMENT ON TABLE "public"."meeting_action_items" IS 'Action items from Fathom meetings. Tasks are created MANUALLY only when sales reps click "Create Task" button. No automatic task creation.';

COMMENT ON COLUMN "public"."meeting_action_items"."ai_generated" IS 'Whether this action item was extracted by Claude AI from transcript';

COMMENT ON COLUMN "public"."meeting_action_items"."ai_task_type" IS 'AI-determined task type using Claude Haiku 4.5';

COMMENT ON COLUMN "public"."meeting_action_items"."ai_deadline" IS 'AI-determined ideal deadline';

COMMENT ON COLUMN "public"."meeting_action_items"."ai_confidence_score" IS 'AI confidence score (0-1) for categorization';

COMMENT ON COLUMN "public"."meeting_action_items"."ai_reasoning" IS 'AI reasoning for task type and deadline choice';

COMMENT ON COLUMN "public"."meeting_action_items"."ai_analyzed_at" IS 'Timestamp when AI analysis was performed';

COMMENT ON COLUMN "public"."meeting_action_items"."task_id" IS 'Link to synced CRM task (for internal assignees only)';

COMMENT ON COLUMN "public"."meeting_action_items"."synced_to_task" IS 'Whether this action item has been synced to a CRM task';

COMMENT ON COLUMN "public"."meeting_action_items"."sync_status" IS 'Sync status: pending, synced, failed, or excluded (external assignee)';

COMMENT ON COLUMN "public"."meeting_action_items"."sync_error" IS 'Error message if sync failed';

COMMENT ON COLUMN "public"."meeting_action_items"."synced_at" IS 'When this action item was last synced';

COMMENT ON COLUMN "public"."meeting_action_items"."ai_confidence" IS 'AI confidence score 0.0 to 1.0 for this action item';

COMMENT ON COLUMN "public"."meeting_action_items"."needs_review" IS 'Whether this AI-generated item needs manual review';

COMMENT ON COLUMN "public"."meeting_action_items"."assigned_to_name" IS 'Name of person assigned (from AI extraction)';

COMMENT ON COLUMN "public"."meeting_action_items"."assigned_to_email" IS 'Email of person assigned (from AI extraction)';

COMMENT ON COLUMN "public"."meeting_action_items"."deadline_date" IS 'Deadline date for this action item';

COMMENT ON COLUMN "public"."meeting_action_items"."importance" IS 'Importance level for auto-sync filtering: high (critical), medium (standard), low (optional)';

CREATE TABLE IF NOT EXISTS "public"."meeting_aggregate_metrics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "period_type" "text" NOT NULL,
    "period_start" "date" NOT NULL,
    "period_end" "date" NOT NULL,
    "total_meetings" integer DEFAULT 0,
    "meetings_with_transcripts" integer DEFAULT 0,
    "meetings_analyzed" integer DEFAULT 0,
    "positive_sentiment_count" integer DEFAULT 0,
    "neutral_sentiment_count" integer DEFAULT 0,
    "negative_sentiment_count" integer DEFAULT 0,
    "avg_sentiment_score" numeric,
    "positive_outcome_count" integer DEFAULT 0,
    "neutral_outcome_count" integer DEFAULT 0,
    "negative_outcome_count" integer DEFAULT 0,
    "forward_movement_count" integer DEFAULT 0,
    "proposal_request_count" integer DEFAULT 0,
    "demo_request_count" integer DEFAULT 0,
    "next_steps_established_count" integer DEFAULT 0,
    "pricing_discussion_count" integer DEFAULT 0,
    "competitor_mention_count" integer DEFAULT 0,
    "timeline_discussion_count" integer DEFAULT 0,
    "budget_discussion_count" integer DEFAULT 0,
    "objection_count" integer DEFAULT 0,
    "top_objections" "jsonb" DEFAULT '[]'::"jsonb",
    "top_competitors" "jsonb" DEFAULT '[]'::"jsonb",
    "avg_rep_talk_time" numeric,
    "avg_customer_talk_time" numeric,
    "avg_scorecard_score" numeric,
    "avg_discovery_questions" numeric,
    "next_steps_rate" numeric,
    "stage_breakdown" "jsonb" DEFAULT '{}'::"jsonb",
    "rep_breakdown" "jsonb" DEFAULT '[]'::"jsonb",
    "meetings_change_pct" numeric,
    "forward_movement_change_pct" numeric,
    "sentiment_change_pct" numeric,
    "last_calculated_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "meeting_aggregate_metrics_period_type_check" CHECK (("period_type" = ANY (ARRAY['day'::"text", 'week'::"text", 'month'::"text", 'quarter'::"text"])))
);

-- ALTER TABLE "public"."meeting_aggregate_metrics" OWNER TO "postgres";

COMMENT ON TABLE "public"."meeting_aggregate_metrics" IS 'Pre-computed aggregate metrics per org/period';

CREATE TABLE IF NOT EXISTS "public"."meeting_attendees" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid",
    "name" "text",
    "email" "text",
    "is_external" boolean DEFAULT false,
    "role" "text"
);

-- ALTER TABLE "public"."meeting_attendees" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."meeting_classifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid",
    "org_id" "uuid" NOT NULL,
    "has_forward_movement" boolean DEFAULT false,
    "has_proposal_request" boolean DEFAULT false,
    "has_pricing_discussion" boolean DEFAULT false,
    "has_competitor_mention" boolean DEFAULT false,
    "has_objection" boolean DEFAULT false,
    "has_demo_request" boolean DEFAULT false,
    "has_timeline_discussion" boolean DEFAULT false,
    "has_budget_discussion" boolean DEFAULT false,
    "has_decision_maker" boolean DEFAULT false,
    "has_next_steps" boolean DEFAULT false,
    "outcome" "text",
    "detected_stage" "text",
    "topics" "jsonb" DEFAULT '[]'::"jsonb",
    "objections" "jsonb" DEFAULT '[]'::"jsonb",
    "competitors" "jsonb" DEFAULT '[]'::"jsonb",
    "keywords" "jsonb" DEFAULT '[]'::"jsonb",
    "objection_count" integer DEFAULT 0,
    "competitor_mention_count" integer DEFAULT 0,
    "positive_signal_count" integer DEFAULT 0,
    "negative_signal_count" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "meeting_classifications_detected_stage_check" CHECK (("detected_stage" = ANY (ARRAY['discovery'::"text", 'demo'::"text", 'negotiation'::"text", 'closing'::"text", 'follow_up'::"text", 'general'::"text"]))),
    CONSTRAINT "meeting_classifications_outcome_check" CHECK (("outcome" = ANY (ARRAY['positive'::"text", 'neutral'::"text", 'negative'::"text", 'unknown'::"text"])))
);

-- ALTER TABLE "public"."meeting_classifications" OWNER TO "postgres";

COMMENT ON TABLE "public"."meeting_classifications" IS 'Per-meeting classification flags for fast aggregate queries';

CREATE TABLE IF NOT EXISTS "public"."meeting_contacts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid" NOT NULL,
    "contact_id" "uuid" NOT NULL,
    "is_primary" boolean DEFAULT false,
    "role" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."meeting_contacts" OWNER TO "postgres";

COMMENT ON TABLE "public"."meeting_contacts" IS 'Junction table linking meetings to all attending contacts (many-to-many)';

COMMENT ON COLUMN "public"."meeting_contacts"."is_primary" IS 'Indicates the primary external contact for this meeting';

COMMENT ON COLUMN "public"."meeting_contacts"."role" IS 'Role of contact in meeting: organizer, attendee, guest, etc.';

CREATE TABLE IF NOT EXISTS "public"."meeting_content_topics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "topics" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "extraction_version" integer DEFAULT 1 NOT NULL,
    "model_used" "text" NOT NULL,
    "tokens_used" integer,
    "cost_cents" integer,
    "created_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "deleted_at" timestamp with time zone,
    CONSTRAINT "extraction_version_positive" CHECK (("extraction_version" > 0)),
    CONSTRAINT "meeting_content_topics_cost_cents_check" CHECK (("cost_cents" >= 0)),
    CONSTRAINT "meeting_content_topics_tokens_used_check" CHECK (("tokens_used" >= 0)),
    CONSTRAINT "topics_json_check" CHECK (("jsonb_typeof"("topics") = 'array'::"text"))
);

-- ALTER TABLE "public"."meeting_content_topics" OWNER TO "postgres";

COMMENT ON TABLE "public"."meeting_content_topics" IS 'Created by migration 20250128000000 - Meeting Content Tables';

COMMENT ON COLUMN "public"."meeting_content_topics"."topics" IS 'JSONB array of topic objects with title, description, timestamp, and fathom_url';

COMMENT ON COLUMN "public"."meeting_content_topics"."cost_cents" IS 'Cost in cents for exact financial arithmetic (no floating point errors)';

CREATE TABLE IF NOT EXISTS "public"."meeting_documents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "text",
    "document_id" "text" NOT NULL,
    "document_url" "text" NOT NULL,
    "document_title" "text",
    "user_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."meeting_documents" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."meeting_file_search_index" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid",
    "user_id" "uuid",
    "store_name" "text" NOT NULL,
    "file_name" "text",
    "content_hash" "text",
    "indexed_at" timestamp with time zone DEFAULT "now"(),
    "status" "text" DEFAULT 'pending'::"text",
    "error_message" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "meeting_owner_id" "uuid",
    "org_id" "uuid",
    CONSTRAINT "meeting_file_search_index_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'indexing'::"text", 'indexed'::"text", 'failed'::"text"])))
);

-- ALTER TABLE "public"."meeting_file_search_index" OWNER TO "postgres";

COMMENT ON TABLE "public"."meeting_file_search_index" IS 'Tracks which meetings have been indexed to File Search';

CREATE TABLE IF NOT EXISTS "public"."meeting_generated_content" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid" NOT NULL,
    "content_type" "text" NOT NULL,
    "title" "text",
    "content" "text" NOT NULL,
    "version" integer DEFAULT 1 NOT NULL,
    "parent_id" "uuid",
    "is_latest" boolean DEFAULT true NOT NULL,
    "model_used" "text" NOT NULL,
    "prompt_used" "text",
    "tokens_used" integer,
    "cost_cents" integer,
    "created_by" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "deleted_at" timestamp with time zone,
    CONSTRAINT "meeting_generated_content_content_type_check" CHECK (("content_type" = ANY (ARRAY['social'::"text", 'blog'::"text", 'video'::"text", 'email'::"text"]))),
    CONSTRAINT "meeting_generated_content_cost_cents_check" CHECK (("cost_cents" >= 0)),
    CONSTRAINT "meeting_generated_content_tokens_used_check" CHECK (("tokens_used" >= 0)),
    CONSTRAINT "version_positive" CHECK (("version" > 0))
);

-- ALTER TABLE "public"."meeting_generated_content" OWNER TO "postgres";

COMMENT ON TABLE "public"."meeting_generated_content" IS 'Stores AI-generated marketing content with full version history';

COMMENT ON COLUMN "public"."meeting_generated_content"."content_type" IS 'Type of content: social (posts), blog (articles), video (scripts), email (newsletters)';

COMMENT ON COLUMN "public"."meeting_generated_content"."version" IS 'Version number for tracking regenerations (1, 2, 3...)';

COMMENT ON COLUMN "public"."meeting_generated_content"."parent_id" IS 'Links to previous version for version chain';

COMMENT ON COLUMN "public"."meeting_generated_content"."is_latest" IS 'Flag for quickly finding the most recent version';

CREATE TABLE IF NOT EXISTS "public"."meeting_index_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid",
    "user_id" "uuid",
    "priority" integer DEFAULT 0,
    "attempts" integer DEFAULT 0,
    "max_attempts" integer DEFAULT 3,
    "last_attempt_at" timestamp with time zone,
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "status" "text" DEFAULT 'pending'::"text",
    "last_error" "text",
    "processed_at" timestamp with time zone,
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."meeting_index_queue" OWNER TO "postgres";

COMMENT ON TABLE "public"."meeting_index_queue" IS 'Queue for async processing of meeting indexing jobs';

CREATE TABLE IF NOT EXISTS "public"."meeting_intelligence_queries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "query_text" "text" NOT NULL,
    "parsed_semantic_query" "text",
    "parsed_filters" "jsonb",
    "results_count" integer,
    "response_time_ms" integer,
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."meeting_intelligence_queries" OWNER TO "postgres";

COMMENT ON TABLE "public"."meeting_intelligence_queries" IS 'Audit log of user queries for analytics';

CREATE TABLE IF NOT EXISTS "public"."meeting_metrics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid",
    "words_spoken_rep" integer,
    "words_spoken_customer" integer,
    "avg_response_latency_ms" integer,
    "interruption_count" integer
);

-- ALTER TABLE "public"."meeting_metrics" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."meeting_scorecards" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid",
    "template_id" "uuid",
    "org_id" "uuid" NOT NULL,
    "rep_user_id" "uuid",
    "overall_score" integer,
    "grade" "text",
    "metric_scores" "jsonb" DEFAULT '{}'::"jsonb",
    "talk_time_rep_pct" numeric,
    "talk_time_customer_pct" numeric,
    "discovery_questions_count" integer DEFAULT 0,
    "discovery_questions_examples" "jsonb" DEFAULT '[]'::"jsonb",
    "next_steps_established" boolean,
    "next_steps_details" "text",
    "monologue_instances" "jsonb" DEFAULT '[]'::"jsonb",
    "monologue_count" integer DEFAULT 0,
    "checklist_results" "jsonb" DEFAULT '{}'::"jsonb",
    "checklist_completion_pct" integer DEFAULT 0,
    "checklist_required_completion_pct" integer DEFAULT 0,
    "script_adherence_score" integer,
    "script_flow_analysis" "jsonb" DEFAULT '{}'::"jsonb",
    "strengths" "jsonb" DEFAULT '[]'::"jsonb",
    "areas_for_improvement" "jsonb" DEFAULT '[]'::"jsonb",
    "specific_feedback" "text",
    "coaching_tips" "jsonb" DEFAULT '[]'::"jsonb",
    "key_moments" "jsonb" DEFAULT '[]'::"jsonb",
    "detected_meeting_type" "text",
    "ai_model_used" "text",
    "tokens_used" integer,
    "processing_time_ms" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "workflow_checklist_results" "jsonb" DEFAULT '[]'::"jsonb",
    CONSTRAINT "meeting_scorecards_grade_check" CHECK (("grade" = ANY (ARRAY['A'::"text", 'B'::"text", 'C'::"text", 'D'::"text", 'F'::"text"]))),
    CONSTRAINT "meeting_scorecards_overall_score_check" CHECK ((("overall_score" >= 0) AND ("overall_score" <= 100)))
);

-- ALTER TABLE "public"."meeting_scorecards" OWNER TO "postgres";

COMMENT ON TABLE "public"."meeting_scorecards" IS 'Individual scorecard results for each analyzed meeting';

COMMENT ON COLUMN "public"."meeting_scorecards"."workflow_checklist_results" IS 'Results from workflow checklist analysis showing which items were covered';

CREATE TABLE IF NOT EXISTS "public"."meeting_structured_summaries" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid",
    "org_id" "uuid" NOT NULL,
    "key_decisions" "jsonb" DEFAULT '[]'::"jsonb",
    "rep_commitments" "jsonb" DEFAULT '[]'::"jsonb",
    "prospect_commitments" "jsonb" DEFAULT '[]'::"jsonb",
    "stakeholders_mentioned" "jsonb" DEFAULT '[]'::"jsonb",
    "pricing_discussed" "jsonb" DEFAULT '{}'::"jsonb",
    "technical_requirements" "jsonb" DEFAULT '[]'::"jsonb",
    "outcome_signals" "jsonb" DEFAULT '{}'::"jsonb",
    "stage_indicators" "jsonb" DEFAULT '{}'::"jsonb",
    "competitor_mentions" "jsonb" DEFAULT '[]'::"jsonb",
    "objections" "jsonb" DEFAULT '[]'::"jsonb",
    "ai_model_used" "text",
    "tokens_used" integer,
    "processing_time_ms" integer,
    "version" integer DEFAULT 1,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."meeting_structured_summaries" OWNER TO "postgres";

COMMENT ON TABLE "public"."meeting_structured_summaries" IS 'AI-extracted structured data from meeting transcripts including decisions, commitments, stakeholders, pricing, and outcome signals';

CREATE TABLE IF NOT EXISTS "public"."meeting_topics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid",
    "label" "text"
);

-- ALTER TABLE "public"."meeting_topics" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."meeting_workflow_results" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid" NOT NULL,
    "call_type_id" "uuid",
    "org_id" "uuid",
    "checklist_results" "jsonb" DEFAULT '[]'::"jsonb",
    "coverage_score" numeric(5,2),
    "required_coverage_score" numeric(5,2),
    "missing_required_items" "text"[],
    "notifications_sent" "jsonb" DEFAULT '{}'::"jsonb",
    "notifications_scheduled_at" timestamp with time zone,
    "notifications_sent_at" timestamp with time zone,
    "pipeline_action_taken" "text",
    "pipeline_action_details" "jsonb",
    "forward_movement_signals" "jsonb" DEFAULT '[]'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."meeting_workflow_results" OWNER TO "postgres";

COMMENT ON TABLE "public"."meeting_workflow_results" IS 'Stores workflow execution results including checklist coverage, notifications sent, and pipeline actions taken';

COMMENT ON COLUMN "public"."meeting_workflow_results"."checklist_results" IS 'Array of checklist item results with coverage status and evidence quotes';

COMMENT ON COLUMN "public"."meeting_workflow_results"."coverage_score" IS 'Percentage of all checklist items that were covered (0-100)';

COMMENT ON COLUMN "public"."meeting_workflow_results"."required_coverage_score" IS 'Percentage of required checklist items that were covered (0-100)';

COMMENT ON COLUMN "public"."meeting_workflow_results"."forward_movement_signals" IS 'Detected forward movement signals that may trigger pipeline automation';

CREATE TABLE IF NOT EXISTS "public"."meetingbaas_calendars" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid",
    "meetingbaas_calendar_id" "text" NOT NULL,
    "raw_calendar_id" "text" DEFAULT 'primary'::"text" NOT NULL,
    "platform" "text" DEFAULT 'google'::"text" NOT NULL,
    "email" "text",
    "name" "text",
    "is_active" boolean DEFAULT true,
    "last_sync_at" timestamp with time zone,
    "sync_error" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "meetingbaas_calendars_platform_check" CHECK (("platform" = ANY (ARRAY['google'::"text", 'microsoft'::"text"])))
);

-- ALTER TABLE "public"."meetingbaas_calendars" OWNER TO "postgres";

COMMENT ON TABLE "public"."meetingbaas_calendars" IS 'Stores MeetingBaaS calendar connections for automatic bot deployment';

CREATE OR REPLACE VIEW "public"."meta_ads_analytics" WITH ("security_invoker"='true') AS
 WITH "parsed_signups" AS (
         SELECT "meetings_waitlist"."id",
            "meetings_waitlist"."email",
            "meetings_waitlist"."full_name",
            "meetings_waitlist"."company_name",
            "meetings_waitlist"."created_at",
            "meetings_waitlist"."registration_url",
            "meetings_waitlist"."utm_source",
            "meetings_waitlist"."utm_medium",
            "meetings_waitlist"."utm_campaign",
            COALESCE(NULL::"text", ("regexp_match"("meetings_waitlist"."registration_url", 'utm_content=([^&]+)'::"text"))[1]) AS "utm_content",
            ("regexp_match"("meetings_waitlist"."registration_url", 'utm_term=([^&]+)'::"text"))[1] AS "utm_term",
            ("regexp_match"("meetings_waitlist"."registration_url", 'utm_id=([^&]+)'::"text"))[1] AS "utm_id",
            ("regexp_match"("meetings_waitlist"."registration_url", 'fbclid=([^&]+)'::"text"))[1] AS "fbclid",
                CASE
                    WHEN ("meetings_waitlist"."registration_url" ~~ '%?%'::"text") THEN "split_part"("meetings_waitlist"."registration_url", '?'::"text", 1)
                    ELSE "meetings_waitlist"."registration_url"
                END AS "landing_page"
           FROM "public"."meetings_waitlist"
          WHERE (("meetings_waitlist"."is_seeded" IS NOT TRUE) AND (("meetings_waitlist"."utm_source" IS NOT NULL) OR ("meetings_waitlist"."registration_url" ~~ '%utm_%'::"text") OR ("meetings_waitlist"."registration_url" ~~ '%fbclid%'::"text")))
        )
 SELECT COALESCE("utm_source",
        CASE
            WHEN ("fbclid" IS NOT NULL) THEN 'facebook'::"text"
            ELSE 'unknown'::"text"
        END) AS "source",
        CASE COALESCE("utm_source",
            CASE
                WHEN ("fbclid" IS NOT NULL) THEN 'fb'::"text"
                ELSE 'unknown'::"text"
            END)
            WHEN 'fb'::"text" THEN 'Facebook'::"text"
            WHEN 'ig'::"text" THEN 'Instagram'::"text"
            WHEN 'an'::"text" THEN 'Audience Network'::"text"
            WHEN 'facebook'::"text" THEN 'Facebook'::"text"
            WHEN 'messenger'::"text" THEN 'Messenger'::"text"
            ELSE COALESCE("utm_source", 'Unknown'::"text")
        END AS "source_name",
    COALESCE("utm_medium", 'unknown'::"text") AS "medium",
    "utm_campaign" AS "campaign_id",
    "utm_id" AS "meta_campaign_id",
    "utm_content" AS "creative_id",
    "utm_term" AS "adset_id",
    "landing_page",
    "count"(*) AS "conversions",
    "min"("created_at") AS "first_conversion",
    "max"("created_at") AS "last_conversion",
    "array_agg"("jsonb_build_object"('id', "id", 'email', "email", 'name', "full_name", 'company', "company_name", 'date', "created_at") ORDER BY "created_at" DESC) AS "signups"
   FROM "parsed_signups"
  GROUP BY COALESCE("utm_source",
        CASE
            WHEN ("fbclid" IS NOT NULL) THEN 'facebook'::"text"
            ELSE 'unknown'::"text"
        END),
        CASE COALESCE("utm_source",
            CASE
                WHEN ("fbclid" IS NOT NULL) THEN 'fb'::"text"
                ELSE 'unknown'::"text"
            END)
            WHEN 'fb'::"text" THEN 'Facebook'::"text"
            WHEN 'ig'::"text" THEN 'Instagram'::"text"
            WHEN 'an'::"text" THEN 'Audience Network'::"text"
            WHEN 'facebook'::"text" THEN 'Facebook'::"text"
            WHEN 'messenger'::"text" THEN 'Messenger'::"text"
            ELSE COALESCE("utm_source", 'Unknown'::"text")
        END, COALESCE("utm_medium", 'unknown'::"text"), "utm_campaign", "utm_id", "utm_content", "utm_term", "landing_page"
  ORDER BY ("count"(*)) DESC;

-- ALTER VIEW "public"."meta_ads_analytics" OWNER TO "postgres";

CREATE OR REPLACE VIEW "public"."meta_ads_daily_summary" WITH ("security_invoker"='true') AS
 SELECT "date"("created_at") AS "date",
    COALESCE("utm_source",
        CASE
            WHEN ("registration_url" ~~ '%fbclid%'::"text") THEN 'facebook'::"text"
            ELSE 'organic'::"text"
        END) AS "source",
        CASE
            WHEN (("registration_url" ~~ '%/intro%'::"text") AND ("registration_url" !~~ '%/introducing%'::"text") AND ("registration_url" !~~ '%/introduction%'::"text")) THEN '/intro'::"text"
            WHEN ("registration_url" ~~ '%/introducing%'::"text") THEN '/introducing'::"text"
            WHEN ("registration_url" ~~ '%/introduction%'::"text") THEN '/introduction'::"text"
            WHEN ("registration_url" ~~ '%/waitlist%'::"text") THEN '/waitlist'::"text"
            ELSE 'other'::"text"
        END AS "landing_page",
    "count"(*) AS "conversions",
    "count"(DISTINCT ("regexp_match"("registration_url", 'utm_campaign=([^&]+)'::"text"))[1]) AS "campaigns",
    "count"(DISTINCT ("regexp_match"("registration_url", 'utm_content=([^&]+)'::"text"))[1]) AS "creatives"
   FROM "public"."meetings_waitlist"
  WHERE ("is_seeded" IS NOT TRUE)
  GROUP BY ("date"("created_at")), COALESCE("utm_source",
        CASE
            WHEN ("registration_url" ~~ '%fbclid%'::"text") THEN 'facebook'::"text"
            ELSE 'organic'::"text"
        END),
        CASE
            WHEN (("registration_url" ~~ '%/intro%'::"text") AND ("registration_url" !~~ '%/introducing%'::"text") AND ("registration_url" !~~ '%/introduction%'::"text")) THEN '/intro'::"text"
            WHEN ("registration_url" ~~ '%/introducing%'::"text") THEN '/introducing'::"text"
            WHEN ("registration_url" ~~ '%/introduction%'::"text") THEN '/introduction'::"text"
            WHEN ("registration_url" ~~ '%/waitlist%'::"text") THEN '/waitlist'::"text"
            ELSE 'other'::"text"
        END
  ORDER BY ("date"("created_at")) DESC, ("count"(*)) DESC;

-- ALTER VIEW "public"."meta_ads_daily_summary" OWNER TO "postgres";

CREATE OR REPLACE VIEW "public"."monthly_ai_usage" WITH ("security_invoker"='true') AS
 SELECT "user_id",
    "date_trunc"('month'::"text", "created_at") AS "month",
    "provider",
    "model",
    "count"(*) AS "request_count",
    "sum"("prompt_tokens") AS "total_prompt_tokens",
    "sum"("completion_tokens") AS "total_completion_tokens",
    "sum"("total_tokens") AS "total_tokens",
    "sum"("cost_estimate") AS "total_cost"
   FROM "public"."ai_usage_logs"
  GROUP BY "user_id", ("date_trunc"('month'::"text", "created_at")), "provider", "model"
  ORDER BY ("date_trunc"('month'::"text", "created_at")) DESC, "user_id";

-- ALTER VIEW "public"."monthly_ai_usage" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."organization_subscriptions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "plan_id" "uuid" NOT NULL,
    "status" "text" DEFAULT 'active'::"text" NOT NULL,
    "billing_cycle" "text" DEFAULT 'monthly'::"text" NOT NULL,
    "started_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "current_period_start" timestamp with time zone DEFAULT "now"() NOT NULL,
    "current_period_end" timestamp with time zone DEFAULT ("now"() + '1 mon'::interval) NOT NULL,
    "trial_ends_at" timestamp with time zone,
    "canceled_at" timestamp with time zone,
    "stripe_subscription_id" "text",
    "stripe_customer_id" "text",
    "custom_max_users" integer,
    "custom_max_meetings" integer,
    "custom_max_ai_tokens" integer,
    "custom_max_storage_mb" integer,
    "admin_notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "stripe_price_id" "text",
    "trial_start_at" timestamp with time zone,
    "quantity" integer DEFAULT 1,
    "cancel_at_period_end" boolean DEFAULT false,
    "cancellation_reason" "text",
    "stripe_latest_invoice_id" "text",
    "stripe_payment_method_id" "text",
    "current_recurring_amount_cents" integer,
    "recurring_interval" "text",
    "interval_count" integer DEFAULT 1,
    "discount_info" "jsonb" DEFAULT '{}'::"jsonb",
    "customer_country" "text",
    "currency" "text" DEFAULT 'GBP'::"text",
    "first_payment_at" timestamp with time zone,
    "last_payment_at" timestamp with time zone,
    CONSTRAINT "organization_subscriptions_billing_cycle_check" CHECK (("billing_cycle" = ANY (ARRAY['monthly'::"text", 'yearly'::"text"]))),
    CONSTRAINT "organization_subscriptions_recurring_interval_check" CHECK (("recurring_interval" = ANY (ARRAY['month'::"text", 'year'::"text"]))),
    CONSTRAINT "organization_subscriptions_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'trialing'::"text", 'past_due'::"text", 'canceled'::"text", 'paused'::"text"])))
);

-- ALTER TABLE "public"."organization_subscriptions" OWNER TO "postgres";

COMMENT ON TABLE "public"."organization_subscriptions" IS 'Links organizations to their active subscription plan';

COMMENT ON COLUMN "public"."organization_subscriptions"."current_recurring_amount_cents" IS 'Actual recurring amount in cents (accounts for discounts/coupons)';

COMMENT ON COLUMN "public"."organization_subscriptions"."recurring_interval" IS 'Recurring interval: month or year';

COMMENT ON COLUMN "public"."organization_subscriptions"."interval_count" IS 'Number of intervals (1 for monthly, 12 for yearly)';

COMMENT ON COLUMN "public"."organization_subscriptions"."discount_info" IS 'Discount/coupon information (JSONB)';

COMMENT ON COLUMN "public"."organization_subscriptions"."customer_country" IS 'Customer country code (for segmentation)';

COMMENT ON COLUMN "public"."organization_subscriptions"."first_payment_at" IS 'Date of first successful payment (for cohort analysis)';

COMMENT ON COLUMN "public"."organization_subscriptions"."last_payment_at" IS 'Date of last successful payment (for churn detection)';

CREATE TABLE IF NOT EXISTS "public"."subscription_plans" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "description" "text",
    "price_monthly" integer DEFAULT 0 NOT NULL,
    "price_yearly" integer DEFAULT 0 NOT NULL,
    "currency" "text" DEFAULT 'USD'::"text" NOT NULL,
    "max_users" integer,
    "max_meetings_per_month" integer,
    "max_ai_tokens_per_month" integer,
    "max_storage_mb" integer,
    "features" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "is_active" boolean DEFAULT true,
    "is_default" boolean DEFAULT false,
    "display_order" integer DEFAULT 0,
    "badge_text" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "stripe_product_id" "text",
    "stripe_price_id_monthly" "text",
    "stripe_price_id_yearly" "text",
    "stripe_seat_price_id" "text",
    "included_seats" integer DEFAULT 1,
    "per_seat_price" integer DEFAULT 0,
    "meeting_retention_months" integer,
    "trial_days" integer DEFAULT 14,
    "is_free_tier" boolean DEFAULT false,
    "is_public" boolean DEFAULT true,
    "cta_text" "text" DEFAULT 'Get Started'::"text",
    "cta_url" "text",
    "highlight_features" "text"[] DEFAULT '{}'::"text"[],
    "stripe_synced_at" timestamp with time zone,
    "stripe_sync_error" "text"
);

-- ALTER TABLE "public"."subscription_plans" OWNER TO "postgres";

COMMENT ON TABLE "public"."subscription_plans" IS 'Available subscription tiers with pricing and limits';

COMMENT ON COLUMN "public"."subscription_plans"."stripe_seat_price_id" IS 'Stripe price ID for additional seat billing';

COMMENT ON COLUMN "public"."subscription_plans"."included_seats" IS 'Number of seats included in the base price (e.g., 2 for Team plan)';

COMMENT ON COLUMN "public"."subscription_plans"."per_seat_price" IS 'Price in pence for each additional seat beyond included_seats';

COMMENT ON COLUMN "public"."subscription_plans"."is_free_tier" IS 'Marks this plan as the free tier (no payment 
  required)';

COMMENT ON COLUMN "public"."subscription_plans"."is_public" IS 'Whether to show this plan on the public pricing 
  page';

COMMENT ON COLUMN "public"."subscription_plans"."cta_text" IS 'Custom call-to-action button text for pricing 
  cards';

COMMENT ON COLUMN "public"."subscription_plans"."cta_url" IS 'Optional custom URL for CTA button (if not 
  standard checkout)';

COMMENT ON COLUMN "public"."subscription_plans"."highlight_features" IS 'Array of feature bullet points for 
  pricing cards';

COMMENT ON COLUMN "public"."subscription_plans"."stripe_synced_at" IS 'Last time this plan was synced with 
  Stripe';

COMMENT ON COLUMN "public"."subscription_plans"."stripe_sync_error" IS 'Error message from last Stripe sync 
  attempt';

CREATE OR REPLACE VIEW "public"."subscription_facts_view" AS
 SELECT "os"."id",
    "os"."org_id",
    "os"."plan_id",
    "sp"."slug" AS "plan_slug",
    "sp"."name" AS "plan_name",
    "os"."status",
    "os"."billing_cycle",
    "os"."started_at",
    "os"."current_period_start",
    "os"."current_period_end",
    "os"."trial_start_at",
    "os"."trial_ends_at",
    "os"."canceled_at",
    "os"."cancel_at_period_end",
    "os"."current_recurring_amount_cents",
    "os"."recurring_interval",
    "os"."interval_count",
    "os"."currency",
    "public"."calculate_normalized_monthly_amount"("os"."current_recurring_amount_cents", "os"."recurring_interval", "os"."interval_count") AS "normalized_mrr_cents",
    "os"."discount_info",
    "os"."customer_country",
    "os"."first_payment_at",
    "os"."last_payment_at",
    "os"."stripe_subscription_id",
    "os"."stripe_customer_id",
    "os"."stripe_price_id",
    "date_trunc"('month'::"text", "os"."started_at") AS "cohort_month",
    "date_trunc"('week'::"text", "os"."started_at") AS "cohort_week",
    ("os"."status" = ANY (ARRAY['active'::"text", 'trialing'::"text"])) AS "is_active",
    ("os"."status" = 'trialing'::"text") AS "is_trialing",
    "os"."created_at",
    "os"."updated_at"
   FROM ("public"."organization_subscriptions" "os"
     JOIN "public"."subscription_plans" "sp" ON (("sp"."id" = "os"."plan_id")));

-- ALTER VIEW "public"."subscription_facts_view" OWNER TO "postgres";

COMMENT ON VIEW "public"."subscription_facts_view" IS 'View of subscription facts with normalized MRR for analytics';

CREATE OR REPLACE VIEW "public"."mrr_current_view" AS
 SELECT COALESCE("sum"("normalized_mrr_cents"), (0)::bigint) AS "total_mrr_cents",
    "count"(*) FILTER (WHERE "is_active") AS "active_subscriptions",
    "count"(*) FILTER (WHERE "is_trialing") AS "trialing_subscriptions",
    "currency"
   FROM "public"."subscription_facts_view"
  WHERE ("is_active" = true)
  GROUP BY "currency";

-- ALTER VIEW "public"."mrr_current_view" OWNER TO "postgres";

COMMENT ON VIEW "public"."mrr_current_view" IS 'Current MRR snapshot (active subscriptions only)';

CREATE OR REPLACE VIEW "public"."mrr_movement_view" AS
 SELECT ("occurred_at")::"date" AS "change_date",
    COALESCE(("metadata" ->> 'currency'::"text"), 'GBP'::"text") AS "currency",
    "count"(*) FILTER (WHERE ("event_type" = 'subscription_created'::"text")) AS "new_subscriptions",
    COALESCE("sum"((("metadata" ->> 'amount'::"text"))::bigint) FILTER (WHERE ("event_type" = 'subscription_created'::"text")), (0)::numeric) AS "new_mrr_cents",
    "count"(*) FILTER (WHERE ("event_type" = 'subscription_updated'::"text")) AS "plan_changes",
    "count"(*) FILTER (WHERE ("event_type" = 'subscription_canceled'::"text")) AS "canceled_subscriptions",
    COALESCE("sum"((("metadata" ->> 'amount'::"text"))::bigint) FILTER (WHERE ("event_type" = 'subscription_canceled'::"text")), (0)::numeric) AS "churned_mrr_cents"
   FROM "public"."billing_event_log" "bel"
  WHERE (("provider" = 'stripe'::"text") AND ("event_type" = ANY (ARRAY['subscription_created'::"text", 'subscription_updated'::"text", 'subscription_canceled'::"text"])) AND ("processed_at" IS NOT NULL))
  GROUP BY (("occurred_at")::"date"), COALESCE(("metadata" ->> 'currency'::"text"), 'GBP'::"text")
  ORDER BY (("occurred_at")::"date") DESC, COALESCE(("metadata" ->> 'currency'::"text"), 'GBP'::"text");

-- ALTER VIEW "public"."mrr_movement_view" OWNER TO "postgres";

COMMENT ON VIEW "public"."mrr_movement_view" IS 'MRR movement breakdown (new, expansion, contraction, churned)';

-- ALTER TABLE "public"."next_action_suggestions" OWNER TO "postgres";

COMMENT ON TABLE "public"."next_action_suggestions" IS 'AI-generated next-best-action suggestions based on sales activities';

COMMENT ON COLUMN "public"."next_action_suggestions"."activity_id" IS 'ID of the source activity (meeting, email, etc.)';

COMMENT ON COLUMN "public"."next_action_suggestions"."activity_type" IS 'Type of source activity';

COMMENT ON COLUMN "public"."next_action_suggestions"."action_type" IS 'Specific action category (e.g., send_roi_calculator, schedule_demo)';

COMMENT ON COLUMN "public"."next_action_suggestions"."reasoning" IS 'AI-generated explanation for why this action is recommended';

COMMENT ON COLUMN "public"."next_action_suggestions"."confidence_score" IS 'AI confidence in this suggestion (0.0 to 1.0)';

COMMENT ON COLUMN "public"."next_action_suggestions"."context_quality" IS 'Quality of context used for analysis (0.0 to 1.0)';

COMMENT ON COLUMN "public"."next_action_suggestions"."timestamp_seconds" IS 'Second in the meeting recording where this action was discussed. Used for click-to-play in Fathom.';

COMMENT ON COLUMN "public"."next_action_suggestions"."importance" IS 'Importance level for auto-sync filtering: high (critical), medium (standard), low (optional)';

CREATE TABLE IF NOT EXISTS "public"."node_executions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "execution_id" "uuid" NOT NULL,
    "node_id" "text" NOT NULL,
    "node_type" "text" NOT NULL,
    "started_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "status" "text" NOT NULL,
    "input_data" "jsonb" DEFAULT '{}'::"jsonb",
    "output_data" "jsonb" DEFAULT '{}'::"jsonb",
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "node_executions_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'running'::"text", 'completed'::"text", 'failed'::"text", 'skipped'::"text"])))
);

-- ALTER TABLE "public"."node_executions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."node_fixtures" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid" NOT NULL,
    "node_id" "text" NOT NULL,
    "fixture_name" "text" NOT NULL,
    "fixture_type" "text",
    "environment" "text",
    "data" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "node_fixtures_environment_check" CHECK (("environment" = ANY (ARRAY['build'::"text", 'staging'::"text", 'live'::"text"]))),
    CONSTRAINT "node_fixtures_fixture_type_check" CHECK (("fixture_type" = ANY (ARRAY['input'::"text", 'output'::"text", 'golden'::"text"])))
);

-- ALTER TABLE "public"."node_fixtures" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."notetaker_user_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "is_enabled" boolean DEFAULT false,
    "auto_record_external" boolean DEFAULT true,
    "auto_record_internal" boolean DEFAULT false,
    "notify_before_join" boolean DEFAULT true,
    "notify_minutes_before" integer DEFAULT 5,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "selected_calendar_id" "text" DEFAULT 'primary'::"text",
    CONSTRAINT "notetaker_user_settings_notify_minutes_before_check" CHECK ((("notify_minutes_before" >= 1) AND ("notify_minutes_before" <= 30)))
);

-- ALTER TABLE "public"."notetaker_user_settings" OWNER TO "postgres";

COMMENT ON COLUMN "public"."notetaker_user_settings"."selected_calendar_id" IS 'The Google Calendar ID to watch for meetings. Defaults to "primary".';

CREATE TABLE IF NOT EXISTS "public"."notifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "message" "text" NOT NULL,
    "type" character varying(20) DEFAULT 'info'::character varying,
    "category" character varying(50),
    "entity_type" character varying(50),
    "entity_id" "uuid",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "read" boolean DEFAULT false,
    "read_at" timestamp with time zone,
    "action_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "workflow_execution_id" "uuid",
    "expires_at" timestamp with time zone,
    CONSTRAINT "notifications_type_check" CHECK ((("type")::"text" = ANY (ARRAY[('info'::character varying)::"text", ('success'::character varying)::"text", ('warning'::character varying)::"text", ('error'::character varying)::"text"])))
);

-- ALTER TABLE "public"."notifications" OWNER TO "postgres";

CREATE OR REPLACE VIEW "public"."notification_counts_by_user" WITH ("security_invoker"='true') AS
 SELECT "n"."user_id",
    "p"."email" AS "user_email",
    "count"(*) AS "total_notifications",
    "count"(*) FILTER (WHERE ("n"."read" = false)) AS "unread_notifications",
    "count"(*) FILTER (WHERE (("n"."type")::"text" = 'error'::"text")) AS "error_notifications",
    "count"(*) FILTER (WHERE (("n"."type")::"text" = 'warning'::"text")) AS "warning_notifications",
    "count"(*) FILTER (WHERE (("n"."type")::"text" = 'info'::"text")) AS "info_notifications",
    "count"(*) FILTER (WHERE (("n"."type")::"text" = 'success'::"text")) AS "success_notifications",
    "count"(*) FILTER (WHERE ("n"."created_at" > ("now"() - '01:00:00'::interval))) AS "last_hour",
    "count"(*) FILTER (WHERE ("n"."created_at" > ("now"() - '24:00:00'::interval))) AS "last_24_hours",
    "count"(*) FILTER (WHERE ("n"."created_at" > ("now"() - '7 days'::interval))) AS "last_7_days",
    "max"("n"."created_at") AS "last_notification_at",
    "min"("n"."created_at") AS "first_notification_at"
   FROM ("public"."notifications" "n"
     LEFT JOIN "public"."profiles" "p" ON (("p"."id" = "n"."user_id")))
  GROUP BY "n"."user_id", "p"."email";

-- ALTER VIEW "public"."notification_counts_by_user" OWNER TO "postgres";

COMMENT ON VIEW "public"."notification_counts_by_user" IS 'Shows notification counts and statistics per user for monitoring.';

CREATE TABLE IF NOT EXISTS "public"."notification_feedback" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "feedback_type" "text" NOT NULL,
    "feedback_value" "text" NOT NULL,
    "feedback_source" "text" NOT NULL,
    "notification_type" "text",
    "triggered_by_notification_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "notification_feedback_feedback_source_check" CHECK (("feedback_source" = ANY (ARRAY['slack_button'::"text", 'settings_page'::"text", 'in_app'::"text", 'survey'::"text"]))),
    CONSTRAINT "notification_feedback_feedback_type_check" CHECK (("feedback_type" = ANY (ARRAY['frequency_preference'::"text", 'notification_rating'::"text", 'content_feedback'::"text"])))
);

-- ALTER TABLE "public"."notification_feedback" OWNER TO "postgres";

COMMENT ON TABLE "public"."notification_feedback" IS 'Explicit user feedback on notification frequency and helpfulness';

CREATE OR REPLACE VIEW "public"."notification_flood_alerts" WITH ("security_invoker"='true') AS
 SELECT "user_id",
    "user_email",
    "total_notifications",
    "unread_notifications",
    "error_notifications",
    "last_hour",
    "last_24_hours",
    "last_7_days",
    "last_notification_at",
        CASE
            WHEN (("last_hour" > 100) OR ("last_24_hours" > 1000)) THEN 'CRITICAL'::"text"
            WHEN (("last_hour" > 50) OR ("last_24_hours" > 500) OR ("error_notifications" > 500)) THEN 'HIGH'::"text"
            WHEN (("last_hour" > 20) OR ("last_24_hours" > 200) OR ("error_notifications" > 100)) THEN 'MEDIUM'::"text"
            WHEN (("last_hour" > 10) OR ("last_24_hours" > 100) OR ("error_notifications" > 50)) THEN 'LOW'::"text"
            ELSE 'NORMAL'::"text"
        END AS "alert_level",
        CASE
            WHEN ("last_hour" > 100) THEN "concat"('FLOOD: ', "last_hour", ' notifications in last hour')
            WHEN ("last_24_hours" > 1000) THEN "concat"('FLOOD: ', "last_24_hours", ' notifications in 24 hours')
            WHEN ("last_hour" > 50) THEN "concat"('HIGH: ', "last_hour", ' notifications in last hour')
            WHEN ("last_24_hours" > 500) THEN "concat"('HIGH: ', "last_24_hours", ' notifications in 24 hours')
            WHEN ("error_notifications" > 500) THEN "concat"('HIGH: ', "error_notifications", ' error notifications')
            WHEN ("last_hour" > 20) THEN "concat"('MEDIUM: ', "last_hour", ' notifications in last hour')
            WHEN ("last_24_hours" > 200) THEN "concat"('MEDIUM: ', "last_24_hours", ' notifications in 24 hours')
            WHEN ("error_notifications" > 100) THEN "concat"('MEDIUM: ', "error_notifications", ' error notifications')
            WHEN ("last_hour" > 10) THEN "concat"('LOW: ', "last_hour", ' notifications in last hour')
            WHEN ("last_24_hours" > 100) THEN "concat"('LOW: ', "last_24_hours", ' notifications in 24 hours')
            WHEN ("error_notifications" > 50) THEN "concat"('LOW: ', "error_notifications", ' error notifications')
            ELSE 'Normal notification levels'::"text"
        END AS "alert_reason",
        CASE
            WHEN (("last_hour" > 100) OR ("last_24_hours" > 1000)) THEN 'URGENT: Investigate notification flood immediately'::"text"
            WHEN (("last_hour" > 50) OR ("last_24_hours" > 500) OR ("error_notifications" > 500)) THEN 'Investigate notification patterns and consider rate limiting'::"text"
            WHEN (("last_hour" > 20) OR ("last_24_hours" > 200) OR ("error_notifications" > 100)) THEN 'Monitor notification patterns'::"text"
            WHEN (("last_hour" > 10) OR ("last_24_hours" > 100) OR ("error_notifications" > 50)) THEN 'Review notification sources'::"text"
            ELSE 'No action needed'::"text"
        END AS "recommended_action"
   FROM "public"."notification_counts_by_user"
  WHERE ("total_notifications" > 0)
  ORDER BY
        CASE
            WHEN (("last_hour" > 100) OR ("last_24_hours" > 1000)) THEN 1
            WHEN (("last_hour" > 50) OR ("last_24_hours" > 500) OR ("error_notifications" > 500)) THEN 2
            WHEN (("last_hour" > 20) OR ("last_24_hours" > 200) OR ("error_notifications" > 100)) THEN 3
            WHEN (("last_hour" > 10) OR ("last_24_hours" > 100) OR ("error_notifications" > 50)) THEN 4
            ELSE 5
        END, "last_24_hours" DESC;

-- ALTER VIEW "public"."notification_flood_alerts" OWNER TO "postgres";

COMMENT ON VIEW "public"."notification_flood_alerts" IS 'Detects notification floods and categorizes users by alert level.';

CREATE TABLE IF NOT EXISTS "public"."notification_interactions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "notification_id" "uuid",
    "slack_notification_sent_id" "uuid",
    "notification_type" "text" NOT NULL,
    "delivered_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "delivered_via" "text" NOT NULL,
    "seen_at" timestamp with time zone,
    "clicked_at" timestamp with time zone,
    "dismissed_at" timestamp with time zone,
    "action_taken" "text",
    "time_to_interaction_seconds" integer,
    "feedback_rating" "text",
    "feedback_at" timestamp with time zone,
    "user_was_active" boolean DEFAULT false,
    "hour_of_day" integer,
    "day_of_week" integer,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "notification_interactions_day_of_week_check" CHECK ((("day_of_week" >= 0) AND ("day_of_week" <= 6))),
    CONSTRAINT "notification_interactions_delivered_via_check" CHECK (("delivered_via" = ANY (ARRAY['slack_dm'::"text", 'slack_channel'::"text", 'in_app'::"text", 'email'::"text"]))),
    CONSTRAINT "notification_interactions_feedback_rating_check" CHECK (("feedback_rating" = ANY (ARRAY['helpful'::"text", 'not_helpful'::"text", 'too_frequent'::"text"]))),
    CONSTRAINT "notification_interactions_hour_of_day_check" CHECK ((("hour_of_day" >= 0) AND ("hour_of_day" <= 23)))
);

-- ALTER TABLE "public"."notification_interactions" OWNER TO "postgres";

COMMENT ON TABLE "public"."notification_interactions" IS 'Tracks delivery and interaction with notifications';

CREATE TABLE IF NOT EXISTS "public"."notification_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "notification_type" "text" NOT NULL,
    "channel" "text" NOT NULL,
    "priority" "text" DEFAULT 'normal'::"text" NOT NULL,
    "payload" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "scheduled_for" timestamp with time zone NOT NULL,
    "optimal_send_time" timestamp with time zone,
    "optimal_time_confidence" numeric(3,2),
    "send_deadline" timestamp with time zone,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "attempts" integer DEFAULT 0,
    "last_attempt_at" timestamp with time zone,
    "error_message" "text",
    "sent_at" timestamp with time zone,
    "notification_interaction_id" "uuid",
    "dedupe_key" "text",
    "dedupe_window_minutes" integer DEFAULT 60,
    "related_entity_type" "text",
    "related_entity_id" "uuid",
    "batch_id" "uuid",
    "is_batched" boolean DEFAULT false,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "notification_queue_channel_check" CHECK (("channel" = ANY (ARRAY['slack_dm'::"text", 'slack_channel'::"text", 'email'::"text", 'in_app'::"text"]))),
    CONSTRAINT "notification_queue_priority_check" CHECK (("priority" = ANY (ARRAY['urgent'::"text", 'high'::"text", 'normal'::"text", 'low'::"text"]))),
    CONSTRAINT "notification_queue_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'scheduled'::"text", 'processing'::"text", 'sent'::"text", 'failed'::"text", 'cancelled'::"text", 'skipped'::"text"])))
);

-- ALTER TABLE "public"."notification_queue" OWNER TO "postgres";

COMMENT ON TABLE "public"."notification_queue" IS 'Queue for notifications with intelligent timing and rate limiting';

CREATE TABLE IF NOT EXISTS "public"."notification_rate_limits" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "notification_type" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

-- ALTER TABLE "public"."notification_rate_limits" OWNER TO "postgres";

COMMENT ON TABLE "public"."notification_rate_limits" IS 'Tracks notification creation rates per user for flood prevention. Records are kept for 24 hours then cleaned up automatically.';

CREATE OR REPLACE VIEW "public"."notification_rate_limit_status" WITH ("security_invoker"='true') AS
 SELECT "nrl"."user_id",
    "p"."email" AS "user_email",
    "nrl"."notification_type",
    "count"(*) FILTER (WHERE ("nrl"."created_at" > ("now"() - '01:00:00'::interval))) AS "count_last_hour",
    "count"(*) FILTER (WHERE ("nrl"."created_at" > ("now"() - '24:00:00'::interval))) AS "count_last_24_hours",
    (10 - "count"(*) FILTER (WHERE ("nrl"."created_at" > ("now"() - '01:00:00'::interval)))) AS "hourly_remaining",
    (50 - "count"(*) FILTER (WHERE ("nrl"."created_at" > ("now"() - '24:00:00'::interval)))) AS "daily_remaining",
    "round"(((("count"(*) FILTER (WHERE ("nrl"."created_at" > ("now"() - '01:00:00'::interval))))::numeric * 100.0) / (10)::numeric), 1) AS "hourly_percent_used",
    "round"(((("count"(*) FILTER (WHERE ("nrl"."created_at" > ("now"() - '24:00:00'::interval))))::numeric * 100.0) / (50)::numeric), 1) AS "daily_percent_used",
        CASE
            WHEN ("count"(*) FILTER (WHERE ("nrl"."created_at" > ("now"() - '01:00:00'::interval))) >= 10) THEN 'HOURLY_LIMIT_REACHED'::"text"
            WHEN ("count"(*) FILTER (WHERE ("nrl"."created_at" > ("now"() - '24:00:00'::interval))) >= 50) THEN 'DAILY_LIMIT_REACHED'::"text"
            WHEN ("count"(*) FILTER (WHERE ("nrl"."created_at" > ("now"() - '01:00:00'::interval))) >= 8) THEN 'HOURLY_WARNING'::"text"
            WHEN ("count"(*) FILTER (WHERE ("nrl"."created_at" > ("now"() - '24:00:00'::interval))) >= 40) THEN 'DAILY_WARNING'::"text"
            ELSE 'NORMAL'::"text"
        END AS "limit_status",
    "max"("nrl"."created_at") AS "last_notification_attempt"
   FROM ("public"."notification_rate_limits" "nrl"
     LEFT JOIN "public"."profiles" "p" ON (("p"."id" = "nrl"."user_id")))
  WHERE ("nrl"."created_at" > ("now"() - '24:00:00'::interval))
  GROUP BY "nrl"."user_id", "p"."email", "nrl"."notification_type"
  ORDER BY ("count"(*) FILTER (WHERE ("nrl"."created_at" > ("now"() - '01:00:00'::interval)))) DESC, ("count"(*) FILTER (WHERE ("nrl"."created_at" > ("now"() - '24:00:00'::interval)))) DESC;

-- ALTER VIEW "public"."notification_rate_limit_status" OWNER TO "postgres";

COMMENT ON VIEW "public"."notification_rate_limit_status" IS 'Shows current rate limit usage and remaining capacity per user and notification type.';

CREATE OR REPLACE VIEW "public"."notification_type_breakdown" WITH ("security_invoker"='true') AS
 SELECT "type" AS "notification_type",
    "category",
    "entity_type",
    "count"(*) AS "total_count",
    "count"(DISTINCT "user_id") AS "affected_users",
    "count"(*) FILTER (WHERE ("read" = false)) AS "unread_count",
    "count"(*) FILTER (WHERE ("created_at" > ("now"() - '01:00:00'::interval))) AS "last_hour_count",
    "count"(*) FILTER (WHERE ("created_at" > ("now"() - '24:00:00'::interval))) AS "last_24_hours_count",
    "count"(*) FILTER (WHERE ("created_at" > ("now"() - '7 days'::interval))) AS "last_7_days_count",
    "max"("created_at") AS "last_created_at",
    "min"("created_at") AS "first_created_at",
    "string_agg"(DISTINCT "title", ' | '::"text" ORDER BY "title") FILTER (WHERE ("created_at" > ("now"() - '24:00:00'::interval))) AS "recent_titles_sample"
   FROM "public"."notifications" "n"
  GROUP BY "type", "category", "entity_type"
  ORDER BY ("count"(*)) DESC;

-- ALTER VIEW "public"."notification_type_breakdown" OWNER TO "postgres";

COMMENT ON VIEW "public"."notification_type_breakdown" IS 'Shows notification distribution by type, category, and entity.';

CREATE TABLE IF NOT EXISTS "public"."org_ai_preferences" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "brand_voice" "text",
    "tone_guidelines" "text",
    "required_disclaimers" "text"[] DEFAULT ARRAY[]::"text"[],
    "blocked_phrases" "text"[] DEFAULT ARRAY[]::"text"[],
    "enable_auto_send" boolean DEFAULT false,
    "min_confidence_for_auto" integer DEFAULT 90,
    "require_manager_approval_above" numeric(12,2),
    "total_suggestions" integer DEFAULT 0,
    "org_approval_rate" numeric(5,4) DEFAULT 0,
    "most_edited_action_types" "text"[] DEFAULT ARRAY[]::"text"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "org_ai_preferences_min_confidence_for_auto_check" CHECK ((("min_confidence_for_auto" >= 0) AND ("min_confidence_for_auto" <= 100)))
);

-- ALTER TABLE "public"."org_ai_preferences" OWNER TO "postgres";

COMMENT ON TABLE "public"."org_ai_preferences" IS 'Organization-wide AI settings including brand voice and compliance rules';

CREATE TABLE IF NOT EXISTS "public"."org_call_types" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "keywords" "text"[] DEFAULT '{}'::"text"[],
    "color" "text" DEFAULT '#6366f1'::"text",
    "icon" "text" DEFAULT 'phone'::"text",
    "is_system" boolean DEFAULT false,
    "is_active" boolean DEFAULT true,
    "display_order" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "enable_coaching" boolean DEFAULT true,
    "workflow_config" "jsonb" DEFAULT '{}'::"jsonb"
);

-- ALTER TABLE "public"."org_call_types" OWNER TO "postgres";

COMMENT ON TABLE "public"."org_call_types" IS 'Organization-level call type definitions for AI-powered meeting classification';

COMMENT ON COLUMN "public"."org_call_types"."keywords" IS 'Keywords used by AI to identify this call type in transcripts';

COMMENT ON COLUMN "public"."org_call_types"."is_system" IS 'System default types cannot be deleted, only deactivated';

COMMENT ON COLUMN "public"."org_call_types"."enable_coaching" IS 'Whether to generate coaching scorecards for this call type. Set to false for internal meetings.';

COMMENT ON COLUMN "public"."org_call_types"."workflow_config" IS 'Custom workflow configuration including checklist_items, notifications, and automations settings.';

CREATE TABLE IF NOT EXISTS "public"."org_email_categorization_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "is_enabled" boolean DEFAULT true,
    "label_mode" "text" DEFAULT 'mode_a_internal_only'::"text" NOT NULL,
    "archive_non_actionable" boolean DEFAULT false,
    "use_ai_categorization" boolean DEFAULT true,
    "use_rules_categorization" boolean DEFAULT true,
    "enabled_categories" "text"[] DEFAULT ARRAY['to_respond'::"text", 'fyi'::"text", 'marketing'::"text"],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "updated_by" "uuid",
    CONSTRAINT "org_email_categorization_settings_label_mode_check" CHECK (("label_mode" = ANY (ARRAY['mode_a_internal_only'::"text", 'mode_b_use_existing'::"text", 'mode_c_sync_labels'::"text"])))
);

-- ALTER TABLE "public"."org_email_categorization_settings" OWNER TO "postgres";

COMMENT ON TABLE "public"."org_email_categorization_settings" IS 'Org-level settings for email categorization (modes A/B/C)';

COMMENT ON COLUMN "public"."org_email_categorization_settings"."label_mode" IS 'Mode A: internal-only (default), Mode B: use existing Gmail labels, Mode C: sync labels to Gmail';

CREATE TABLE IF NOT EXISTS "public"."org_file_search_stores" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "store_name" "text" NOT NULL,
    "display_name" "text",
    "status" "text" DEFAULT 'active'::"text",
    "total_files" integer DEFAULT 0,
    "last_sync_at" timestamp with time zone,
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "org_file_search_stores_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'syncing'::"text", 'error'::"text"])))
);

-- ALTER TABLE "public"."org_file_search_stores" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."org_proposal_workflows" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "icon" "text" DEFAULT 'file-text'::"text",
    "color" "text" DEFAULT 'blue'::"text",
    "include_goals" boolean DEFAULT false NOT NULL,
    "include_sow" boolean DEFAULT false NOT NULL,
    "include_html" boolean DEFAULT false NOT NULL,
    "include_email" boolean DEFAULT false NOT NULL,
    "include_markdown" boolean DEFAULT false NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "display_order" integer DEFAULT 0 NOT NULL,
    "is_default" boolean DEFAULT false NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_by" "uuid",
    "include_formatted" boolean DEFAULT false NOT NULL,
    CONSTRAINT "org_proposal_workflows_has_output" CHECK (("include_goals" OR "include_sow" OR "include_html" OR "include_email" OR "include_formatted" OR "include_markdown"))
);

-- ALTER TABLE "public"."org_proposal_workflows" OWNER TO "postgres";

COMMENT ON COLUMN "public"."org_proposal_workflows"."include_formatted" IS 'When true, generates markdown content that is rendered as formatted text on the frontend';

CREATE TABLE IF NOT EXISTS "public"."organization_context" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "context_key" "text" NOT NULL,
    "value" "jsonb" NOT NULL,
    "value_type" "text" NOT NULL,
    "source" "text" NOT NULL,
    "confidence" numeric(3,2) DEFAULT 1.00,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "organization_context_confidence_check" CHECK ((("confidence" >= (0)::numeric) AND ("confidence" <= (1)::numeric))),
    CONSTRAINT "organization_context_source_check" CHECK (("source" = ANY (ARRAY['scrape'::"text", 'manual'::"text", 'user'::"text", 'enrichment'::"text"]))),
    CONSTRAINT "organization_context_value_type_check" CHECK (("value_type" = ANY (ARRAY['string'::"text", 'array'::"text", 'object'::"text"])))
);

-- ALTER TABLE "public"."organization_context" OWNER TO "postgres";

COMMENT ON TABLE "public"."organization_context" IS 'Stores organization-specific context variables used to compile platform skill templates';

COMMENT ON COLUMN "public"."organization_context"."context_key" IS 'Variable name (e.g., company_name, industry, products)';

COMMENT ON COLUMN "public"."organization_context"."value" IS 'JSONB value that can be string, array, or object';

COMMENT ON COLUMN "public"."organization_context"."value_type" IS 'Type of value for validation and type safety';

COMMENT ON COLUMN "public"."organization_context"."source" IS 'How this context was obtained (scrape, manual, user, enrichment)';

COMMENT ON COLUMN "public"."organization_context"."confidence" IS 'Confidence score from 0.00 to 1.00 for enrichment quality';

CREATE TABLE IF NOT EXISTS "public"."organization_enrichment" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid",
    "domain" "text" NOT NULL,
    "company_name" "text",
    "logo_url" "text",
    "tagline" "text",
    "description" "text",
    "industry" "text",
    "employee_count" "text",
    "funding_stage" "text",
    "founded_year" integer,
    "headquarters" "text",
    "products" "jsonb" DEFAULT '[]'::"jsonb",
    "value_propositions" "jsonb" DEFAULT '[]'::"jsonb",
    "use_cases" "jsonb" DEFAULT '[]'::"jsonb",
    "competitors" "jsonb" DEFAULT '[]'::"jsonb",
    "target_market" "text",
    "ideal_customer_profile" "jsonb" DEFAULT '{}'::"jsonb",
    "key_people" "jsonb" DEFAULT '[]'::"jsonb",
    "recent_hires" "jsonb" DEFAULT '[]'::"jsonb",
    "open_roles" "jsonb" DEFAULT '[]'::"jsonb",
    "tech_stack" "jsonb" DEFAULT '[]'::"jsonb",
    "customer_logos" "jsonb" DEFAULT '[]'::"jsonb",
    "case_studies" "jsonb" DEFAULT '[]'::"jsonb",
    "reviews_summary" "jsonb" DEFAULT '{}'::"jsonb",
    "pain_points" "jsonb" DEFAULT '[]'::"jsonb",
    "buying_signals" "jsonb" DEFAULT '[]'::"jsonb",
    "recent_news" "jsonb" DEFAULT '[]'::"jsonb",
    "sources_used" "jsonb" DEFAULT '[]'::"jsonb",
    "confidence_score" numeric(3,2),
    "model" "text" DEFAULT 'gemini-2.0-flash'::"text",
    "raw_scraped_data" "jsonb" DEFAULT '{}'::"jsonb",
    "generated_skills" "jsonb" DEFAULT '{}'::"jsonb",
    "status" "text" DEFAULT 'pending'::"text",
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "organization_enrichment_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'scraping'::"text", 'analyzing'::"text", 'completed'::"text", 'failed'::"text"])))
);

-- ALTER TABLE "public"."organization_enrichment" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."organization_feature_flags" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "feature_key" "text" NOT NULL,
    "is_enabled" boolean DEFAULT false NOT NULL,
    "usage_limit" integer,
    "override_reason" "text",
    "enabled_by" "uuid",
    "enabled_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."organization_feature_flags" OWNER TO "postgres";

COMMENT ON TABLE "public"."organization_feature_flags" IS 'Per-organization feature overrides';

CREATE TABLE IF NOT EXISTS "public"."organization_invitations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "email" "extensions"."citext" NOT NULL,
    "role" "text" DEFAULT 'member'::"text" NOT NULL,
    "invited_by" "uuid",
    "token" "text" DEFAULT "encode"("extensions"."gen_random_bytes"(32), 'hex'::"text") NOT NULL,
    "expires_at" timestamp with time zone DEFAULT ("now"() + '7 days'::interval) NOT NULL,
    "accepted_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "organization_invitations_role_check" CHECK (("role" = ANY (ARRAY['owner'::"text", 'admin'::"text", 'member'::"text", 'readonly'::"text"])))
);

-- ALTER TABLE "public"."organization_invitations" OWNER TO "postgres";

COMMENT ON TABLE "public"."organization_invitations" IS 'Invitations for users to join organizations';

CREATE TABLE IF NOT EXISTS "public"."organization_skills" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid",
    "skill_id" "text" NOT NULL,
    "skill_name" "text" NOT NULL,
    "config" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "ai_generated" boolean DEFAULT true,
    "user_modified" boolean DEFAULT false,
    "version" integer DEFAULT 1 NOT NULL,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "platform_skill_id" "uuid",
    "platform_skill_version" integer,
    "compiled_frontmatter" "jsonb",
    "compiled_content" "text",
    "user_overrides" "jsonb" DEFAULT '{}'::"jsonb",
    "is_enabled" boolean DEFAULT true,
    "last_compiled_at" timestamp with time zone
);

-- ALTER TABLE "public"."organization_skills" OWNER TO "postgres";

COMMENT ON COLUMN "public"."organization_skills"."platform_skill_id" IS 'Reference to the platform skill template used to compile this skill';

COMMENT ON COLUMN "public"."organization_skills"."platform_skill_version" IS 'Version of the platform skill used for compilation';

COMMENT ON COLUMN "public"."organization_skills"."compiled_frontmatter" IS 'Compiled frontmatter with organization context interpolated';

COMMENT ON COLUMN "public"."organization_skills"."compiled_content" IS 'Compiled markdown content with organization context interpolated';

COMMENT ON COLUMN "public"."organization_skills"."user_overrides" IS 'User-specific customizations that override platform skill content';

COMMENT ON COLUMN "public"."organization_skills"."is_enabled" IS 'Whether this skill is enabled for the organization';

COMMENT ON COLUMN "public"."organization_skills"."last_compiled_at" IS 'Timestamp of last successful compilation';

CREATE TABLE IF NOT EXISTS "public"."organization_skills_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "skill_record_id" "uuid",
    "organization_id" "uuid",
    "skill_id" "text" NOT NULL,
    "config" "jsonb" NOT NULL,
    "version" integer NOT NULL,
    "changed_by" "uuid",
    "change_reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."organization_skills_history" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."organization_usage" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "period_start" "date" NOT NULL,
    "period_end" "date" NOT NULL,
    "meetings_count" integer DEFAULT 0 NOT NULL,
    "meetings_duration_minutes" integer DEFAULT 0 NOT NULL,
    "ai_tokens_used" integer DEFAULT 0 NOT NULL,
    "storage_used_mb" integer DEFAULT 0 NOT NULL,
    "active_users_count" integer DEFAULT 0 NOT NULL,
    "usage_breakdown" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."organization_usage" OWNER TO "postgres";

COMMENT ON TABLE "public"."organization_usage" IS 'Monthly usage snapshots per organization';

CREATE TABLE IF NOT EXISTS "public"."pipeline_automation_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "rule_id" "uuid",
    "meeting_id" "uuid",
    "deal_id" "uuid",
    "trigger_type" "text" NOT NULL,
    "trigger_signal" "jsonb",
    "action_type" "text" NOT NULL,
    "action_result" "jsonb",
    "status" "text" DEFAULT 'success'::"text" NOT NULL,
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "pipeline_automation_log_status_check" CHECK (("status" = ANY (ARRAY['success'::"text", 'failed'::"text", 'skipped'::"text"])))
);

-- ALTER TABLE "public"."pipeline_automation_log" OWNER TO "postgres";

COMMENT ON TABLE "public"."pipeline_automation_log" IS 'Audit log tracking all pipeline automation actions taken';

CREATE TABLE IF NOT EXISTS "public"."pipeline_stage_recommendations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid" NOT NULL,
    "deal_id" "uuid",
    "company_id" "uuid",
    "contact_id" "uuid",
    "user_id" "uuid" NOT NULL,
    "current_stage" "text" NOT NULL,
    "recommended_stage" "text" NOT NULL,
    "confidence_score" numeric,
    "recommendation_reason" "text",
    "meeting_sentiment_score" numeric,
    "meeting_summary" "text",
    "key_signals" "text"[],
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "reviewed_at" timestamp with time zone,
    "reviewed_by" "uuid",
    "review_notes" "text",
    "auto_apply_enabled" boolean DEFAULT false,
    "auto_apply_threshold" numeric DEFAULT 0.85,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone DEFAULT ("now"() + '7 days'::interval),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "pipeline_stage_recommendations_confidence_score_check" CHECK ((("confidence_score" >= (0)::numeric) AND ("confidence_score" <= (1)::numeric))),
    CONSTRAINT "pipeline_stage_recommendations_meeting_sentiment_score_check" CHECK ((("meeting_sentiment_score" >= ('-1'::integer)::numeric) AND ("meeting_sentiment_score" <= (1)::numeric))),
    CONSTRAINT "pipeline_stage_recommendations_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text", 'auto_applied'::"text", 'expired'::"text"])))
);

-- ALTER TABLE "public"."pipeline_stage_recommendations" OWNER TO "postgres";

COMMENT ON TABLE "public"."pipeline_stage_recommendations" IS 'AI-generated pipeline stage recommendations based on meeting sentiment with HITL approval';

COMMENT ON COLUMN "public"."pipeline_stage_recommendations"."confidence_score" IS 'AI confidence in recommendation (0-1)';

COMMENT ON COLUMN "public"."pipeline_stage_recommendations"."key_signals" IS 'Array of key phrases/signals that influenced the recommendation';

COMMENT ON COLUMN "public"."pipeline_stage_recommendations"."status" IS 'pending: awaiting review, approved: user accepted, rejected: user declined, auto_applied: auto-approved above threshold, expired: recommendation too old';

COMMENT ON COLUMN "public"."pipeline_stage_recommendations"."auto_apply_enabled" IS 'If true and confidence > threshold, automatically apply recommendation';

CREATE TABLE IF NOT EXISTS "public"."platform_skills" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "skill_key" "text" NOT NULL,
    "category" "text" NOT NULL,
    "frontmatter" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "content_template" "text" NOT NULL,
    "version" integer DEFAULT 1 NOT NULL,
    "is_active" boolean DEFAULT true,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "platform_skills_category_check" CHECK (("category" = ANY (ARRAY['sales-ai'::"text", 'writing'::"text", 'enrichment'::"text", 'workflows'::"text", 'data-access'::"text", 'output-format'::"text", 'agent-sequence'::"text"])))
);

-- ALTER TABLE "public"."platform_skills" OWNER TO "postgres";

COMMENT ON TABLE "public"."platform_skills" IS 'Platform skills include agent-sequence category for multi-step orchestrated workflows following Context Engineering principles.';

CREATE TABLE IF NOT EXISTS "public"."platform_skills_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "skill_id" "uuid",
    "version" integer NOT NULL,
    "frontmatter" "jsonb" NOT NULL,
    "content_template" "text" NOT NULL,
    "changed_by" "uuid",
    "changed_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."platform_skills_history" OWNER TO "postgres";

-- ALTER TABLE "public"."pricing_plans" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."process_map_coverage_snapshots" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid",
    "process_map_id" "uuid",
    "org_id" "uuid" NOT NULL,
    "total_paths" integer DEFAULT 0 NOT NULL,
    "covered_paths" integer DEFAULT 0 NOT NULL,
    "path_coverage_percent" numeric(5,2) DEFAULT 0 NOT NULL,
    "total_branches" integer DEFAULT 0 NOT NULL,
    "covered_branches" integer DEFAULT 0 NOT NULL,
    "branch_coverage_percent" numeric(5,2) DEFAULT 0 NOT NULL,
    "failure_mode_coverage" "jsonb" DEFAULT '{}'::"jsonb",
    "integrations_with_full_coverage" "text"[] DEFAULT '{}'::"text"[],
    "integrations_with_partial_coverage" "text"[] DEFAULT '{}'::"text"[],
    "uncovered_paths" "jsonb" DEFAULT '[]'::"jsonb",
    "overall_score" numeric(5,2) DEFAULT 0 NOT NULL,
    "total_scenarios" integer DEFAULT 0 NOT NULL,
    "happy_path_scenarios" integer DEFAULT 0,
    "branch_path_scenarios" integer DEFAULT 0,
    "failure_mode_scenarios" integer DEFAULT 0,
    "version" integer DEFAULT 1,
    "process_structure_hash" "text",
    "calculated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

-- ALTER TABLE "public"."process_map_coverage_snapshots" OWNER TO "postgres";

COMMENT ON TABLE "public"."process_map_coverage_snapshots" IS 'Coverage analysis snapshots for versioning and comparison';

COMMENT ON COLUMN "public"."process_map_coverage_snapshots"."uncovered_paths" IS 'Array of paths that lack test coverage';

COMMENT ON COLUMN "public"."process_map_coverage_snapshots"."overall_score" IS 'Weighted coverage score (0-100) combining path, branch, and failure mode coverage';

CREATE TABLE IF NOT EXISTS "public"."process_map_fixtures" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid",
    "org_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "fixture_type" "text" NOT NULL,
    "data" "jsonb" NOT NULL,
    "target_step_id" "text",
    "target_integration" "text",
    "is_default" boolean DEFAULT false,
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "process_map_fixtures_fixture_type_check" CHECK (("fixture_type" = ANY (ARRAY['trigger_data'::"text", 'step_input'::"text", 'step_output'::"text", 'full_scenario'::"text", 'integration_response'::"text"])))
);

-- ALTER TABLE "public"."process_map_fixtures" OWNER TO "postgres";

COMMENT ON TABLE "public"."process_map_fixtures" IS 'Reusable test data configurations';

CREATE TABLE IF NOT EXISTS "public"."process_map_mocks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid",
    "org_id" "uuid" NOT NULL,
    "integration" "text" NOT NULL,
    "endpoint" "text",
    "mock_type" "text" DEFAULT 'success'::"text" NOT NULL,
    "response_data" "jsonb",
    "error_response" "jsonb",
    "delay_ms" integer DEFAULT 0,
    "match_conditions" "jsonb",
    "priority" integer DEFAULT 0,
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "process_map_mocks_mock_type_check" CHECK (("mock_type" = ANY (ARRAY['success'::"text", 'error'::"text", 'timeout'::"text", 'rate_limit'::"text", 'auth_failure'::"text", 'custom'::"text"])))
);

-- ALTER TABLE "public"."process_map_mocks" OWNER TO "postgres";

COMMENT ON TABLE "public"."process_map_mocks" IS 'Configurable mock behaviors for integration testing';

CREATE TABLE IF NOT EXISTS "public"."process_map_scenario_runs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "scenario_id" "uuid" NOT NULL,
    "test_run_id" "uuid" NOT NULL,
    "result" "text" NOT NULL,
    "matched_expectation" boolean DEFAULT false NOT NULL,
    "mismatch_details" "text",
    "duration_ms" integer,
    "steps_executed" integer DEFAULT 0,
    "steps_passed" integer DEFAULT 0,
    "steps_failed" integer DEFAULT 0,
    "error_message" "text",
    "failure_step_id" "text",
    "failure_type" "text",
    "executed_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "process_map_scenario_runs_result_check" CHECK (("result" = ANY (ARRAY['pass'::"text", 'fail'::"text", 'partial'::"text", 'error'::"text"])))
);

-- ALTER TABLE "public"."process_map_scenario_runs" OWNER TO "postgres";

COMMENT ON TABLE "public"."process_map_scenario_runs" IS 'History of scenario executions linked to test runs';

CREATE TABLE IF NOT EXISTS "public"."process_map_step_results" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "test_run_id" "uuid" NOT NULL,
    "step_id" "text" NOT NULL,
    "step_name" "text" NOT NULL,
    "sequence_number" integer NOT NULL,
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "duration_ms" integer,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "input_data" "jsonb",
    "output_data" "jsonb",
    "expected_output" "jsonb",
    "validation_results" "jsonb" DEFAULT '[]'::"jsonb",
    "error_message" "text",
    "error_details" "jsonb",
    "error_stack" "text",
    "was_mocked" boolean DEFAULT false,
    "mock_source" "text",
    "logs" "jsonb" DEFAULT '[]'::"jsonb",
    CONSTRAINT "process_map_step_results_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'running'::"text", 'passed'::"text", 'failed'::"text", 'skipped'::"text", 'warning'::"text"])))
);

-- ALTER TABLE "public"."process_map_step_results" OWNER TO "postgres";

COMMENT ON TABLE "public"."process_map_step_results" IS 'Detailed results for each step in a test run';

CREATE TABLE IF NOT EXISTS "public"."process_map_test_runs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid",
    "org_id" "uuid" NOT NULL,
    "run_mode" "text" NOT NULL,
    "test_data" "jsonb" DEFAULT '{}'::"jsonb",
    "run_config" "jsonb" DEFAULT '{}'::"jsonb",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "started_at" timestamp with time zone,
    "completed_at" timestamp with time zone,
    "overall_result" "text",
    "duration_ms" integer,
    "steps_total" integer DEFAULT 0,
    "steps_passed" integer DEFAULT 0,
    "steps_failed" integer DEFAULT 0,
    "steps_skipped" integer DEFAULT 0,
    "error_message" "text",
    "error_details" "jsonb",
    "run_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "process_map_test_runs_overall_result_check" CHECK (("overall_result" = ANY (ARRAY['pass'::"text", 'fail'::"text", 'partial'::"text", 'error'::"text"]))),
    CONSTRAINT "process_map_test_runs_run_mode_check" CHECK (("run_mode" = ANY (ARRAY['schema_validation'::"text", 'mock'::"text", 'production_readonly'::"text"]))),
    CONSTRAINT "process_map_test_runs_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'running'::"text", 'completed'::"text", 'failed'::"text", 'cancelled'::"text"])))
);

-- ALTER TABLE "public"."process_map_test_runs" OWNER TO "postgres";

COMMENT ON TABLE "public"."process_map_test_runs" IS 'Records of test executions with configuration and aggregate results';

CREATE TABLE IF NOT EXISTS "public"."process_map_test_scenarios" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid",
    "process_map_id" "uuid",
    "org_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "scenario_type" "text" NOT NULL,
    "path" "jsonb" NOT NULL,
    "mock_overrides" "jsonb" DEFAULT '[]'::"jsonb",
    "expected_result" "text" NOT NULL,
    "expected_failure_step" "text",
    "expected_failure_type" "text",
    "priority" integer DEFAULT 1,
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "last_run_result" "jsonb",
    "version" integer DEFAULT 1,
    "process_structure_hash" "text",
    "generated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "process_map_test_scenarios_expected_failure_type_check" CHECK ((("expected_failure_type" IS NULL) OR ("expected_failure_type" = ANY (ARRAY['error'::"text", 'timeout'::"text", 'rate_limit'::"text", 'auth_failure'::"text"])))),
    CONSTRAINT "process_map_test_scenarios_expected_result_check" CHECK (("expected_result" = ANY (ARRAY['pass'::"text", 'fail'::"text"]))),
    CONSTRAINT "process_map_test_scenarios_scenario_type_check" CHECK (("scenario_type" = ANY (ARRAY['happy_path'::"text", 'branch_path'::"text", 'failure_mode'::"text"])))
);

-- ALTER TABLE "public"."process_map_test_scenarios" OWNER TO "postgres";

COMMENT ON TABLE "public"."process_map_test_scenarios" IS 'Auto-generated test scenarios for process map workflows';

COMMENT ON COLUMN "public"."process_map_test_scenarios"."scenario_type" IS 'Type: happy_path (main flow), branch_path (alternative route), failure_mode (error simulation)';

COMMENT ON COLUMN "public"."process_map_test_scenarios"."path" IS 'JSONB containing stepIds array, decisions, totalSteps, and pathHash';

COMMENT ON COLUMN "public"."process_map_test_scenarios"."mock_overrides" IS 'Array of mock configurations to apply for this scenario';

COMMENT ON COLUMN "public"."process_map_test_scenarios"."process_structure_hash" IS 'Hash of ProcessStructure to detect when scenarios need regeneration';

CREATE TABLE IF NOT EXISTS "public"."process_map_workflows" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "process_map_id" "uuid",
    "org_id" "uuid" NOT NULL,
    "steps" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "connections" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "test_config" "jsonb" DEFAULT '{}'::"jsonb",
    "mock_config" "jsonb" DEFAULT '{}'::"jsonb",
    "version" integer DEFAULT 1,
    "is_active" boolean DEFAULT true,
    "parsed_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

-- ALTER TABLE "public"."process_map_workflows" OWNER TO "postgres";

COMMENT ON TABLE "public"."process_map_workflows" IS 'Parsed executable workflow definitions from process maps';

CREATE TABLE IF NOT EXISTS "public"."process_maps" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "process_type" "text" NOT NULL,
    "process_name" "text" NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "mermaid_code" "text" NOT NULL,
    "generated_by" "uuid",
    "version" integer DEFAULT 1 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "mermaid_code_horizontal" "text",
    "mermaid_code_vertical" "text",
    "generation_status" "text" DEFAULT 'complete'::"text",
    "process_structure" "jsonb",
    "description_long" "text"
);

-- ALTER TABLE "public"."process_maps" OWNER TO "postgres";

COMMENT ON TABLE "public"."process_maps" IS 'Stores AI-generated Mermaid process visualization charts for integrations and workflows. Platform admin access only.';

COMMENT ON COLUMN "public"."process_maps"."mermaid_code_horizontal" IS 'Mermaid code with LR (left-right) flow direction for card thumbnails';

COMMENT ON COLUMN "public"."process_maps"."mermaid_code_vertical" IS 'Mermaid code with TB (top-bottom) flow direction for modal/detail view';

COMMENT ON COLUMN "public"."process_maps"."generation_status" IS 'Status of generation: pending, partial (one view ready), complete (both views ready)';

COMMENT ON COLUMN "public"."process_maps"."process_structure" IS 'Structured JSON representation of the process (nodes, connections, subgraphs). Generated by Claude Opus, used as source of truth for Mermaid rendering and testing system.';

COMMENT ON COLUMN "public"."process_maps"."description_long" IS 'Extended description with full workflow details, shown via View More expansion. Supports markdown.';

CREATE TABLE IF NOT EXISTS "public"."proposal_templates" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "type" "text" NOT NULL,
    "content" "text" NOT NULL,
    "is_default" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "user_id" "uuid",
    CONSTRAINT "proposal_templates_type_check" CHECK (("type" = ANY (ARRAY['goals'::"text", 'sow'::"text", 'proposal'::"text", 'design_system'::"text"])))
);

-- ALTER TABLE "public"."proposal_templates" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."proposals" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "meeting_id" "uuid",
    "contact_id" "uuid",
    "type" "text" NOT NULL,
    "status" "text" DEFAULT 'draft'::"text",
    "content" "text" NOT NULL,
    "title" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "user_id" "uuid",
    "share_token" "uuid" DEFAULT "gen_random_uuid"(),
    "password_hash" "text",
    "is_public" boolean DEFAULT false,
    "share_views" integer DEFAULT 0,
    "last_viewed_at" timestamp with time zone,
    CONSTRAINT "proposals_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'generated'::"text", 'approved'::"text", 'sent'::"text"]))),
    CONSTRAINT "proposals_type_check" CHECK (("type" = ANY (ARRAY['goals'::"text", 'sow'::"text", 'proposal'::"text"])))
);

-- ALTER TABLE "public"."proposals" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."rate_limit" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "endpoint" "text" NOT NULL,
    "ip_address" "text",
    "user_agent" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."rate_limit" OWNER TO "postgres";

CREATE OR REPLACE VIEW "public"."recent_notification_activity" WITH ("security_invoker"='true') AS
 SELECT "n"."id",
    "n"."user_id",
    "p"."email" AS "user_email",
    "n"."title",
    "n"."type",
    "n"."category",
    "n"."entity_type",
    "n"."entity_id",
    "n"."read",
    "n"."created_at",
    (EXTRACT(epoch FROM ("now"() - "n"."created_at")) / (3600)::numeric) AS "hours_ago",
    ( SELECT "count"(*) AS "count"
           FROM "public"."notifications" "n2"
          WHERE (("n2"."user_id" = "n"."user_id") AND (("n2"."type")::"text" = ("n"."type")::"text") AND (("n2"."created_at" >= ("n"."created_at" - '01:00:00'::interval)) AND ("n2"."created_at" <= "n"."created_at")))) AS "notifications_in_same_hour"
   FROM ("public"."notifications" "n"
     LEFT JOIN "public"."profiles" "p" ON (("p"."id" = "n"."user_id")))
  WHERE ("n"."created_at" > ("now"() - '24:00:00'::interval))
  ORDER BY "n"."created_at" DESC;

-- ALTER VIEW "public"."recent_notification_activity" OWNER TO "postgres";

COMMENT ON VIEW "public"."recent_notification_activity" IS 'Shows detailed notification activity from the last 24 hours.';

CREATE TABLE IF NOT EXISTS "public"."recording_rules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "name" "text" NOT NULL,
    "is_active" boolean DEFAULT true,
    "priority" integer DEFAULT 0,
    "domain_mode" "text" DEFAULT 'external_only'::"text",
    "specific_domains" "text"[],
    "internal_domain" "text",
    "min_attendee_count" integer DEFAULT 2,
    "max_attendee_count" integer,
    "title_keywords" "text"[],
    "title_keywords_exclude" "text"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "recording_rules_domain_mode_check" CHECK (("domain_mode" = ANY (ARRAY['external_only'::"text", 'internal_only'::"text", 'specific_domains'::"text", 'all'::"text"])))
);

-- ALTER TABLE "public"."recording_rules" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."recordings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "meeting_platform" "text" NOT NULL,
    "meeting_url" "text" NOT NULL,
    "meeting_title" "text",
    "meeting_start_time" timestamp with time zone,
    "meeting_end_time" timestamp with time zone,
    "meeting_duration_seconds" integer,
    "calendar_event_id" "uuid",
    "bot_id" "text",
    "meetingbaas_recording_id" "text",
    "recording_s3_key" "text",
    "recording_s3_url" "text",
    "transcript_s3_key" "text",
    "transcript_json" "jsonb",
    "transcript_text" "text",
    "summary" "text",
    "highlights" "jsonb",
    "action_items" "jsonb",
    "speakers" "jsonb",
    "speaker_identification_method" "text",
    "crm_contacts" "jsonb",
    "crm_deal_id" "uuid",
    "crm_activity_id" "uuid",
    "hitl_required" boolean DEFAULT false,
    "hitl_type" "text",
    "hitl_data" "jsonb",
    "hitl_resolved_at" timestamp with time zone,
    "hitl_resolved_by" "uuid",
    "status" "text" DEFAULT 'pending'::"text",
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "crm_synced" boolean DEFAULT false,
    "hubspot_engagement_id" "text",
    CONSTRAINT "recordings_meeting_platform_check" CHECK (("meeting_platform" = ANY (ARRAY['zoom'::"text", 'google_meet'::"text", 'microsoft_teams'::"text"]))),
    CONSTRAINT "recordings_speaker_identification_method_check" CHECK (("speaker_identification_method" = ANY (ARRAY['email_match'::"text", 'ai_inference'::"text", 'manual'::"text", 'unknown'::"text"]))),
    CONSTRAINT "recordings_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'bot_joining'::"text", 'recording'::"text", 'processing'::"text", 'ready'::"text", 'failed'::"text"])))
);

-- ALTER TABLE "public"."recordings" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."reengagement_log" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "segment_at_send" "text" NOT NULL,
    "reengagement_type" "text" NOT NULL,
    "channel" "text" NOT NULL,
    "trigger_type" "text",
    "trigger_entity_type" "text",
    "trigger_entity_id" "uuid",
    "trigger_context" "jsonb",
    "sent_at" timestamp with time zone DEFAULT "now"(),
    "delivered" boolean DEFAULT false,
    "delivered_at" timestamp with time zone,
    "opened_at" timestamp with time zone,
    "clicked_at" timestamp with time zone,
    "action_taken" "text",
    "returned_to_app" boolean DEFAULT false,
    "returned_at" timestamp with time zone,
    "outcome" "text",
    "new_segment_after" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."reengagement_log" OWNER TO "postgres";

COMMENT ON TABLE "public"."reengagement_log" IS 'Log of all re-engagement attempts and their outcomes';

-- ALTER TABLE "public"."relationship_health_history" OWNER TO "postgres";

COMMENT ON TABLE "public"."relationship_health_history" IS 'Historical snapshots of relationship health scores for trend analysis';

COMMENT ON COLUMN "public"."relationship_health_history"."snapshot_reason" IS 'Why this snapshot was created (scheduled, major change, intervention, etc.)';

COMMENT ON COLUMN "public"."relationship_health_history"."changes_from_previous" IS 'JSONB containing deltas and changes from previous snapshot';

-- ALTER TABLE "public"."relationship_health_scores" OWNER TO "postgres";

COMMENT ON TABLE "public"."relationship_health_scores" IS 'Tracks health scores for relationships (contacts/companies) with ghost detection';

COMMENT ON COLUMN "public"."relationship_health_scores"."ghost_signals" IS 'JSONB array of detected ghost signals with severity and context';

COMMENT ON COLUMN "public"."relationship_health_scores"."last_meaningful_interaction" IS 'JSONB object containing details of the last significant interaction';

-- ALTER TABLE "public"."roadmap_comments" OWNER TO "postgres";

-- ALTER TABLE "public"."roadmap_suggestions" OWNER TO "postgres";

COMMENT ON COLUMN "public"."roadmap_suggestions"."hub_task_id" IS 'Reference to the task ID in ai-dev-hub system';

COMMENT ON COLUMN "public"."roadmap_suggestions"."hub_task_code" IS 'Human-readable task code from ai-dev-hub (e.g., TSK-0042)';

COMMENT ON COLUMN "public"."roadmap_suggestions"."hub_sync_status" IS 'Synchronization status: pending, synced, failed, not_synced';

COMMENT ON COLUMN "public"."roadmap_suggestions"."hub_sync_error" IS 'Error message if synchronization failed';

COMMENT ON COLUMN "public"."roadmap_suggestions"."hub_last_sync_at" IS 'Timestamp of last synchronization attempt';

CREATE SEQUENCE IF NOT EXISTS "public"."roadmap_suggestions_ticket_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;

-- ALTER SEQUENCE "public"."roadmap_suggestions_ticket_id_seq" OWNER TO "postgres";

ALTER SEQUENCE "public"."roadmap_suggestions_ticket_id_seq" OWNED BY "public"."roadmap_suggestions"."ticket_id";

-- ALTER TABLE "public"."roadmap_votes" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."savvycal_integration_secrets" (
    "integration_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "api_token" "text",
    "webhook_secret" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "api_public_key" "text",
    "api_private_key" "text"
);

-- ALTER TABLE "public"."savvycal_integration_secrets" OWNER TO "postgres";

COMMENT ON TABLE "public"."savvycal_integration_secrets" IS 'Org-scoped SavvyCal credentials (admin-only). Stores Personal Access Token.';

COMMENT ON COLUMN "public"."savvycal_integration_secrets"."api_token" IS 'Legacy: single token field (deprecated, use api_public_key/api_private_key).';

COMMENT ON COLUMN "public"."savvycal_integration_secrets"."webhook_secret" IS 'Optional secret for HMAC signature verification of webhooks.';

COMMENT ON COLUMN "public"."savvycal_integration_secrets"."api_public_key" IS 'SavvyCal Public Key (pk_...).';

COMMENT ON COLUMN "public"."savvycal_integration_secrets"."api_private_key" IS 'SavvyCal Private Key (sk_...).';

CREATE TABLE IF NOT EXISTS "public"."savvycal_integrations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "connected_by_user_id" "uuid",
    "is_active" boolean DEFAULT true NOT NULL,
    "webhook_token" "text" NOT NULL,
    "webhook_configured_at" timestamp with time zone,
    "webhook_last_received_at" timestamp with time zone,
    "webhook_last_event_id" "text",
    "last_sync_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."savvycal_integrations" OWNER TO "postgres";

COMMENT ON TABLE "public"."savvycal_integrations" IS 'Org-scoped SavvyCal integration metadata (non-sensitive). Stores webhook token for per-org routing.';

COMMENT ON COLUMN "public"."savvycal_integrations"."webhook_token" IS 'Unique token used in webhook URL for org identification.';

COMMENT ON COLUMN "public"."savvycal_integrations"."webhook_configured_at" IS 'Timestamp when webhook was verified as configured in SavvyCal.';

COMMENT ON COLUMN "public"."savvycal_integrations"."webhook_last_received_at" IS 'Timestamp of last successful webhook received from SavvyCal.';

CREATE TABLE IF NOT EXISTS "public"."savvycal_link_mappings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "link_id" "text" NOT NULL,
    "source_name" "text" NOT NULL,
    "channel" "text" DEFAULT 'direct'::"text" NOT NULL,
    "medium" "text",
    "description" "text",
    "default_owner_email" "text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."savvycal_link_mappings" OWNER TO "postgres";

COMMENT ON TABLE "public"."savvycal_link_mappings" IS 'Maps SavvyCal scheduling link IDs to human-readable source names and channels';

COMMENT ON COLUMN "public"."savvycal_link_mappings"."link_id" IS 'SavvyCal link identifier (e.g., link_01JBH7K597B546RDY6VW39RFCK)';

COMMENT ON COLUMN "public"."savvycal_link_mappings"."source_name" IS 'Human-readable source name for display';

COMMENT ON COLUMN "public"."savvycal_link_mappings"."channel" IS 'Marketing channel (paid_social, direct, organic, email, etc.)';

COMMENT ON COLUMN "public"."savvycal_link_mappings"."medium" IS 'UTM medium equivalent (linkedin, meta, calendaring, etc.)';

CREATE TABLE IF NOT EXISTS "public"."savvycal_source_mappings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "link_id" "text" NOT NULL,
    "source" "text" NOT NULL,
    "notes" "text",
    "created_by" "uuid",
    "org_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "source_id" "uuid",
    "private_link" "text",
    "meeting_link" "text"
);

-- ALTER TABLE "public"."savvycal_source_mappings" OWNER TO "postgres";

COMMENT ON TABLE "public"."savvycal_source_mappings" IS 'Maps SavvyCal booking link IDs to lead sources for conversion tracking';

COMMENT ON COLUMN "public"."savvycal_source_mappings"."link_id" IS 'SavvyCal booking link ID (from CSV link_id column)';

COMMENT ON COLUMN "public"."savvycal_source_mappings"."source" IS 'Source name (can be custom or match booking_sources.name)';

COMMENT ON COLUMN "public"."savvycal_source_mappings"."source_id" IS 'Optional reference to predefined booking source';

COMMENT ON COLUMN "public"."savvycal_source_mappings"."private_link" IS 'SavvyCal private link name (often contains source information)';

COMMENT ON COLUMN "public"."savvycal_source_mappings"."meeting_link" IS 'SavvyCal meeting link slug (e.g., /bookdemo, /demo, /chatwithus)';

CREATE TABLE IF NOT EXISTS "public"."scenario_fixtures" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid" NOT NULL,
    "scenario_name" "text" NOT NULL,
    "description" "text",
    "difficulty" "text",
    "tags" "text"[],
    "trigger_data" "jsonb" DEFAULT '{}'::"jsonb",
    "expected_outputs" "jsonb" DEFAULT '{}'::"jsonb",
    "node_fixtures" "jsonb" DEFAULT '[]'::"jsonb",
    "validation_rules" "jsonb" DEFAULT '[]'::"jsonb",
    "is_baseline" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "scenario_fixtures_difficulty_check" CHECK (("difficulty" = ANY (ARRAY['easy'::"text", 'medium'::"text", 'hard'::"text"])))
);

-- ALTER TABLE "public"."scenario_fixtures" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."sentiment_alerts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "meeting_id" "uuid",
    "contact_id" "uuid",
    "alert_type" "text" NOT NULL,
    "severity" "text" NOT NULL,
    "sentiment_score" numeric,
    "message" "text" NOT NULL,
    "is_read" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "sentiment_alerts_alert_type_check" CHECK (("alert_type" = ANY (ARRAY['negative_meeting'::"text", 'declining_trend'::"text", 'at_risk'::"text"]))),
    CONSTRAINT "sentiment_alerts_sentiment_score_check" CHECK ((("sentiment_score" >= ('-1'::integer)::numeric) AND ("sentiment_score" <= (1)::numeric))),
    CONSTRAINT "sentiment_alerts_severity_check" CHECK (("severity" = ANY (ARRAY['info'::"text", 'warning'::"text", 'critical'::"text"])))
);

-- ALTER TABLE "public"."sentiment_alerts" OWNER TO "postgres";

COMMENT ON TABLE "public"."sentiment_alerts" IS 'Alerts for negative sentiment patterns in meetings';

CREATE TABLE IF NOT EXISTS "public"."sentry_bridge_config" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "enabled" boolean DEFAULT false NOT NULL,
    "sentry_org_slug" "text",
    "sentry_project_slugs" "text"[],
    "default_priority" "text" DEFAULT 'medium'::"text",
    "triage_mode_enabled" boolean DEFAULT true NOT NULL,
    "max_tickets_per_hour" integer DEFAULT 50,
    "max_tickets_per_day" integer DEFAULT 200,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "default_dev_hub_project_id" "text"
);

-- ALTER TABLE "public"."sentry_bridge_config" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."sentry_bridge_metrics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "bucket_start" timestamp with time zone NOT NULL,
    "bucket_end" timestamp with time zone NOT NULL,
    "webhooks_received" integer DEFAULT 0 NOT NULL,
    "webhooks_processed" integer DEFAULT 0 NOT NULL,
    "webhooks_failed" integer DEFAULT 0 NOT NULL,
    "webhooks_skipped" integer DEFAULT 0 NOT NULL,
    "tickets_created" integer DEFAULT 0 NOT NULL,
    "tickets_updated" integer DEFAULT 0 NOT NULL,
    "tickets_triaged" integer DEFAULT 0 NOT NULL,
    "dlq_items" integer DEFAULT 0 NOT NULL,
    "avg_processing_time_ms" integer,
    "max_processing_time_ms" integer,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

-- ALTER TABLE "public"."sentry_bridge_metrics" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."sentry_dead_letter_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "original_queue_id" "uuid" NOT NULL,
    "queue_type" "text" NOT NULL,
    "webhook_event_id" "uuid" NOT NULL,
    "sentry_issue_id" "text" NOT NULL,
    "event_type" "text" NOT NULL,
    "original_payload" "jsonb" NOT NULL,
    "failure_reason" "text" NOT NULL,
    "attempt_count" integer NOT NULL,
    "last_error_details" "jsonb",
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "resolved_by" "uuid",
    "resolved_at" timestamp with time zone,
    "resolution_notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "sentry_dead_letter_queue_queue_type_check" CHECK (("queue_type" = ANY (ARRAY['bridge'::"text", 'triage'::"text"]))),
    CONSTRAINT "sentry_dead_letter_queue_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'replayed'::"text", 'discarded'::"text"])))
);

-- ALTER TABLE "public"."sentry_dead_letter_queue" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."sentry_issue_mappings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "sentry_issue_id" "text" NOT NULL,
    "sentry_project_slug" "text" NOT NULL,
    "dev_hub_task_id" "text" NOT NULL,
    "dev_hub_project_id" "text" NOT NULL,
    "error_hash" "text",
    "sentry_status" "text" DEFAULT 'unresolved'::"text" NOT NULL,
    "dev_hub_status" "text",
    "latest_sentry_event_id" "text",
    "first_seen" timestamp with time zone DEFAULT "now"() NOT NULL,
    "last_seen" timestamp with time zone DEFAULT "now"() NOT NULL,
    "event_count" integer DEFAULT 1 NOT NULL,
    "first_release" "text",
    "latest_release" "text",
    "sentry_external_issue_id" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

-- ALTER TABLE "public"."sentry_issue_mappings" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."sentry_routing_rules" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "config_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "priority" integer DEFAULT 100 NOT NULL,
    "enabled" boolean DEFAULT true NOT NULL,
    "test_mode" boolean DEFAULT false NOT NULL,
    "match_sentry_project" "text",
    "match_error_type" "text",
    "match_error_message" "text",
    "match_culprit" "text",
    "match_tags" "jsonb",
    "match_environment" "text",
    "match_release_pattern" "text",
    "target_dev_hub_project_id" "text" NOT NULL,
    "target_owner_user_id" "uuid",
    "target_priority" "text" DEFAULT 'medium'::"text",
    "attach_runbook_urls" "text"[],
    "additional_labels" "text"[],
    "notify_slack_channel" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "sentry_routing_rules_target_priority_check" CHECK (("target_priority" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'urgent'::"text"])))
);

-- ALTER TABLE "public"."sentry_routing_rules" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."sentry_triage_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "webhook_event_id" "uuid" NOT NULL,
    "sentry_issue_id" "text" NOT NULL,
    "sentry_project_slug" "text" NOT NULL,
    "error_title" "text" NOT NULL,
    "error_type" "text",
    "error_message" "text",
    "culprit" "text",
    "environment" "text",
    "release_version" "text",
    "event_count" integer DEFAULT 1,
    "first_seen" timestamp with time zone,
    "suggested_dev_hub_project_id" "text",
    "suggested_owner_user_id" "uuid",
    "suggested_priority" "text",
    "matched_rule_id" "uuid",
    "ticket_payload" "jsonb" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "triaged_by" "uuid",
    "triaged_at" timestamp with time zone,
    "rejection_reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "sentry_triage_queue_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'rejected'::"text", 'auto_approved'::"text"])))
);

-- ALTER TABLE "public"."sentry_triage_queue" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."sentry_webhook_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "sentry_event_id" "text" NOT NULL,
    "sentry_issue_id" "text",
    "event_type" "text" NOT NULL,
    "raw_payload" "jsonb" NOT NULL,
    "status" "text" DEFAULT 'received'::"text" NOT NULL,
    "error_message" "text",
    "processed_at" timestamp with time zone,
    "event_dedupe_key" "text" GENERATED ALWAYS AS (((("org_id")::"text" || ':'::"text") || "sentry_event_id")) STORED,
    "received_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "sentry_webhook_events_status_check" CHECK (("status" = ANY (ARRAY['received'::"text", 'processing'::"text", 'processed'::"text", 'failed'::"text", 'skipped'::"text"])))
);

-- ALTER TABLE "public"."sentry_webhook_events" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."sentry_webhook_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "event_type" "text" NOT NULL,
    "sentry_issue_id" "text" NOT NULL,
    "sentry_project_slug" "text",
    "payload" "jsonb" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "priority" integer DEFAULT 100 NOT NULL,
    "error_message" "text",
    "retry_count" integer DEFAULT 0 NOT NULL,
    "max_retries" integer DEFAULT 3 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "processed_at" timestamp with time zone,
    "next_retry_at" timestamp with time zone
);

-- ALTER TABLE "public"."sentry_webhook_queue" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."sequence_executions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "sequence_key" "text" NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "input_context" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "step_results" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "final_output" "jsonb",
    "error_message" "text",
    "failed_step_index" integer,
    "is_simulation" boolean DEFAULT false NOT NULL,
    "mock_data_used" "jsonb",
    "started_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "waiting_for_hitl" boolean DEFAULT false,
    "current_hitl_request_id" "uuid",
    CONSTRAINT "sequence_executions_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'running'::"text", 'completed'::"text", 'failed'::"text", 'cancelled'::"text", 'waiting_hitl'::"text"])))
);

-- ALTER TABLE "public"."sequence_executions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."sequence_hitl_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "execution_id" "text" NOT NULL,
    "sequence_key" "text" NOT NULL,
    "step_index" integer NOT NULL,
    "timing" "text" NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "requested_by_user_id" "uuid" NOT NULL,
    "assigned_to_user_id" "uuid",
    "request_type" "text" NOT NULL,
    "prompt" "text" NOT NULL,
    "options" "jsonb" DEFAULT '[]'::"jsonb",
    "default_value" "text",
    "channels" "jsonb" DEFAULT '["in_app"]'::"jsonb" NOT NULL,
    "slack_channel_id" "text",
    "slack_message_ts" "text",
    "timeout_minutes" integer DEFAULT 60 NOT NULL,
    "timeout_action" "text" DEFAULT 'fail'::"text" NOT NULL,
    "expires_at" timestamp with time zone,
    "execution_context" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "response_value" "text",
    "response_context" "jsonb" DEFAULT '{}'::"jsonb",
    "responded_by_user_id" "uuid",
    "responded_at" timestamp with time zone,
    "response_channel" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "sequence_hitl_requests_request_type_check" CHECK (("request_type" = ANY (ARRAY['confirmation'::"text", 'question'::"text", 'choice'::"text", 'input'::"text"]))),
    CONSTRAINT "sequence_hitl_requests_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'responded'::"text", 'expired'::"text", 'cancelled'::"text"]))),
    CONSTRAINT "sequence_hitl_requests_timeout_action_check" CHECK (("timeout_action" = ANY (ARRAY['fail'::"text", 'continue'::"text", 'use_default'::"text"]))),
    CONSTRAINT "sequence_hitl_requests_timing_check" CHECK (("timing" = ANY (ARRAY['before'::"text", 'after'::"text"])))
);

-- ALTER TABLE "public"."sequence_hitl_requests" OWNER TO "postgres";

COMMENT ON TABLE "public"."sequence_hitl_requests" IS 'Tracks Human-in-the-Loop approval requests during sequence execution. Supports pausing sequences for human review and approval.';

CREATE TABLE IF NOT EXISTS "public"."sequence_references_archive" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "sequence_instance_id" "text" NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "reference_type" "text" NOT NULL,
    "location" "text" NOT NULL,
    "summary" "text",
    "size_bytes" integer,
    "archived_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "sequence_references_archive_reference_type_check" CHECK (("reference_type" = ANY (ARRAY['transcript'::"text", 'enrichment'::"text", 'draft'::"text", 'analysis'::"text", 'raw_response'::"text", 'image'::"text", 'document'::"text"])))
);

-- ALTER TABLE "public"."sequence_references_archive" OWNER TO "postgres";

COMMENT ON TABLE "public"."sequence_references_archive" IS 'Archives references that have been compacted out of active sequence state. Allows retrieval of historical data without bloating active context.';

CREATE TABLE IF NOT EXISTS "public"."sequence_token_budgets" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "sequence_instance_id" "text" NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "system_prompt_tokens" integer DEFAULT 0 NOT NULL,
    "state_tokens" integer DEFAULT 0 NOT NULL,
    "skill_result_tokens" integer DEFAULT 0 NOT NULL,
    "total_used" integer DEFAULT 0 NOT NULL,
    "per_step_ceiling" integer DEFAULT 3800 NOT NULL,
    "over_budget" boolean DEFAULT false NOT NULL,
    "warnings" "jsonb" DEFAULT '[]'::"jsonb",
    "step_breakdown" "jsonb" DEFAULT '[]'::"jsonb",
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

-- ALTER TABLE "public"."sequence_token_budgets" OWNER TO "postgres";

COMMENT ON TABLE "public"."sequence_token_budgets" IS 'Tracks token usage per sequence execution. Implements Context Engineering token budget guidelines to keep sequences efficient.';

CREATE TABLE IF NOT EXISTS "public"."skill_output_storage" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "organization_id" "uuid" NOT NULL,
    "path" "text" NOT NULL,
    "content_type" "text" DEFAULT 'raw_response'::"text" NOT NULL,
    "data" "jsonb" NOT NULL,
    "size_bytes" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "expires_at" timestamp with time zone,
    CONSTRAINT "skill_output_storage_content_type_check" CHECK (("content_type" = ANY (ARRAY['transcript'::"text", 'enrichment'::"text", 'draft'::"text", 'analysis'::"text", 'raw_response'::"text", 'image'::"text", 'document'::"text"])))
);

-- ALTER TABLE "public"."skill_output_storage" OWNER TO "postgres";

COMMENT ON TABLE "public"."skill_output_storage" IS 'Stores full skill outputs for reference. Implements the Context Engineering compaction principle: store full data externally, pass references in context.';

CREATE TABLE IF NOT EXISTS "public"."slack_channels" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "integration_id" "uuid" NOT NULL,
    "channel_id" "text" NOT NULL,
    "channel_name" "text" NOT NULL,
    "is_private" boolean DEFAULT false,
    "is_member" boolean DEFAULT true,
    "is_archived" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."slack_channels" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."slack_deal_rooms" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid",
    "deal_id" "uuid",
    "slack_channel_id" "text" NOT NULL,
    "slack_channel_name" "text" NOT NULL,
    "is_archived" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "archived_at" timestamp with time zone,
    "invited_slack_user_ids" "text"[]
);

-- ALTER TABLE "public"."slack_deal_rooms" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."slack_integrations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "team_id" "text" NOT NULL,
    "team_name" "text" NOT NULL,
    "access_token" "text" NOT NULL,
    "bot_user_id" "text" NOT NULL,
    "app_id" "text" NOT NULL,
    "authed_user" "jsonb",
    "scope" "text" NOT NULL,
    "token_type" "text" DEFAULT 'bot'::"text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."slack_integrations" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."slack_notification_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid",
    "feature" "text" NOT NULL,
    "is_enabled" boolean DEFAULT true,
    "delivery_method" "text" DEFAULT 'channel'::"text",
    "channel_id" "text",
    "channel_name" "text",
    "schedule_time" time without time zone,
    "schedule_timezone" "text" DEFAULT 'UTC'::"text",
    "deal_value_threshold" numeric,
    "deal_stage_trigger" "text",
    "stakeholder_slack_ids" "text"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "deal_stage_threshold" "text" DEFAULT 'opportunity'::"text",
    "dm_audience" "text" DEFAULT 'owner'::"text",
    "thresholds" "jsonb" DEFAULT '{}'::"jsonb",
    "schedule" "text",
    "target_channel_id" "text",
    CONSTRAINT "slack_notification_settings_dm_audience_chk" CHECK ((("dm_audience" IS NULL) OR ("dm_audience" = ANY (ARRAY['owner'::"text", 'stakeholders'::"text", 'both'::"text"]))))
);

-- ALTER TABLE "public"."slack_notification_settings" OWNER TO "postgres";

COMMENT ON COLUMN "public"."slack_notification_settings"."dm_audience" IS 'When delivery_method includes DM (meeting debriefs), controls who receives DMs: owner, stakeholders, or both.';

CREATE TABLE IF NOT EXISTS "public"."slack_notifications_sent" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid",
    "feature" "text" NOT NULL,
    "entity_type" "text",
    "entity_id" "uuid",
    "recipient_type" "text",
    "recipient_id" "text",
    "slack_ts" "text",
    "slack_channel_id" "text",
    "sent_at" timestamp with time zone DEFAULT "now"(),
    "dedupe_key" "text",
    "slack_message_ts" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "entity_key" "text"
);

-- ALTER TABLE "public"."slack_notifications_sent" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."slack_org_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid",
    "slack_team_id" "text",
    "slack_team_name" "text",
    "bot_access_token" "text",
    "bot_user_id" "text",
    "is_connected" boolean DEFAULT false,
    "connected_at" timestamp with time zone,
    "connected_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."slack_org_settings" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."slack_user_mappings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid",
    "slack_user_id" "text" NOT NULL,
    "slack_username" "text",
    "slack_display_name" "text",
    "slack_email" "text",
    "slack_avatar_url" "text",
    "sixty_user_id" "uuid",
    "is_auto_matched" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."slack_user_mappings" OWNER TO "postgres";

-- ALTER TABLE "public"."smart_task_templates" OWNER TO "postgres";

-- ALTER TABLE "public"."solutions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."stages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "position" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."stages" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."subscription_seat_usage" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "subscription_id" "uuid",
    "org_id" "uuid" NOT NULL,
    "period_start" timestamp with time zone NOT NULL,
    "period_end" timestamp with time zone NOT NULL,
    "active_seats" integer DEFAULT 0 NOT NULL,
    "included_seats" integer DEFAULT 1 NOT NULL,
    "overage_seats" integer GENERATED ALWAYS AS (GREATEST(0, ("active_seats" - "included_seats"))) STORED,
    "overage_amount_cents" integer DEFAULT 0,
    "stripe_usage_record_id" "text",
    "billed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."subscription_seat_usage" OWNER TO "postgres";

COMMENT ON TABLE "public"."subscription_seat_usage" IS 'Tracks per-seat overage for Team tier billing';

CREATE TABLE IF NOT EXISTS "public"."system_config" (
    "key" "text" NOT NULL,
    "value" "text" NOT NULL,
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."system_config" OWNER TO "postgres";

COMMENT ON TABLE "public"."system_config" IS 'Application-wide configuration settings';

CREATE TABLE IF NOT EXISTS "public"."targets" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "team_id" "uuid",
    "revenue_target" numeric(12,2) NOT NULL,
    "outbound_target" integer NOT NULL,
    "meetings_target" integer NOT NULL,
    "proposal_target" integer NOT NULL,
    "start_date" "date" NOT NULL,
    "end_date" "date" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid",
    "closed_by" "uuid",
    "previous_target_id" "uuid",
    CONSTRAINT "targets_check" CHECK ((("user_id" IS NOT NULL) OR ("team_id" IS NOT NULL))),
    CONSTRAINT "targets_check1" CHECK (("start_date" <= "end_date"))
);

-- ALTER TABLE "public"."targets" OWNER TO "postgres";

COMMENT ON COLUMN "public"."targets"."created_by" IS 'ID of the admin user who created this specific target record/version. Should ideally be NOT NULL, consider backfilling for existing records if necessary.';

COMMENT ON COLUMN "public"."targets"."closed_by" IS 'ID of the admin user who ended the validity of this target record (set the end_date). NULL if the record is still active or was never closed.';

COMMENT ON COLUMN "public"."targets"."previous_target_id" IS 'ID of the target record that this record version supersedes (due to modification). NULL for the first target in a chain.';

-- ALTER TABLE "public"."task_notifications" OWNER TO "postgres";

COMMENT ON TABLE "public"."task_notifications" IS 'Stores notifications for task creation and AI suggestions';

CREATE TABLE IF NOT EXISTS "public"."tasks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" "text" NOT NULL,
    "description" "text",
    "notes" "text",
    "due_date" timestamp with time zone,
    "completed" boolean DEFAULT false,
    "completed_at" timestamp with time zone,
    "priority" "text" DEFAULT 'medium'::"text",
    "status" "text" DEFAULT 'pending'::"text",
    "task_type" "text" DEFAULT 'general'::"text",
    "assigned_to" "uuid" NOT NULL,
    "created_by" "uuid" NOT NULL,
    "deal_id" "uuid",
    "company_id" "uuid",
    "contact_id" "uuid",
    "contact_email" "text",
    "contact_name" "text",
    "company" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "owner_id" "uuid",
    "type" "text" DEFAULT 'follow_up'::"text",
    "google_task_id" "text",
    "google_list_id" "text",
    "sync_status" "text" DEFAULT 'pending_sync'::"text",
    "last_synced_at" timestamp with time zone,
    "google_position" "text",
    "google_etag" "text",
    "synced_to_lists" "jsonb" DEFAULT '[]'::"jsonb",
    "primary_google_list_id" "text",
    "parent_task_id" "uuid",
    "meeting_id" "uuid",
    "meeting_action_item_id" "uuid",
    "category" "text",
    "source" "text",
    "metadata" "jsonb",
    "clerk_org_id" "text",
    "importance" "text",
    "call_id" "uuid",
    "call_action_item_id" "uuid",
    "source_id" "uuid",
    CONSTRAINT "chk_tasks_max_depth" CHECK (("public"."get_task_depth"("id") <= 5)),
    CONSTRAINT "chk_tasks_no_self_reference" CHECK (("parent_task_id" <> "id")),
    CONSTRAINT "tasks_importance_check" CHECK (("importance" = ANY (ARRAY['high'::"text", 'medium'::"text", 'low'::"text"]))),
    CONSTRAINT "tasks_priority_check" CHECK (("priority" = ANY (ARRAY['low'::"text", 'medium'::"text", 'high'::"text", 'urgent'::"text"]))),
    CONSTRAINT "tasks_sync_status_check" CHECK (("sync_status" = ANY (ARRAY['local_only'::"text", 'synced'::"text", 'pending_sync'::"text", 'sync_error'::"text"]))),
    CONSTRAINT "tasks_task_type_check" CHECK (("task_type" = ANY (ARRAY['call'::"text", 'email'::"text", 'meeting'::"text", 'follow_up'::"text", 'proposal'::"text", 'demo'::"text", 'general'::"text"]))),
    CONSTRAINT "tasks_type_check" CHECK (("type" = ANY (ARRAY['call'::"text", 'email'::"text", 'meeting'::"text", 'follow_up'::"text", 'proposal'::"text", 'demo'::"text", 'general'::"text"])))
);

-- ALTER TABLE "public"."tasks" OWNER TO "postgres";

COMMENT ON COLUMN "public"."tasks"."parent_task_id" IS 'References parent task ID for subtasks. NULL for top-level tasks.';

COMMENT ON COLUMN "public"."tasks"."meeting_id" IS 'Direct reference to the associated meeting (if task was created from a meeting)';

COMMENT ON COLUMN "public"."tasks"."meeting_action_item_id" IS 'Link to source meeting action item for bidirectional sync';

COMMENT ON COLUMN "public"."tasks"."source" IS 'Origin of the task: fathom_action_item, manual, automated, etc.';

COMMENT ON COLUMN "public"."tasks"."metadata" IS 'Stores additional structured data: action_item_id (UUID), fathom_meeting_id (UUID), recording_timestamp (INTEGER), recording_playback_url (TEXT)';

COMMENT ON COLUMN "public"."tasks"."clerk_org_id" IS 'Clerk Organization ID for multi-tenant isolation';

COMMENT ON COLUMN "public"."tasks"."importance" IS 'Denormalized importance level from action item for efficient filtering';

COMMENT ON COLUMN "public"."tasks"."call_id" IS 'Direct reference to a call (JustCall etc.) associated with this task';

COMMENT ON COLUMN "public"."tasks"."call_action_item_id" IS 'Reference to a call action item that created this task (if applicable)';

COMMENT ON COLUMN "public"."tasks"."source_id" IS 'UUID of the source record (voice_recording.id, meeting.id, etc.)';

CREATE OR REPLACE VIEW "public"."team_meeting_analytics" WITH ("security_invoker"='true') AS
 SELECT "p"."id" AS "user_id",
    COALESCE(NULLIF(TRIM(BOTH FROM "concat"(COALESCE("p"."first_name", ''::"text"), ' ', COALESCE("p"."last_name", ''::"text"))), ''::"text"), "p"."email") AS "full_name",
    "p"."email",
    "om"."org_id",
    "count"("m"."id") AS "total_meetings",
    "avg"("m"."sentiment_score") AS "avg_sentiment",
    "avg"("m"."talk_time_rep_pct") AS "avg_talk_time",
    "avg"("m"."coach_rating") AS "avg_coach_rating",
    "count"(
        CASE
            WHEN ("m"."sentiment_score" > 0.2) THEN 1
            ELSE NULL::integer
        END) AS "positive_meetings",
    "count"(
        CASE
            WHEN ("m"."sentiment_score" < '-0.2'::numeric) THEN 1
            ELSE NULL::integer
        END) AS "negative_meetings",
    "sum"("m"."duration_minutes") AS "total_duration_minutes",
    "max"("m"."meeting_start") AS "last_meeting_date",
    "min"("m"."meeting_start") AS "first_meeting_date"
   FROM (("public"."profiles" "p"
     JOIN "public"."organization_memberships" "om" ON (("om"."user_id" = "p"."id")))
     LEFT JOIN "public"."meetings" "m" ON ((("m"."org_id" = "om"."org_id") AND (("m"."meeting_start" >= ("now"() - '30 days'::interval)) OR ("m"."meeting_start" IS NULL)))))
  GROUP BY "p"."id", "p"."first_name", "p"."last_name", "p"."email", "om"."org_id";

-- ALTER VIEW "public"."team_meeting_analytics" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."team_members" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "team_id" "uuid",
    "user_id" "uuid",
    "role" "public"."member_role" DEFAULT 'member'::"public"."member_role",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."team_members" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."teams" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."teams" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."topic_aggregation_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "meeting_id" "uuid" NOT NULL,
    "topic_index" integer NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "attempts" integer DEFAULT 0 NOT NULL,
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "processed_at" timestamp with time zone,
    CONSTRAINT "topic_aggregation_queue_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text"])))
);

-- ALTER TABLE "public"."topic_aggregation_queue" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."usage_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "event_type" "text" NOT NULL,
    "event_subtype" "text",
    "quantity" integer DEFAULT 1 NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."usage_events" OWNER TO "postgres";

COMMENT ON TABLE "public"."usage_events" IS 'Detailed usage event log for tracking';

CREATE TABLE IF NOT EXISTS "public"."user_activity_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "event_type" "text" NOT NULL,
    "event_source" "text" NOT NULL,
    "event_category" "text",
    "entity_type" "text",
    "entity_id" "uuid",
    "action_detail" "text",
    "event_at" timestamp with time zone DEFAULT "now"(),
    "day_of_week" integer,
    "hour_of_day" integer,
    "session_id" "uuid",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "user_activity_events_day_of_week_check" CHECK ((("day_of_week" >= 0) AND ("day_of_week" <= 6))),
    CONSTRAINT "user_activity_events_event_source_check" CHECK (("event_source" = ANY (ARRAY['app'::"text", 'slack'::"text", 'email'::"text"]))),
    CONSTRAINT "user_activity_events_hour_of_day_check" CHECK ((("hour_of_day" >= 0) AND ("hour_of_day" <= 23)))
);

-- ALTER TABLE "public"."user_activity_events" OWNER TO "postgres";

COMMENT ON TABLE "public"."user_activity_events" IS 'Raw event log of user activity across app, Slack, and email';

CREATE TABLE IF NOT EXISTS "public"."user_ai_feature_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "feature_key" "text" NOT NULL,
    "provider" "text" NOT NULL,
    "model" "text" NOT NULL,
    "temperature" numeric(3,2) DEFAULT 0.7,
    "max_tokens" integer DEFAULT 2048,
    "is_enabled" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "user_ai_feature_settings_max_tokens_check" CHECK (("max_tokens" > 0)),
    CONSTRAINT "user_ai_feature_settings_provider_check" CHECK (("provider" = ANY (ARRAY['openai'::"text", 'anthropic'::"text", 'openrouter'::"text", 'gemini'::"text"]))),
    CONSTRAINT "user_ai_feature_settings_temperature_check" CHECK ((("temperature" >= (0)::numeric) AND ("temperature" <= (2)::numeric)))
);

-- ALTER TABLE "public"."user_ai_feature_settings" OWNER TO "postgres";

COMMENT ON TABLE "public"."user_ai_feature_settings" IS 'User-specific AI model configuration per feature (task extraction, sentiment, proposals, etc.)';

CREATE TABLE IF NOT EXISTS "public"."user_ai_preferences" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "preferred_tone" "text",
    "preferred_length" "text",
    "prefers_ctas" boolean,
    "prefers_bullet_points" boolean,
    "auto_approve_threshold" integer DEFAULT 90,
    "always_hitl_actions" "text"[] DEFAULT ARRAY['send_email'::"text", 'send_slack_message'::"text"],
    "never_auto_send" boolean DEFAULT false,
    "notification_frequency" "text" DEFAULT 'moderate'::"text",
    "preferred_channels" "text"[] DEFAULT ARRAY['slack_dm'::"text"],
    "total_suggestions" integer DEFAULT 0,
    "approval_rate" numeric(5,4) DEFAULT 0,
    "edit_rate" numeric(5,4) DEFAULT 0,
    "rejection_rate" numeric(5,4) DEFAULT 0,
    "avg_time_to_decision_seconds" numeric(10,2) DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "user_ai_preferences_auto_approve_threshold_check" CHECK ((("auto_approve_threshold" >= 0) AND ("auto_approve_threshold" <= 100))),
    CONSTRAINT "user_ai_preferences_notification_frequency_check" CHECK (("notification_frequency" = ANY (ARRAY['high'::"text", 'moderate'::"text", 'low'::"text"]))),
    CONSTRAINT "user_ai_preferences_preferred_length_check" CHECK (("preferred_length" = ANY (ARRAY['concise'::"text", 'standard'::"text", 'detailed'::"text"]))),
    CONSTRAINT "user_ai_preferences_preferred_tone_check" CHECK (("preferred_tone" = ANY (ARRAY['formal'::"text", 'professional'::"text", 'casual'::"text", 'friendly'::"text"])))
);

-- ALTER TABLE "public"."user_ai_preferences" OWNER TO "postgres";

COMMENT ON TABLE "public"."user_ai_preferences" IS 'Stores user-specific AI preferences and learned behaviors from feedback';

COMMENT ON COLUMN "public"."user_ai_preferences"."approval_rate" IS 'Fraction of suggestions approved (0-1)';

CREATE TABLE IF NOT EXISTS "public"."user_coaching_preferences" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "coaching_framework" "text" DEFAULT 'Evaluate the sales representative''s performance across key areas: discovery, objection handling, value articulation, closing technique, and relationship building.'::"text" NOT NULL,
    "evaluation_criteria" "jsonb" DEFAULT '[{"area": "Discovery", "weight": 20, "description": "How well did the rep uncover customer needs and pain points?"}, {"area": "Listening", "weight": 20, "description": "Did the rep actively listen and respond appropriately?"}, {"area": "Value Articulation", "weight": 20, "description": "How clearly did the rep communicate value and differentiation?"}, {"area": "Objection Handling", "weight": 20, "description": "How effectively did the rep address concerns and objections?"}, {"area": "Next Steps", "weight": 20, "description": "Did the rep secure clear next steps and commitment?"}]'::"jsonb",
    "good_examples" "text" DEFAULT 'GOOD EXAMPLES:
- "Tell me more about your current process..." (open-ended discovery)
- "Based on what you shared, here''s how we can help..." (value alignment)
- "That''s a great concern. Here''s how we address that..." (confident objection handling)
- "Let''s get that demo scheduled for next Tuesday - does 2pm work?" (clear next step)'::"text",
    "bad_examples" "text" DEFAULT 'BAD EXAMPLES:
- Talking more than 70% of the time (poor listening)
- Pitching features before understanding needs (premature presentation)
- Avoiding or dismissing objections (defensive behavior)
- Ending without clear next steps or commitment (weak closing)'::"text",
    "rating_scale" "jsonb" DEFAULT '{"10": "Outstanding - Exceptional performance, best-in-class execution.", "1-3": "Poor - Significant improvement needed. Multiple areas performed below standard.", "4-5": "Below Average - Some good moments but key areas need work.", "6-7": "Good - Solid performance with a few areas to improve.", "8-9": "Excellent - Strong performance across most areas."}'::"jsonb",
    "focus_areas" "text"[] DEFAULT ARRAY['discovery'::"text", 'listening'::"text", 'value_articulation'::"text", 'objection_handling'::"text", 'closing'::"text", 'relationship_building'::"text"],
    "custom_instructions" "text" DEFAULT 'Focus on actionable feedback. Be specific about what was done well and what could be improved. Provide 2-3 concrete improvement suggestions.'::"text",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "good_example_meeting_ids" "uuid"[] DEFAULT ARRAY[]::"uuid"[],
    "bad_example_meeting_ids" "uuid"[] DEFAULT ARRAY[]::"uuid"[]
);

-- ALTER TABLE "public"."user_coaching_preferences" OWNER TO "postgres";

COMMENT ON TABLE "public"."user_coaching_preferences" IS 'User-defined coaching evaluation frameworks and criteria for AI analysis of sales calls';

COMMENT ON COLUMN "public"."user_coaching_preferences"."good_example_meeting_ids" IS 'Array of meeting IDs to use as reference examples of excellent sales technique. AI will analyze these calls and use them as benchmarks.';

COMMENT ON COLUMN "public"."user_coaching_preferences"."bad_example_meeting_ids" IS 'Array of meeting IDs to use as reference examples of techniques to avoid. AI will analyze these calls to identify anti-patterns.';

CREATE TABLE IF NOT EXISTS "public"."user_engagement_metrics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid" NOT NULL,
    "last_app_active_at" timestamp with time zone,
    "last_slack_active_at" timestamp with time zone,
    "last_notification_clicked_at" timestamp with time zone,
    "last_login_at" timestamp with time zone,
    "typical_active_hours" "jsonb" DEFAULT '{}'::"jsonb",
    "peak_activity_hour" integer,
    "avg_daily_sessions" numeric(5,2) DEFAULT 0,
    "avg_session_duration_minutes" integer DEFAULT 0,
    "app_engagement_score" integer DEFAULT 50,
    "slack_engagement_score" integer DEFAULT 50,
    "notification_engagement_score" integer DEFAULT 50,
    "overall_engagement_score" integer DEFAULT 50,
    "user_segment" "text" DEFAULT 'regular'::"text",
    "preferred_notification_frequency" "text" DEFAULT 'moderate'::"text",
    "notification_fatigue_level" integer DEFAULT 0,
    "last_feedback_requested_at" timestamp with time zone,
    "notifications_since_last_feedback" integer DEFAULT 0,
    "inferred_timezone" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "reengagement_attempts" integer DEFAULT 0,
    "last_reengagement_at" timestamp with time zone,
    "last_reengagement_type" "text",
    "reengagement_cooldown_until" timestamp with time zone,
    "previous_segment" "text",
    "segment_changed_at" timestamp with time zone,
    CONSTRAINT "user_engagement_metrics_app_engagement_score_check" CHECK ((("app_engagement_score" >= 0) AND ("app_engagement_score" <= 100))),
    CONSTRAINT "user_engagement_metrics_notification_engagement_score_check" CHECK ((("notification_engagement_score" >= 0) AND ("notification_engagement_score" <= 100))),
    CONSTRAINT "user_engagement_metrics_notification_fatigue_level_check" CHECK ((("notification_fatigue_level" >= 0) AND ("notification_fatigue_level" <= 100))),
    CONSTRAINT "user_engagement_metrics_overall_engagement_score_check" CHECK ((("overall_engagement_score" >= 0) AND ("overall_engagement_score" <= 100))),
    CONSTRAINT "user_engagement_metrics_preferred_notification_frequency_check" CHECK (("preferred_notification_frequency" = ANY (ARRAY['low'::"text", 'moderate'::"text", 'high'::"text"]))),
    CONSTRAINT "user_engagement_metrics_slack_engagement_score_check" CHECK ((("slack_engagement_score" >= 0) AND ("slack_engagement_score" <= 100))),
    CONSTRAINT "user_engagement_metrics_user_segment_check" CHECK (("user_segment" = ANY (ARRAY['power_user'::"text", 'regular'::"text", 'casual'::"text", 'at_risk'::"text", 'dormant'::"text", 'churned'::"text"])))
);

-- ALTER TABLE "public"."user_engagement_metrics" OWNER TO "postgres";

COMMENT ON TABLE "public"."user_engagement_metrics" IS 'Stores computed engagement scores and notification preferences for each user';

CREATE TABLE IF NOT EXISTS "public"."user_file_search_stores" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "store_name" "text" NOT NULL,
    "display_name" "text",
    "status" "text" DEFAULT 'active'::"text",
    "total_files" integer DEFAULT 0,
    "last_sync_at" timestamp with time zone,
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "user_file_search_stores_status_check" CHECK (("status" = ANY (ARRAY['active'::"text", 'syncing'::"text", 'error'::"text"])))
);

-- ALTER TABLE "public"."user_file_search_stores" OWNER TO "postgres";

COMMENT ON TABLE "public"."user_file_search_stores" IS 'Stores reference to each user''s Google File Search store for meeting RAG';

CREATE TABLE IF NOT EXISTS "public"."user_notifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "org_id" "uuid",
    "type" "text" NOT NULL,
    "title" "text" NOT NULL,
    "message" "text" NOT NULL,
    "action_url" "text",
    "action_text" "text",
    "is_read" boolean DEFAULT false,
    "read_at" timestamp with time zone,
    "dismissed_at" timestamp with time zone,
    "scheduled_for" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."user_notifications" OWNER TO "postgres";

COMMENT ON TABLE "public"."user_notifications" IS 'In-app notifications for subscription events';

CREATE TABLE IF NOT EXISTS "public"."user_preferences" (
    "user_id" "uuid" NOT NULL,
    "recording_setup_completed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);

-- ALTER TABLE "public"."user_preferences" OWNER TO "postgres";

COMMENT ON TABLE "public"."user_preferences" IS 'User-specific preferences and state tracking';

COMMENT ON COLUMN "public"."user_preferences"."recording_setup_completed_at" IS 'Timestamp when the user completed the recording setup wizard';

CREATE TABLE IF NOT EXISTS "public"."user_profiles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "email" "text" NOT NULL,
    "full_name" "text",
    "role" "text",
    "is_admin" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."user_profiles" OWNER TO "postgres";

-- ALTER TABLE "public"."user_roles" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."user_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "ai_provider_keys" "jsonb" DEFAULT '{}'::"jsonb",
    "preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"())
);

-- ALTER TABLE "public"."user_settings" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."user_sync_status" (
    "user_id" "uuid" NOT NULL,
    "calendar_last_synced_at" timestamp with time zone,
    "calendar_sync_token" "text",
    "email_last_synced_at" timestamp with time zone,
    "email_sync_token" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "gmail_history_id" "text",
    "gmail_last_full_sync_at" timestamp with time zone,
    "email_categorization_enabled" boolean DEFAULT true,
    "last_categorization_run_at" timestamp with time zone
);

-- ALTER TABLE "public"."user_sync_status" OWNER TO "postgres";

COMMENT ON TABLE "public"."user_sync_status" IS 'Tracks Google Calendar and Gmail sync state per user for incremental synchronization';

COMMENT ON COLUMN "public"."user_sync_status"."calendar_sync_token" IS 'Google Calendar syncToken for incremental sync - use this to fetch only changed events';

COMMENT ON COLUMN "public"."user_sync_status"."email_sync_token" IS 'Gmail historyId for incremental email sync (future use)';

COMMENT ON COLUMN "public"."user_sync_status"."gmail_history_id" IS 'Gmail historyId for incremental message sync (more efficient than date-based)';

COMMENT ON COLUMN "public"."user_sync_status"."gmail_last_full_sync_at" IS 'Timestamp of last full Gmail sync (to know when to do incremental)';

COMMENT ON COLUMN "public"."user_sync_status"."email_categorization_enabled" IS 'User-level toggle for email categorization';

COMMENT ON COLUMN "public"."user_sync_status"."last_categorization_run_at" IS 'Last time the categorizer processed this user''s emails';

CREATE OR REPLACE VIEW "public"."user_task_list_configs" WITH ("security_invoker"='true') AS
 SELECT "id",
    "user_id",
    "google_list_id",
    "list_title",
    "sync_direction",
    "is_primary",
    "priority_filter",
    "task_categories",
    "status_filter",
    "auto_create_in_list",
    "sync_enabled",
    "display_order",
    "created_at",
    "updated_at",
        CASE
            WHEN ("priority_filter" = '{}'::"text"[]) THEN 'All priorities'::"text"
            WHEN (('high'::"text" = ANY ("priority_filter")) AND ('critical'::"text" = ANY ("priority_filter"))) THEN 'High & Critical only'::"text"
            WHEN ('high'::"text" = ANY ("priority_filter")) THEN 'High priority only'::"text"
            WHEN ('medium'::"text" = ANY ("priority_filter")) THEN 'Medium and above'::"text"
            ELSE 'Custom filter'::"text"
        END AS "priority_description",
        CASE
            WHEN "is_primary" THEN 'Primary list'::"text"
            WHEN ("array_length"("priority_filter", 1) > 0) THEN 'Filtered list'::"text"
            ELSE 'Secondary list'::"text"
        END AS "list_type"
   FROM "public"."google_tasks_list_configs" "c"
  WHERE ("sync_enabled" = true)
  ORDER BY "is_primary" DESC, "display_order", "created_at";

-- ALTER VIEW "public"."user_task_list_configs" OWNER TO "postgres";

COMMENT ON VIEW "public"."user_task_list_configs" IS 'User task list configurations (security_invoker enabled)';

CREATE TABLE IF NOT EXISTS "public"."user_tone_settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "content_type" "text" NOT NULL,
    "tone_style" "text" DEFAULT 'professional'::"text" NOT NULL,
    "formality_level" integer DEFAULT 5 NOT NULL,
    "emoji_usage" "text" DEFAULT 'none'::"text" NOT NULL,
    "brand_voice_description" "text",
    "sample_phrases" "text"[],
    "words_to_avoid" "text"[] DEFAULT '{}'::"text"[],
    "preferred_keywords" "text"[] DEFAULT '{}'::"text"[],
    "max_length_override" integer,
    "include_cta" boolean DEFAULT true,
    "cta_style" "text" DEFAULT 'soft'::"text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "user_tone_settings_content_type_check" CHECK (("content_type" = ANY (ARRAY['social'::"text", 'blog'::"text", 'email'::"text", 'video'::"text"]))),
    CONSTRAINT "user_tone_settings_emoji_usage_check" CHECK (("emoji_usage" = ANY (ARRAY['none'::"text", 'minimal'::"text", 'moderate'::"text", 'liberal'::"text"]))),
    CONSTRAINT "user_tone_settings_formality_level_check" CHECK ((("formality_level" >= 1) AND ("formality_level" <= 10)))
);

-- ALTER TABLE "public"."user_tone_settings" OWNER TO "postgres";

CREATE OR REPLACE VIEW "public"."user_weekly_cohorts" WITH ("security_invoker"='true') AS
 SELECT ("date_trunc"('week'::"text", "created_at"))::"date" AS "cohort_week",
    EXTRACT(week FROM "created_at") AS "week_number",
    EXTRACT(year FROM "created_at") AS "year",
    "count"(DISTINCT "user_id") AS "total_users",
    "count"(DISTINCT
        CASE
            WHEN ("fathom_connected" = true) THEN "user_id"
            ELSE NULL::"uuid"
        END) AS "fathom_connected",
    "count"(DISTINCT
        CASE
            WHEN ("first_meeting_synced" = true) THEN "user_id"
            ELSE NULL::"uuid"
        END) AS "first_meeting_synced",
    "count"(DISTINCT
        CASE
            WHEN ("first_summary_viewed" = true) THEN "user_id"
            ELSE NULL::"uuid"
        END) AS "first_summary_viewed",
    "count"(DISTINCT
        CASE
            WHEN ("activation_completed_at" IS NOT NULL) THEN "user_id"
            ELSE NULL::"uuid"
        END) AS "fully_activated",
    "round"(((100.0 * ("count"(DISTINCT
        CASE
            WHEN ("fathom_connected" = true) THEN "user_id"
            ELSE NULL::"uuid"
        END))::numeric) / (NULLIF("count"(DISTINCT "user_id"), 0))::numeric), 1) AS "fathom_rate",
    "round"(((100.0 * ("count"(DISTINCT
        CASE
            WHEN ("first_meeting_synced" = true) THEN "user_id"
            ELSE NULL::"uuid"
        END))::numeric) / (NULLIF("count"(DISTINCT "user_id"), 0))::numeric), 1) AS "meeting_synced_rate",
    "round"(((100.0 * ("count"(DISTINCT
        CASE
            WHEN ("first_summary_viewed" = true) THEN "user_id"
            ELSE NULL::"uuid"
        END))::numeric) / (NULLIF("count"(DISTINCT "user_id"), 0))::numeric), 1) AS "summary_viewed_rate",
    "round"(((100.0 * ("count"(DISTINCT
        CASE
            WHEN ("activation_completed_at" IS NOT NULL) THEN "user_id"
            ELSE NULL::"uuid"
        END))::numeric) / (NULLIF("count"(DISTINCT "user_id"), 0))::numeric), 1) AS "activation_rate",
    "round"("avg"(
        CASE
            WHEN ("activation_completed_at" IS NOT NULL) THEN (EXTRACT(epoch FROM ("activation_completed_at" - "created_at")) / (86400)::numeric)
            ELSE NULL::numeric
        END), 1) AS "avg_days_to_activation"
   FROM "public"."user_onboarding_progress" "uop"
  WHERE ("created_at" >= ("now"() - '90 days'::interval))
  GROUP BY ("date_trunc"('week'::"text", "created_at")), (EXTRACT(week FROM "created_at")), (EXTRACT(year FROM "created_at"))
  ORDER BY (("date_trunc"('week'::"text", "created_at"))::"date") DESC;

-- ALTER VIEW "public"."user_weekly_cohorts" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."user_writing_styles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "tone_description" "text" NOT NULL,
    "examples" "text"[] DEFAULT '{}'::"text"[],
    "is_default" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "style_metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "source" "text" DEFAULT 'manual'::"text",
    "source_email_count" integer DEFAULT 0,
    "trained_at" timestamp with time zone,
    CONSTRAINT "user_writing_styles_source_check" CHECK (("source" = ANY (ARRAY['manual'::"text", 'email_training'::"text"])))
);

-- ALTER TABLE "public"."user_writing_styles" OWNER TO "postgres";

COMMENT ON COLUMN "public"."user_writing_styles"."style_metadata" IS 'Rich metadata extracted from email analysis: tone characteristics, structural patterns, vocabulary profile, greetings/signoffs';

COMMENT ON COLUMN "public"."user_writing_styles"."source" IS 'How this style was created: manual (user-entered) or email_training (extracted from Gmail)';

COMMENT ON COLUMN "public"."user_writing_styles"."source_email_count" IS 'Number of emails analyzed to create this style (only for email_training source)';

COMMENT ON COLUMN "public"."user_writing_styles"."trained_at" IS 'Timestamp when this style was trained from emails (only for email_training source)';

CREATE OR REPLACE VIEW "public"."v_failed_transcript_retries" WITH ("security_invoker"='true') AS
 SELECT "rtj"."id",
    "rtj"."meeting_id",
    "m"."title" AS "meeting_title",
    "m"."fathom_recording_id",
    "rtj"."user_id",
    "p"."email" AS "user_email",
    "rtj"."recording_id",
    "rtj"."attempt_count",
    "rtj"."max_attempts",
    "rtj"."last_error",
    "rtj"."created_at",
    "rtj"."updated_at",
    "rtj"."completed_at",
    (EXTRACT(epoch FROM ("now"() - "rtj"."updated_at")) / (60)::numeric) AS "minutes_since_last_update"
   FROM (("public"."fathom_transcript_retry_jobs" "rtj"
     LEFT JOIN "public"."meetings" "m" ON (("m"."id" = "rtj"."meeting_id")))
     LEFT JOIN "public"."profiles" "p" ON (("p"."id" = "rtj"."user_id")))
  WHERE ("rtj"."status" = 'failed'::"text")
  ORDER BY "rtj"."updated_at" DESC;

-- ALTER VIEW "public"."v_failed_transcript_retries" OWNER TO "postgres";

COMMENT ON VIEW "public"."v_failed_transcript_retries" IS 'View of all failed transcript retry jobs for monitoring (security_invoker enabled)';

CREATE OR REPLACE VIEW "public"."v_pending_transcript_retries" WITH ("security_invoker"='true') AS
 SELECT "rtj"."id",
    "rtj"."meeting_id",
    "m"."title" AS "meeting_title",
    "m"."fathom_recording_id",
    "rtj"."user_id",
    "p"."email" AS "user_email",
    "rtj"."recording_id",
    "rtj"."attempt_count",
    "rtj"."max_attempts",
    "rtj"."next_retry_at",
    "rtj"."last_error",
    "rtj"."created_at",
    "rtj"."updated_at",
        CASE
            WHEN ("rtj"."next_retry_at" <= "now"()) THEN 'ready'::"text"
            ELSE 'waiting'::"text"
        END AS "retry_status",
    (EXTRACT(epoch FROM ("rtj"."next_retry_at" - "now"())) / (60)::numeric) AS "minutes_until_retry"
   FROM (("public"."fathom_transcript_retry_jobs" "rtj"
     LEFT JOIN "public"."meetings" "m" ON (("m"."id" = "rtj"."meeting_id")))
     LEFT JOIN "public"."profiles" "p" ON (("p"."id" = "rtj"."user_id")))
  WHERE ("rtj"."status" = ANY (ARRAY['pending'::"text", 'processing'::"text"]))
  ORDER BY "rtj"."next_retry_at";

-- ALTER VIEW "public"."v_pending_transcript_retries" OWNER TO "postgres";

COMMENT ON VIEW "public"."v_pending_transcript_retries" IS 'View of all pending/processing transcript retry jobs (security_invoker enabled)';

CREATE OR REPLACE VIEW "public"."v_transcript_retry_stats" WITH ("security_invoker"='true') AS
 SELECT "count"(*) FILTER (WHERE ("status" = 'pending'::"text")) AS "pending_count",
    "count"(*) FILTER (WHERE ("status" = 'processing'::"text")) AS "processing_count",
    "count"(*) FILTER (WHERE ("status" = 'completed'::"text")) AS "completed_count",
    "count"(*) FILTER (WHERE ("status" = 'failed'::"text")) AS "failed_count",
    "count"(*) FILTER (WHERE (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text"])) AND ("next_retry_at" <= "now"()))) AS "ready_to_retry",
    "avg"("attempt_count") FILTER (WHERE ("status" = 'completed'::"text")) AS "avg_attempts_to_complete",
    "max"("attempt_count") AS "max_attempts_made",
    "count"(DISTINCT "user_id") AS "unique_users_with_retries",
    "count"(DISTINCT "meeting_id") AS "unique_meetings_with_retries"
   FROM "public"."fathom_transcript_retry_jobs";

-- ALTER VIEW "public"."v_transcript_retry_stats" OWNER TO "postgres";

COMMENT ON VIEW "public"."v_transcript_retry_stats" IS 'Aggregate statistics for transcript retry system (security_invoker enabled)';

CREATE TABLE IF NOT EXISTS "public"."variable_storage" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid",
    "execution_id" "uuid",
    "scope" "text" NOT NULL,
    "key" "text" NOT NULL,
    "value" "jsonb" NOT NULL,
    "ttl_seconds" integer,
    "expires_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "variable_storage_scope_check" CHECK (("scope" = ANY (ARRAY['global'::"text", 'workflow'::"text", 'execution'::"text", 'branch'::"text", 'ephemeral'::"text"])))
);

-- ALTER TABLE "public"."variable_storage" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."voice_recordings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "org_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "title" "text" DEFAULT 'Untitled Recording'::"text" NOT NULL,
    "audio_url" "text" NOT NULL,
    "file_name" "text" NOT NULL,
    "file_size_bytes" integer,
    "duration_seconds" integer,
    "status" "text" DEFAULT 'uploaded'::"text" NOT NULL,
    "error_message" "text",
    "transcript_text" "text",
    "transcript_segments" "jsonb",
    "speakers" "jsonb",
    "language" "text" DEFAULT 'en'::"text",
    "summary" "text",
    "action_items" "jsonb",
    "key_topics" "jsonb",
    "sentiment_score" numeric(3,2),
    "meeting_id" "uuid",
    "contact_id" "uuid",
    "company_id" "uuid",
    "deal_id" "uuid",
    "recorded_at" timestamp with time zone DEFAULT "now"(),
    "processed_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "recording_type" "text" DEFAULT 'meeting'::"text" NOT NULL,
    "gladia_result_url" "text",
    "share_token" "uuid" DEFAULT "gen_random_uuid"(),
    "is_public" boolean DEFAULT false,
    "share_views" integer DEFAULT 0,
    "last_viewed_at" timestamp with time zone,
    CONSTRAINT "voice_recordings_recording_type_check" CHECK (("recording_type" = ANY (ARRAY['meeting'::"text", 'voice_note'::"text"]))),
    CONSTRAINT "voice_recordings_status_check" CHECK (("status" = ANY (ARRAY['uploaded'::"text", 'transcribing'::"text", 'analyzing'::"text", 'completed'::"text", 'failed'::"text"])))
);

-- ALTER TABLE "public"."voice_recordings" OWNER TO "postgres";

COMMENT ON TABLE "public"."voice_recordings" IS 'Stores voice recordings from use60 Voice feature with transcriptions and AI analysis';

COMMENT ON COLUMN "public"."voice_recordings"."status" IS 'Processing status: uploaded -> transcribing -> analyzing -> completed/failed';

COMMENT ON COLUMN "public"."voice_recordings"."transcript_segments" IS 'Array of speaker-attributed transcript segments with timestamps';

COMMENT ON COLUMN "public"."voice_recordings"."speakers" IS 'Array of detected speakers with names and colors';

COMMENT ON COLUMN "public"."voice_recordings"."action_items" IS 'AI-extracted action items from the recording';

COMMENT ON COLUMN "public"."voice_recordings"."recording_type" IS 'Type of recording: meeting (external calls, client meetings) or voice_note (internal notes, AI commands)';

COMMENT ON COLUMN "public"."voice_recordings"."share_token" IS 'Unique token for public sharing URL';

COMMENT ON COLUMN "public"."voice_recordings"."is_public" IS 'Whether the recording is publicly accessible via share link';

COMMENT ON COLUMN "public"."voice_recordings"."share_views" IS 'Number of times the public link has been viewed';

COMMENT ON COLUMN "public"."voice_recordings"."last_viewed_at" IS 'Timestamp of last public view';

CREATE TABLE IF NOT EXISTS "public"."vsl_video_analytics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "signup_source" "text" NOT NULL,
    "video_public_id" "text" NOT NULL,
    "event_type" "text" NOT NULL,
    "playback_time" numeric DEFAULT 0,
    "duration" numeric DEFAULT 0,
    "progress_percent" numeric DEFAULT 0,
    "watch_time" numeric DEFAULT 0,
    "session_id" "text" NOT NULL,
    "user_agent" "text",
    "referrer" "text",
    "screen_width" integer,
    "screen_height" integer,
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."vsl_video_analytics" OWNER TO "postgres";

COMMENT ON TABLE "public"."vsl_video_analytics" IS 'Tracks video engagement events for VSL split testing';

CREATE OR REPLACE VIEW "public"."vsl_analytics_summary" WITH ("security_invoker"='true') AS
 WITH "session_watch_times" AS (
         SELECT "vsl_video_analytics"."session_id",
            "vsl_video_analytics"."signup_source",
            "vsl_video_analytics"."video_public_id",
            "date"("vsl_video_analytics"."created_at") AS "event_date",
            "max"("vsl_video_analytics"."watch_time") AS "max_watch_time",
            "max"("vsl_video_analytics"."progress_percent") AS "max_progress"
           FROM "public"."vsl_video_analytics"
          WHERE (("vsl_video_analytics"."event_type" = ANY (ARRAY['pause'::"text", 'ended'::"text", 'progress'::"text"])) AND ("vsl_video_analytics"."watch_time" IS NOT NULL) AND ("vsl_video_analytics"."watch_time" > (0)::numeric))
          GROUP BY "vsl_video_analytics"."session_id", "vsl_video_analytics"."signup_source", "vsl_video_analytics"."video_public_id", ("date"("vsl_video_analytics"."created_at"))
        ), "waitlist_with_source" AS (
         SELECT "meetings_waitlist"."id",
            "meetings_waitlist"."created_at",
            COALESCE("meetings_waitlist"."signup_source",
                CASE
                    WHEN (("meetings_waitlist"."registration_url" ~~ '%/intro%'::"text") AND ("meetings_waitlist"."registration_url" !~~ '%/introducing%'::"text") AND ("meetings_waitlist"."registration_url" !~~ '%/introduction%'::"text")) THEN 'intro-vsl'::"text"
                    WHEN ("meetings_waitlist"."registration_url" ~~ '%/introducing%'::"text") THEN 'introducing-vsl'::"text"
                    WHEN ("meetings_waitlist"."registration_url" ~~ '%/introduction%'::"text") THEN 'introduction-vsl'::"text"
                    WHEN ("meetings_waitlist"."registration_url" ~~ '%/waitlist%'::"text") THEN 'waitlist'::"text"
                    ELSE NULL::"text"
                END) AS "effective_signup_source"
           FROM "public"."meetings_waitlist"
          WHERE ("meetings_waitlist"."is_seeded" IS NOT TRUE)
        ), "total_conversions" AS (
         SELECT "waitlist_with_source"."effective_signup_source" AS "signup_source",
            "count"(*) AS "total_conversion_count"
           FROM "waitlist_with_source"
          WHERE ("waitlist_with_source"."effective_signup_source" IS NOT NULL)
          GROUP BY "waitlist_with_source"."effective_signup_source"
        ), "daily_conversions" AS (
         SELECT "waitlist_with_source"."effective_signup_source" AS "signup_source",
            "date"("waitlist_with_source"."created_at") AS "conversion_date",
            "count"(*) AS "conversion_count"
           FROM "waitlist_with_source"
          WHERE ("waitlist_with_source"."effective_signup_source" IS NOT NULL)
          GROUP BY "waitlist_with_source"."effective_signup_source", ("date"("waitlist_with_source"."created_at"))
        ), "watch_time_stats" AS (
         SELECT "session_watch_times"."signup_source",
            "session_watch_times"."video_public_id",
            "session_watch_times"."event_date",
            "avg"("session_watch_times"."max_watch_time") AS "avg_watch_time",
            "avg"("session_watch_times"."max_progress") AS "avg_completion_percent"
           FROM "session_watch_times"
          GROUP BY "session_watch_times"."signup_source", "session_watch_times"."video_public_id", "session_watch_times"."event_date"
        ), "video_daily_stats" AS (
         SELECT "vsl_video_analytics"."signup_source",
            "vsl_video_analytics"."video_public_id",
            "date"("vsl_video_analytics"."created_at") AS "event_date",
            "count"(DISTINCT "vsl_video_analytics"."session_id") FILTER (WHERE ("vsl_video_analytics"."event_type" = 'view'::"text")) AS "unique_views",
            "count"(*) FILTER (WHERE ("vsl_video_analytics"."event_type" = 'view'::"text")) AS "total_views",
            "count"(DISTINCT "vsl_video_analytics"."session_id") FILTER (WHERE ("vsl_video_analytics"."event_type" = 'play'::"text")) AS "unique_plays",
            "count"(*) FILTER (WHERE ("vsl_video_analytics"."event_type" = 'play'::"text")) AS "total_plays",
            "count"(DISTINCT "vsl_video_analytics"."session_id") FILTER (WHERE ("vsl_video_analytics"."event_type" = 'ended'::"text")) AS "completions",
            "count"(DISTINCT "vsl_video_analytics"."session_id") FILTER (WHERE (("vsl_video_analytics"."event_type" = 'progress'::"text") AND ("vsl_video_analytics"."progress_percent" >= (25)::numeric))) AS "reached_25",
            "count"(DISTINCT "vsl_video_analytics"."session_id") FILTER (WHERE (("vsl_video_analytics"."event_type" = 'progress'::"text") AND ("vsl_video_analytics"."progress_percent" >= (50)::numeric))) AS "reached_50",
            "count"(DISTINCT "vsl_video_analytics"."session_id") FILTER (WHERE (("vsl_video_analytics"."event_type" = 'progress'::"text") AND ("vsl_video_analytics"."progress_percent" >= (75)::numeric))) AS "reached_75"
           FROM "public"."vsl_video_analytics"
          GROUP BY "vsl_video_analytics"."signup_source", "vsl_video_analytics"."video_public_id", ("date"("vsl_video_analytics"."created_at"))
        ), "all_dates" AS (
         SELECT DISTINCT "video_daily_stats"."event_date" AS "date"
           FROM "video_daily_stats"
        UNION
         SELECT DISTINCT "daily_conversions"."conversion_date" AS "date"
           FROM "daily_conversions"
        ), "all_sources" AS (
         SELECT DISTINCT "video_daily_stats"."signup_source"
           FROM "video_daily_stats"
          WHERE ("video_daily_stats"."signup_source" IS NOT NULL)
        UNION
         SELECT DISTINCT "daily_conversions"."signup_source"
           FROM "daily_conversions"
          WHERE ("daily_conversions"."signup_source" IS NOT NULL)
        ), "source_date_matrix" AS (
         SELECT "s"."signup_source",
            "d"."date"
           FROM ("all_sources" "s"
             CROSS JOIN "all_dates" "d")
        )
 SELECT "sdm"."signup_source",
    "vds"."video_public_id",
    "sdm"."date",
    COALESCE("vds"."unique_views", (0)::bigint) AS "unique_views",
    COALESCE("vds"."total_views", (0)::bigint) AS "total_views",
    COALESCE("vds"."unique_plays", (0)::bigint) AS "unique_plays",
    COALESCE("vds"."total_plays", (0)::bigint) AS "total_plays",
    COALESCE("vds"."completions", (0)::bigint) AS "completions",
    COALESCE("vds"."reached_25", (0)::bigint) AS "reached_25",
    COALESCE("vds"."reached_50", (0)::bigint) AS "reached_50",
    COALESCE("vds"."reached_75", (0)::bigint) AS "reached_75",
    "wts"."avg_watch_time",
    "wts"."avg_completion_percent",
    COALESCE("dc"."conversion_count", (0)::bigint) AS "daily_conversions",
    COALESCE("tc"."total_conversion_count", (0)::bigint) AS "conversions"
   FROM (((("source_date_matrix" "sdm"
     LEFT JOIN "video_daily_stats" "vds" ON ((("vds"."signup_source" = "sdm"."signup_source") AND ("vds"."event_date" = "sdm"."date"))))
     LEFT JOIN "watch_time_stats" "wts" ON ((("wts"."signup_source" = "sdm"."signup_source") AND ("wts"."video_public_id" = "vds"."video_public_id") AND ("wts"."event_date" = "sdm"."date"))))
     LEFT JOIN "daily_conversions" "dc" ON ((("dc"."signup_source" = "sdm"."signup_source") AND ("dc"."conversion_date" = "sdm"."date"))))
     LEFT JOIN "total_conversions" "tc" ON (("tc"."signup_source" = "sdm"."signup_source")))
  WHERE ("sdm"."signup_source" IS NOT NULL);

-- ALTER VIEW "public"."vsl_analytics_summary" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."waitlist_admin_actions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "waitlist_entry_id" "uuid" NOT NULL,
    "admin_user_id" "uuid" NOT NULL,
    "action_type" character varying(50) NOT NULL,
    "action_details" "jsonb",
    "previous_value" "jsonb",
    "new_value" "jsonb",
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "waitlist_admin_actions_action_type_check" CHECK ((("action_type")::"text" = ANY (ARRAY[('grant_access'::character varying)::"text", ('adjust_position'::character varying)::"text", ('send_email'::character varying)::"text", ('export_data'::character varying)::"text", ('status_change'::character varying)::"text", ('notes_update'::character varying)::"text"])))
);

-- ALTER TABLE "public"."waitlist_admin_actions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."waitlist_email_invites" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "waitlist_entry_id" "uuid" NOT NULL,
    "email" character varying(255) NOT NULL,
    "invite_status" character varying(50) DEFAULT 'pending'::character varying,
    "sent_at" timestamp with time zone,
    "converted_at" timestamp with time zone,
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "waitlist_email_invites_invite_status_check" CHECK ((("invite_status")::"text" = ANY (ARRAY[('pending'::character varying)::"text", ('sent'::character varying)::"text", ('failed'::character varying)::"text", ('converted'::character varying)::"text"])))
);

-- ALTER TABLE "public"."waitlist_email_invites" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."waitlist_invite_codes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "code" "text" NOT NULL,
    "description" "text",
    "is_active" boolean DEFAULT true NOT NULL,
    "use_count" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "last_used_at" timestamp with time zone
);

-- ALTER TABLE "public"."waitlist_invite_codes" OWNER TO "postgres";

COMMENT ON TABLE "public"."waitlist_invite_codes" IS 'Invite codes required to join the waitlist. Admin bypass code SIXTY60 is hardcoded in the application.';

COMMENT ON COLUMN "public"."waitlist_invite_codes"."last_used_at" IS 'Timestamp of the last time this code was used for signup.';

CREATE TABLE IF NOT EXISTS "public"."waitlist_onboarding_progress" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "waitlist_entry_id" "uuid",
    "account_created_at" timestamp with time zone,
    "profile_completed_at" timestamp with time zone,
    "first_meeting_synced_at" timestamp with time zone,
    "meeting_intelligence_used_at" timestamp with time zone,
    "crm_integrated_at" timestamp with time zone,
    "team_invited_at" timestamp with time zone,
    "completion_percentage" integer DEFAULT 0,
    "completed_steps" integer DEFAULT 0,
    "total_steps" integer DEFAULT 6 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "waitlist_onboarding_progress_completed_steps_check" CHECK ((("completed_steps" >= 0) AND ("completed_steps" <= 6))),
    CONSTRAINT "waitlist_onboarding_progress_completion_percentage_check" CHECK ((("completion_percentage" >= 0) AND ("completion_percentage" <= 100)))
);

-- ALTER TABLE "public"."waitlist_onboarding_progress" OWNER TO "postgres";

COMMENT ON TABLE "public"."waitlist_onboarding_progress" IS 'Tracks waitlist user completion of 6 key onboarding steps with automatic progress calculation';

COMMENT ON COLUMN "public"."waitlist_onboarding_progress"."completion_percentage" IS 'Auto-calculated percentage of completed steps (0-100)';

COMMENT ON COLUMN "public"."waitlist_onboarding_progress"."completed_steps" IS 'Auto-calculated count of completed steps (0-6)';

CREATE TABLE IF NOT EXISTS "public"."waitlist_shares" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "waitlist_entry_id" "uuid" NOT NULL,
    "platform" "text" NOT NULL,
    "referral_clicked" boolean DEFAULT false,
    "referral_converted" boolean DEFAULT false,
    "shared_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "waitlist_shares_platform_check" CHECK (("platform" = ANY (ARRAY['twitter'::"text", 'linkedin'::"text", 'email'::"text", 'copy'::"text"])))
);

-- ALTER TABLE "public"."waitlist_shares" OWNER TO "postgres";

COMMENT ON TABLE "public"."waitlist_shares" IS 'Tracks referral link sharing for waitlist gamification and viral growth analytics';

COMMENT ON COLUMN "public"."waitlist_shares"."platform" IS 'Platform where link was shared: twitter, linkedin, email, or copy (clipboard)';

COMMENT ON COLUMN "public"."waitlist_shares"."referral_clicked" IS 'Whether someone clicked the referral link';

COMMENT ON COLUMN "public"."waitlist_shares"."referral_converted" IS 'Whether the click converted to a signup';

CREATE OR REPLACE VIEW "public"."waitlist_with_rank" WITH ("security_invoker"='true') AS
 SELECT "id",
    "email",
    "full_name",
    "company_name",
    "dialer_tool",
    "dialer_other",
    "meeting_recorder_tool",
    "meeting_recorder_other",
    "crm_tool",
    "crm_other",
    "referral_code",
    "referred_by_code",
    "referral_count",
    "signup_position",
    "effective_position",
    "status",
    "released_at",
    "released_by",
    "admin_notes",
    "utm_source",
    "utm_campaign",
    "utm_medium",
    "registration_url",
    "created_at",
    "updated_at",
    "user_id",
    "converted_at",
    "magic_link_sent_at",
    "magic_link_expires_at",
    "access_granted_by",
    "total_points",
    "linkedin_boost_claimed",
    "twitter_boost_claimed",
    "linkedin_share_claimed",
    "linkedin_first_share_at",
    "task_manager_tool",
    "task_manager_other",
    "is_seeded",
    "row_number"() OVER (ORDER BY COALESCE("effective_position", 999999), "created_at") AS "display_rank"
   FROM "public"."meetings_waitlist"
  WHERE ("status" <> 'declined'::"public"."waitlist_status");

-- ALTER VIEW "public"."waitlist_with_rank" OWNER TO "postgres";

COMMENT ON VIEW "public"."waitlist_with_rank" IS 'Waitlist entries with display_rank that breaks ties by signup time (includes registration_url)';

CREATE TABLE IF NOT EXISTS "public"."webhook_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "source" "text" NOT NULL,
    "event_type" "text" NOT NULL,
    "event_id" "text",
    "payload" "jsonb" NOT NULL,
    "headers" "jsonb",
    "status" "text" DEFAULT 'received'::"text",
    "processed_at" timestamp with time zone,
    "error_message" "text",
    "retry_count" integer DEFAULT 0,
    "next_retry_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "webhook_events_status_check" CHECK (("status" = ANY (ARRAY['received'::"text", 'processing'::"text", 'processed'::"text", 'failed'::"text", 'ignored'::"text"])))
);

-- ALTER TABLE "public"."webhook_events" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."webhook_mirror_config" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid" NOT NULL,
    "source_environment" "text" NOT NULL,
    "target_environment" "text" NOT NULL,
    "mirror_percentage" numeric(5,2) DEFAULT 0,
    "filter_rules" "jsonb" DEFAULT '[]'::"jsonb",
    "is_active" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."webhook_mirror_config" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workflow_batch_windows" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid" NOT NULL,
    "node_id" "text" NOT NULL,
    "window_type" "text",
    "window_size" integer NOT NULL,
    "current_batch" "jsonb" DEFAULT '[]'::"jsonb",
    "current_count" integer DEFAULT 0,
    "current_size" integer DEFAULT 0,
    "window_started_at" timestamp with time zone DEFAULT "now"(),
    "window_closes_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "workflow_batch_windows_window_type_check" CHECK (("window_type" = ANY (ARRAY['time'::"text", 'count'::"text", 'size'::"text"])))
);

-- ALTER TABLE "public"."workflow_batch_windows" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workflow_circuit_breakers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid",
    "node_id" "text" NOT NULL,
    "state" "text" DEFAULT 'closed'::"text",
    "failure_count" integer DEFAULT 0,
    "success_count" integer DEFAULT 0,
    "failure_threshold" integer DEFAULT 5,
    "success_threshold" integer DEFAULT 3,
    "timeout_seconds" integer DEFAULT 60,
    "last_failure_at" timestamp with time zone,
    "opens_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "workflow_circuit_breakers_state_check" CHECK (("state" = ANY (ARRAY['closed'::"text", 'open'::"text", 'half_open'::"text"])))
);

-- ALTER TABLE "public"."workflow_circuit_breakers" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workflow_contracts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid" NOT NULL,
    "node_id" "text" NOT NULL,
    "node_type" "text" NOT NULL,
    "input_schema" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "output_schema" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "version" integer DEFAULT 1,
    "is_current" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."workflow_contracts" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workflow_dead_letter_queue" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid" NOT NULL,
    "execution_id" "uuid",
    "trigger_data" "jsonb" DEFAULT '{}'::"jsonb",
    "error_message" "text",
    "error_count" integer DEFAULT 1,
    "max_retries" integer DEFAULT 3,
    "next_retry_at" timestamp with time zone,
    "status" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "resolved_at" timestamp with time zone,
    CONSTRAINT "workflow_dead_letter_queue_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'retrying'::"text", 'failed'::"text", 'resolved'::"text"])))
);

-- ALTER TABLE "public"."workflow_dead_letter_queue" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workflow_environment_promotions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid" NOT NULL,
    "from_environment" "text" NOT NULL,
    "to_environment" "text" NOT NULL,
    "promoted_by" "uuid",
    "changes_diff" "jsonb" DEFAULT '{}'::"jsonb",
    "rollback_data" "jsonb" DEFAULT '{}'::"jsonb",
    "status" "text",
    "promoted_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "workflow_environment_promotions_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'completed'::"text", 'failed'::"text", 'rolled_back'::"text"])))
);

-- ALTER TABLE "public"."workflow_environment_promotions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workflow_environments" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid" NOT NULL,
    "environment" "text" NOT NULL,
    "config" "jsonb" DEFAULT '{}'::"jsonb",
    "variables" "jsonb" DEFAULT '{}'::"jsonb",
    "secrets" "jsonb" DEFAULT '{}'::"jsonb",
    "webhook_urls" "jsonb" DEFAULT '{}'::"jsonb",
    "rate_limits" "jsonb" DEFAULT '{}'::"jsonb",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "workflow_environments_environment_check" CHECK (("environment" = ANY (ARRAY['build'::"text", 'staging'::"text", 'live'::"text"])))
);

-- ALTER TABLE "public"."workflow_environments" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workflow_executions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "trigger_type" "text" NOT NULL,
    "trigger_data" "jsonb",
    "execution_status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "started_at" timestamp with time zone DEFAULT "now"(),
    "completed_at" timestamp with time zone,
    "action_results" "jsonb",
    "error_message" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "clerk_org_id" "text"
);

-- ALTER TABLE "public"."workflow_executions" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workflow_forms" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "form_id" "text" NOT NULL,
    "workflow_id" "uuid",
    "config" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "is_test" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "created_by" "uuid"
);

-- ALTER TABLE "public"."workflow_forms" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workflow_idempotency_keys" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid" NOT NULL,
    "idempotency_key" "text" NOT NULL,
    "execution_id" "uuid",
    "result" "jsonb",
    "status" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "expires_at" timestamp with time zone,
    CONSTRAINT "workflow_idempotency_keys_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'processing'::"text", 'completed'::"text", 'failed'::"text"])))
);

-- ALTER TABLE "public"."workflow_idempotency_keys" OWNER TO "postgres";

-- ALTER TABLE "public"."workflow_mcp_logs" OWNER TO "postgres";

CREATE TABLE IF NOT EXISTS "public"."workflow_rate_limits" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "workflow_id" "uuid",
    "node_id" "text",
    "limit_key" "text" NOT NULL,
    "requests_per_second" integer,
    "requests_per_minute" integer,
    "requests_per_hour" integer,
    "burst_size" integer DEFAULT 10,
    "current_tokens" integer DEFAULT 0,
    "last_refill_at" timestamp with time zone DEFAULT "now"(),
    "created_at" timestamp with time zone DEFAULT "now"()
);

-- ALTER TABLE "public"."workflow_rate_limits" OWNER TO "postgres";

ALTER TABLE ONLY "public"."roadmap_suggestions" ALTER COLUMN "ticket_id" SET DEFAULT "nextval"('"public"."roadmap_suggestions_ticket_id_seq"'::"regclass");

ALTER TABLE ONLY "public"."action_items"
    ADD CONSTRAINT "action_items_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."activities"
    ADD CONSTRAINT "activities_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."activity_sync_rules"
    ADD CONSTRAINT "activity_sync_rules_activity_type_owner_id_key" UNIQUE ("activity_type", "owner_id");

ALTER TABLE ONLY "public"."activity_sync_rules"
    ADD CONSTRAINT "activity_sync_rules_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."ai_cost_events"
    ADD CONSTRAINT "ai_cost_events_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."ai_feedback"
    ADD CONSTRAINT "ai_feedback_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."ai_insights"
    ADD CONSTRAINT "ai_insights_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."ai_prompt_template_history"
    ADD CONSTRAINT "ai_prompt_template_history_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."ai_prompt_templates"
    ADD CONSTRAINT "ai_prompt_templates_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."ai_usage_logs"
    ADD CONSTRAINT "ai_usage_logs_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."api_key_usage"
    ADD CONSTRAINT "api_key_usage_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."api_keys"
    ADD CONSTRAINT "api_keys_key_hash_key" UNIQUE ("key_hash");

ALTER TABLE ONLY "public"."api_keys"
    ADD CONSTRAINT "api_keys_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."api_monitor_improvements"
    ADD CONSTRAINT "api_monitor_improvements_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."api_monitor_rollups_daily"
    ADD CONSTRAINT "api_monitor_rollups_daily_date_user_id_key" UNIQUE ("date", "user_id");

ALTER TABLE ONLY "public"."api_monitor_rollups_daily"
    ADD CONSTRAINT "api_monitor_rollups_daily_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."api_monitor_snapshots"
    ADD CONSTRAINT "api_monitor_snapshots_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."api_requests"
    ADD CONSTRAINT "api_requests_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."app_settings"
    ADD CONSTRAINT "app_settings_pkey" PRIMARY KEY ("key");

ALTER TABLE ONLY "public"."audit_logs"
    ADD CONSTRAINT "audit_logs_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."automation_executions"
    ADD CONSTRAINT "automation_executions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."billing_event_log"
    ADD CONSTRAINT "billing_event_log_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."billing_history"
    ADD CONSTRAINT "billing_history_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."booking_sources"
    ADD CONSTRAINT "booking_sources_api_name_key" UNIQUE ("api_name");

ALTER TABLE ONLY "public"."booking_sources"
    ADD CONSTRAINT "booking_sources_name_key" UNIQUE ("name");

ALTER TABLE ONLY "public"."booking_sources"
    ADD CONSTRAINT "booking_sources_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."bot_deployments"
    ADD CONSTRAINT "bot_deployments_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."branding_settings"
    ADD CONSTRAINT "branding_settings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."calendar_attendees"
    ADD CONSTRAINT "calendar_attendees_event_id_email_key" UNIQUE ("event_id", "email");

ALTER TABLE ONLY "public"."calendar_attendees"
    ADD CONSTRAINT "calendar_attendees_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."calendar_calendars"
    ADD CONSTRAINT "calendar_calendars_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."calendar_events"
    ADD CONSTRAINT "calendar_events_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."calendar_reminders"
    ADD CONSTRAINT "calendar_reminders_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."calendar_sync_logs"
    ADD CONSTRAINT "calendar_sync_logs_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."call_action_items"
    ADD CONSTRAINT "call_action_items_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."call_action_items"
    ADD CONSTRAINT "call_action_items_unique_call_title" UNIQUE ("call_id", "title");

ALTER TABLE ONLY "public"."call_file_search_index"
    ADD CONSTRAINT "call_file_search_index_call_id_owner_user_id_key" UNIQUE ("call_id", "owner_user_id");

ALTER TABLE ONLY "public"."call_file_search_index"
    ADD CONSTRAINT "call_file_search_index_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."call_index_queue"
    ADD CONSTRAINT "call_index_queue_call_id_key" UNIQUE ("call_id");

ALTER TABLE ONLY "public"."call_index_queue"
    ADD CONSTRAINT "call_index_queue_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."call_transcript_queue"
    ADD CONSTRAINT "call_transcript_queue_call_id_key" UNIQUE ("call_id");

ALTER TABLE ONLY "public"."call_transcript_queue"
    ADD CONSTRAINT "call_transcript_queue_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."calls"
    ADD CONSTRAINT "calls_org_id_provider_external_id_key" UNIQUE ("org_id", "provider", "external_id");

ALTER TABLE ONLY "public"."calls"
    ADD CONSTRAINT "calls_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."challenge_features"
    ADD CONSTRAINT "challenge_features_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."challenges"
    ADD CONSTRAINT "challenges_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."clerk_sync_log"
    ADD CONSTRAINT "clerk_sync_log_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."clerk_user_mappings"
    ADD CONSTRAINT "clerk_user_mappings_email_key" UNIQUE ("email");

ALTER TABLE ONLY "public"."clerk_user_mappings"
    ADD CONSTRAINT "clerk_user_mappings_pkey" PRIMARY KEY ("clerk_user_id");

ALTER TABLE ONLY "public"."clerk_user_mappings"
    ADD CONSTRAINT "clerk_user_mappings_supabase_user_id_key" UNIQUE ("supabase_user_id");

ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."coaching_scorecard_templates"
    ADD CONSTRAINT "coaching_scorecard_templates_org_id_name_key" UNIQUE ("org_id", "name");

ALTER TABLE ONLY "public"."coaching_scorecard_templates"
    ADD CONSTRAINT "coaching_scorecard_templates_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."communication_events"
    ADD CONSTRAINT "communication_events_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."companies"
    ADD CONSTRAINT "companies_domain_key" UNIQUE ("domain");

ALTER TABLE ONLY "public"."companies"
    ADD CONSTRAINT "companies_name_key" UNIQUE ("name");

ALTER TABLE ONLY "public"."companies"
    ADD CONSTRAINT "companies_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."company_meeting_insights"
    ADD CONSTRAINT "company_meeting_insights_company_id_key" UNIQUE ("company_id");

ALTER TABLE ONLY "public"."company_meeting_insights"
    ADD CONSTRAINT "company_meeting_insights_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."contact_meeting_insights"
    ADD CONSTRAINT "contact_meeting_insights_contact_id_key" UNIQUE ("contact_id");

ALTER TABLE ONLY "public"."contact_meeting_insights"
    ADD CONSTRAINT "contact_meeting_insights_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."contact_notes"
    ADD CONSTRAINT "contact_notes_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."contacts"
    ADD CONSTRAINT "contacts_email_key" UNIQUE ("email");

ALTER TABLE ONLY "public"."contacts"
    ADD CONSTRAINT "contacts_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."content"
    ADD CONSTRAINT "content_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."content_topic_links"
    ADD CONSTRAINT "content_topic_links_pkey" PRIMARY KEY ("content_id", "topic_index");

ALTER TABLE ONLY "public"."copilot_analytics"
    ADD CONSTRAINT "copilot_analytics_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."copilot_conversations"
    ADD CONSTRAINT "copilot_conversations_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."copilot_messages"
    ADD CONSTRAINT "copilot_messages_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."cost_rates"
    ADD CONSTRAINT "cost_rates_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."cost_rates"
    ADD CONSTRAINT "cost_rates_provider_model_effective_from_key" UNIQUE ("provider", "model", "effective_from");

ALTER TABLE ONLY "public"."cron_job_logs"
    ADD CONSTRAINT "cron_job_logs_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."cron_job_settings"
    ADD CONSTRAINT "cron_job_settings_job_name_key" UNIQUE ("job_name");

ALTER TABLE ONLY "public"."cron_job_settings"
    ADD CONSTRAINT "cron_job_settings_pkey" PRIMARY KEY ("id");

-- ALTER TABLE ONLY "public"."cron_notification_subscribers"
--     ADD CONSTRAINT "cron_notification_subscribers_email_unique" UNIQUE ("email");

--
--
-- ALTER TABLE ONLY "public"."cron_notification_subscribers"
--     ADD CONSTRAINT "cron_notification_subscribers_pkey" PRIMARY KEY ("id");

--
--
-- ALTER TABLE ONLY "public"."cron_notifications_log"
--     ADD CONSTRAINT "cron_notifications_log_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."csv_mapping_templates"
    ADD CONSTRAINT "csv_mapping_templates_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."csv_mapping_templates"
    ADD CONSTRAINT "csv_mapping_templates_user_id_name_key" UNIQUE ("user_id", "name");

ALTER TABLE ONLY "public"."deal_activities"
    ADD CONSTRAINT "deal_activities_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."deal_clarity_scores"
    ADD CONSTRAINT "deal_clarity_scores_deal_id_key" UNIQUE ("deal_id");

ALTER TABLE ONLY "public"."deal_clarity_scores"
    ADD CONSTRAINT "deal_clarity_scores_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."deal_close_plan_items"
    ADD CONSTRAINT "deal_close_plan_items_deal_id_milestone_key_key" UNIQUE ("deal_id", "milestone_key");

ALTER TABLE ONLY "public"."deal_close_plan_items"
    ADD CONSTRAINT "deal_close_plan_items_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."deal_health_alerts"
    ADD CONSTRAINT "deal_health_alerts_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."deal_health_history"
    ADD CONSTRAINT "deal_health_history_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."deal_health_rules"
    ADD CONSTRAINT "deal_health_rules_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."deal_health_rules"
    ADD CONSTRAINT "deal_health_rules_rule_name_key" UNIQUE ("rule_name");

ALTER TABLE ONLY "public"."deal_health_scores"
    ADD CONSTRAINT "deal_health_scores_deal_id_key" UNIQUE ("deal_id");

ALTER TABLE ONLY "public"."deal_health_scores"
    ADD CONSTRAINT "deal_health_scores_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."deal_migration_reviews"
    ADD CONSTRAINT "deal_migration_reviews_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."deal_notes"
    ADD CONSTRAINT "deal_notes_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."deal_risk_aggregates"
    ADD CONSTRAINT "deal_risk_aggregates_deal_id_key" UNIQUE ("deal_id");

ALTER TABLE ONLY "public"."deal_risk_aggregates"
    ADD CONSTRAINT "deal_risk_aggregates_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."deal_risk_signals"
    ADD CONSTRAINT "deal_risk_signals_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."deal_splits"
    ADD CONSTRAINT "deal_splits_deal_id_user_id_key" UNIQUE ("deal_id", "user_id");

ALTER TABLE ONLY "public"."deal_splits"
    ADD CONSTRAINT "deal_splits_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."deal_stage_history"
    ADD CONSTRAINT "deal_stage_history_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."deal_stages"
    ADD CONSTRAINT "deal_stages_name_key" UNIQUE ("name");

ALTER TABLE ONLY "public"."deal_stages"
    ADD CONSTRAINT "deal_stages_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."deal_truth_fields"
    ADD CONSTRAINT "deal_truth_fields_deal_id_field_key_key" UNIQUE ("deal_id", "field_key");

ALTER TABLE ONLY "public"."deal_truth_fields"
    ADD CONSTRAINT "deal_truth_fields_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."deals"
    ADD CONSTRAINT "deals_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."email_attachments"
    ADD CONSTRAINT "email_attachments_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."email_categorizations"
    ADD CONSTRAINT "email_categorizations_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."email_categorizations"
    ADD CONSTRAINT "email_categorizations_user_id_external_id_key" UNIQUE ("user_id", "external_id");

ALTER TABLE ONLY "public"."email_journeys"
    ADD CONSTRAINT "email_journeys_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."email_label_map"
    ADD CONSTRAINT "email_label_map_pkey" PRIMARY KEY ("email_id", "label_id");

ALTER TABLE ONLY "public"."email_labels"
    ADD CONSTRAINT "email_labels_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."email_labels"
    ADD CONSTRAINT "email_labels_user_id_name_key" UNIQUE ("user_id", "name");

ALTER TABLE ONLY "public"."email_logs"
    ADD CONSTRAINT "email_logs_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."email_sends"
    ADD CONSTRAINT "email_sends_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."email_templates"
    ADD CONSTRAINT "email_templates_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."email_templates"
    ADD CONSTRAINT "email_templates_user_id_name_key" UNIQUE ("user_id", "name");

ALTER TABLE ONLY "public"."email_threads"
    ADD CONSTRAINT "email_threads_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."emails"
    ADD CONSTRAINT "emails_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."encharge_email_templates"
    ADD CONSTRAINT "encharge_email_templates_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."encharge_email_templates"
    ADD CONSTRAINT "encharge_email_templates_template_name_key" UNIQUE ("template_name");

ALTER TABLE ONLY "public"."execution_checkpoints"
    ADD CONSTRAINT "execution_checkpoints_execution_id_checkpoint_name_key" UNIQUE ("execution_id", "checkpoint_name");

ALTER TABLE ONLY "public"."execution_checkpoints"
    ADD CONSTRAINT "execution_checkpoints_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."execution_snapshots"
    ADD CONSTRAINT "execution_snapshots_execution_id_node_id_sequence_number_key" UNIQUE ("execution_id", "node_id", "sequence_number");

ALTER TABLE ONLY "public"."execution_snapshots"
    ADD CONSTRAINT "execution_snapshots_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."fathom_integrations"
    ADD CONSTRAINT "fathom_integrations_fathom_user_id_key" UNIQUE ("fathom_user_id");

ALTER TABLE ONLY "public"."fathom_integrations"
    ADD CONSTRAINT "fathom_integrations_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."fathom_integrations"
    ADD CONSTRAINT "fathom_integrations_user_id_key" UNIQUE ("user_id");

ALTER TABLE ONLY "public"."fathom_oauth_states"
    ADD CONSTRAINT "fathom_oauth_states_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."fathom_oauth_states"
    ADD CONSTRAINT "fathom_oauth_states_state_key" UNIQUE ("state");

ALTER TABLE ONLY "public"."fathom_org_credentials"
    ADD CONSTRAINT "fathom_org_credentials_pkey" PRIMARY KEY ("org_id");

ALTER TABLE ONLY "public"."fathom_org_integrations"
    ADD CONSTRAINT "fathom_org_integrations_org_id_unique" UNIQUE ("org_id");

ALTER TABLE ONLY "public"."fathom_org_integrations"
    ADD CONSTRAINT "fathom_org_integrations_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."fathom_org_sync_state"
    ADD CONSTRAINT "fathom_org_sync_state_integration_id_unique" UNIQUE ("integration_id");

ALTER TABLE ONLY "public"."fathom_org_sync_state"
    ADD CONSTRAINT "fathom_org_sync_state_org_id_unique" UNIQUE ("org_id");

ALTER TABLE ONLY "public"."fathom_org_sync_state"
    ADD CONSTRAINT "fathom_org_sync_state_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."fathom_sync_state"
    ADD CONSTRAINT "fathom_sync_state_integration_id_key" UNIQUE ("integration_id");

ALTER TABLE ONLY "public"."fathom_sync_state"
    ADD CONSTRAINT "fathom_sync_state_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."fathom_sync_state"
    ADD CONSTRAINT "fathom_sync_state_user_id_key" UNIQUE ("user_id");

ALTER TABLE ONLY "public"."fathom_transcript_retry_jobs"
    ADD CONSTRAINT "fathom_transcript_retry_jobs_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."fathom_user_mappings"
    ADD CONSTRAINT "fathom_user_mappings_org_id_fathom_user_email_key" UNIQUE ("org_id", "fathom_user_email");

ALTER TABLE ONLY "public"."fathom_user_mappings"
    ADD CONSTRAINT "fathom_user_mappings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."ghost_detection_signals"
    ADD CONSTRAINT "ghost_detection_signals_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."global_topic_sources"
    ADD CONSTRAINT "global_topic_sources_global_topic_id_meeting_id_topic_index_key" UNIQUE ("global_topic_id", "meeting_id", "topic_index");

ALTER TABLE ONLY "public"."global_topic_sources"
    ADD CONSTRAINT "global_topic_sources_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."global_topics"
    ADD CONSTRAINT "global_topics_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."gmail_label_mappings"
    ADD CONSTRAINT "gmail_label_mappings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."gmail_label_mappings"
    ADD CONSTRAINT "gmail_label_mappings_user_id_category_key_key" UNIQUE ("user_id", "category_key");

ALTER TABLE ONLY "public"."google_calendar_channels"
    ADD CONSTRAINT "google_calendar_channels_channel_id_key" UNIQUE ("channel_id");

ALTER TABLE ONLY "public"."google_calendar_channels"
    ADD CONSTRAINT "google_calendar_channels_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."google_calendars"
    ADD CONSTRAINT "google_calendars_integration_id_calendar_id_key" UNIQUE ("integration_id", "calendar_id");

ALTER TABLE ONLY "public"."google_calendars"
    ADD CONSTRAINT "google_calendars_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."google_docs_templates"
    ADD CONSTRAINT "google_docs_templates_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."google_drive_folders"
    ADD CONSTRAINT "google_drive_folders_integration_id_folder_id_key" UNIQUE ("integration_id", "folder_id");

ALTER TABLE ONLY "public"."google_drive_folders"
    ADD CONSTRAINT "google_drive_folders_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."google_email_labels"
    ADD CONSTRAINT "google_email_labels_integration_id_label_id_key" UNIQUE ("integration_id", "label_id");

ALTER TABLE ONLY "public"."google_email_labels"
    ADD CONSTRAINT "google_email_labels_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."google_integrations"
    ADD CONSTRAINT "google_integrations_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."google_integrations"
    ADD CONSTRAINT "google_integrations_user_id_email_key" UNIQUE ("user_id", "email");

ALTER TABLE ONLY "public"."google_oauth_states"
    ADD CONSTRAINT "google_oauth_states_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."google_oauth_states"
    ADD CONSTRAINT "google_oauth_states_state_key" UNIQUE ("state");

ALTER TABLE ONLY "public"."google_service_logs"
    ADD CONSTRAINT "google_service_logs_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."google_task_lists"
    ADD CONSTRAINT "google_task_lists_integration_google_unique" UNIQUE ("integration_id", "google_list_id");

ALTER TABLE ONLY "public"."google_task_lists"
    ADD CONSTRAINT "google_task_lists_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."google_task_mappings"
    ADD CONSTRAINT "google_task_mappings_google_task_id_google_list_id_key" UNIQUE ("google_task_id", "google_list_id");

ALTER TABLE ONLY "public"."google_task_mappings"
    ADD CONSTRAINT "google_task_mappings_google_task_user_unique" UNIQUE ("google_task_id", "user_id");

ALTER TABLE ONLY "public"."google_task_mappings"
    ADD CONSTRAINT "google_task_mappings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."google_task_mappings"
    ADD CONSTRAINT "google_task_mappings_unique" UNIQUE ("task_id", "google_task_id", "google_list_id");

ALTER TABLE ONLY "public"."google_tasks_list_configs"
    ADD CONSTRAINT "google_tasks_list_configs_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."google_tasks_list_configs"
    ADD CONSTRAINT "google_tasks_list_configs_user_id_google_list_id_key" UNIQUE ("user_id", "google_list_id");

ALTER TABLE ONLY "public"."google_tasks_sync_conflicts"
    ADD CONSTRAINT "google_tasks_sync_conflicts_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."google_tasks_sync_status"
    ADD CONSTRAINT "google_tasks_sync_status_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."google_tasks_sync_status"
    ADD CONSTRAINT "google_tasks_sync_status_user_id_key" UNIQUE ("user_id");

ALTER TABLE ONLY "public"."hitl_pending_approvals"
    ADD CONSTRAINT "hitl_pending_approvals_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."hitl_requests"
    ADD CONSTRAINT "hitl_requests_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."http_request_recordings"
    ADD CONSTRAINT "http_request_recordings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."hubspot_oauth_states"
    ADD CONSTRAINT "hubspot_oauth_states_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."hubspot_oauth_states"
    ADD CONSTRAINT "hubspot_oauth_states_state_key" UNIQUE ("state");

ALTER TABLE ONLY "public"."hubspot_object_mappings"
    ADD CONSTRAINT "hubspot_object_mappings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."hubspot_object_mappings"
    ADD CONSTRAINT "hubspot_object_mappings_unique_hubspot" UNIQUE ("org_id", "object_type", "hubspot_id");

ALTER TABLE ONLY "public"."hubspot_object_mappings"
    ADD CONSTRAINT "hubspot_object_mappings_unique_sixty_id" UNIQUE ("org_id", "object_type", "sixty_id");

ALTER TABLE ONLY "public"."hubspot_object_mappings"
    ADD CONSTRAINT "hubspot_object_mappings_unique_sixty_key" UNIQUE ("org_id", "object_type", "sixty_key");

ALTER TABLE ONLY "public"."hubspot_org_credentials"
    ADD CONSTRAINT "hubspot_org_credentials_pkey" PRIMARY KEY ("org_id");

ALTER TABLE ONLY "public"."hubspot_org_integrations"
    ADD CONSTRAINT "hubspot_org_integrations_org_id_unique" UNIQUE ("org_id");

ALTER TABLE ONLY "public"."hubspot_org_integrations"
    ADD CONSTRAINT "hubspot_org_integrations_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."hubspot_org_integrations"
    ADD CONSTRAINT "hubspot_org_integrations_webhook_token_key" UNIQUE ("webhook_token");

ALTER TABLE ONLY "public"."hubspot_org_sync_state"
    ADD CONSTRAINT "hubspot_org_sync_state_org_id_unique" UNIQUE ("org_id");

ALTER TABLE ONLY "public"."hubspot_org_sync_state"
    ADD CONSTRAINT "hubspot_org_sync_state_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."hubspot_settings"
    ADD CONSTRAINT "hubspot_settings_pkey" PRIMARY KEY ("org_id");

ALTER TABLE ONLY "public"."hubspot_sync_queue"
    ADD CONSTRAINT "hubspot_sync_queue_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."hubspot_webhook_events"
    ADD CONSTRAINT "hubspot_webhook_events_org_event_unique" UNIQUE ("org_id", "event_id");

ALTER TABLE ONLY "public"."hubspot_webhook_events"
    ADD CONSTRAINT "hubspot_webhook_events_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."impersonation_logs"
    ADD CONSTRAINT "impersonation_logs_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."integration_alerts"
    ADD CONSTRAINT "integration_alerts_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."integration_sync_logs"
    ADD CONSTRAINT "integration_sync_logs_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."integration_test_results"
    ADD CONSTRAINT "integration_test_results_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."internal_email_domains"
    ADD CONSTRAINT "internal_email_domains_domain_key" UNIQUE ("domain");

ALTER TABLE ONLY "public"."internal_email_domains"
    ADD CONSTRAINT "internal_email_domains_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."internal_users"
    ADD CONSTRAINT "internal_users_email_key" UNIQUE ("email");

ALTER TABLE ONLY "public"."internal_users"
    ADD CONSTRAINT "internal_users_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."intervention_templates"
    ADD CONSTRAINT "intervention_templates_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."interventions"
    ADD CONSTRAINT "interventions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."justcall_integration_secrets"
    ADD CONSTRAINT "justcall_integration_secrets_pkey" PRIMARY KEY ("integration_id");

ALTER TABLE ONLY "public"."justcall_integrations"
    ADD CONSTRAINT "justcall_integrations_org_id_key" UNIQUE ("org_id");

ALTER TABLE ONLY "public"."justcall_integrations"
    ADD CONSTRAINT "justcall_integrations_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."justcall_integrations"
    ADD CONSTRAINT "justcall_integrations_webhook_token_key" UNIQUE ("webhook_token");

ALTER TABLE ONLY "public"."justcall_oauth_states"
    ADD CONSTRAINT "justcall_oauth_states_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."justcall_oauth_states"
    ADD CONSTRAINT "justcall_oauth_states_state_key" UNIQUE ("state");

ALTER TABLE ONLY "public"."launch_checklist_items"
    ADD CONSTRAINT "launch_checklist_items_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."launch_checklist_items"
    ADD CONSTRAINT "launch_checklist_items_task_id_key" UNIQUE ("task_id");

ALTER TABLE ONLY "public"."lead_events"
    ADD CONSTRAINT "lead_events_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."lead_prep_notes"
    ADD CONSTRAINT "lead_prep_notes_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."lead_sources"
    ADD CONSTRAINT "lead_sources_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."lead_sources"
    ADD CONSTRAINT "lead_sources_source_key_key" UNIQUE ("source_key");

ALTER TABLE ONLY "public"."leads"
    ADD CONSTRAINT "leads_external_id_key" UNIQUE ("external_id");

ALTER TABLE ONLY "public"."leads"
    ADD CONSTRAINT "leads_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."mcp_connections"
    ADD CONSTRAINT "mcp_connections_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."mcp_connections"
    ADD CONSTRAINT "mcp_connections_user_id_service_type_key" UNIQUE ("user_id", "service_type");

ALTER TABLE ONLY "public"."meeting_action_items"
    ADD CONSTRAINT "meeting_action_items_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meeting_aggregate_metrics"
    ADD CONSTRAINT "meeting_aggregate_metrics_org_id_period_type_period_start_key" UNIQUE ("org_id", "period_type", "period_start");

ALTER TABLE ONLY "public"."meeting_aggregate_metrics"
    ADD CONSTRAINT "meeting_aggregate_metrics_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meeting_attendees"
    ADD CONSTRAINT "meeting_attendees_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meeting_classifications"
    ADD CONSTRAINT "meeting_classifications_meeting_id_key" UNIQUE ("meeting_id");

ALTER TABLE ONLY "public"."meeting_classifications"
    ADD CONSTRAINT "meeting_classifications_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meeting_contacts"
    ADD CONSTRAINT "meeting_contacts_meeting_id_contact_id_key" UNIQUE ("meeting_id", "contact_id");

ALTER TABLE ONLY "public"."meeting_contacts"
    ADD CONSTRAINT "meeting_contacts_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meeting_content_topics"
    ADD CONSTRAINT "meeting_content_topics_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meeting_documents"
    ADD CONSTRAINT "meeting_documents_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meeting_file_search_index"
    ADD CONSTRAINT "meeting_file_search_index_meeting_id_user_id_key" UNIQUE ("meeting_id", "user_id");

ALTER TABLE ONLY "public"."meeting_file_search_index"
    ADD CONSTRAINT "meeting_file_search_index_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meeting_generated_content"
    ADD CONSTRAINT "meeting_generated_content_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meeting_index_queue"
    ADD CONSTRAINT "meeting_index_queue_meeting_id_key" UNIQUE ("meeting_id");

ALTER TABLE ONLY "public"."meeting_index_queue"
    ADD CONSTRAINT "meeting_index_queue_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meeting_intelligence_queries"
    ADD CONSTRAINT "meeting_intelligence_queries_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meeting_metrics"
    ADD CONSTRAINT "meeting_metrics_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meeting_scorecards"
    ADD CONSTRAINT "meeting_scorecards_meeting_id_key" UNIQUE ("meeting_id");

ALTER TABLE ONLY "public"."meeting_scorecards"
    ADD CONSTRAINT "meeting_scorecards_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meeting_structured_summaries"
    ADD CONSTRAINT "meeting_structured_summaries_meeting_id_key" UNIQUE ("meeting_id");

ALTER TABLE ONLY "public"."meeting_structured_summaries"
    ADD CONSTRAINT "meeting_structured_summaries_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meeting_topics"
    ADD CONSTRAINT "meeting_topics_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meeting_workflow_results"
    ADD CONSTRAINT "meeting_workflow_results_meeting_id_key" UNIQUE ("meeting_id");

ALTER TABLE ONLY "public"."meeting_workflow_results"
    ADD CONSTRAINT "meeting_workflow_results_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meetingbaas_calendars"
    ADD CONSTRAINT "meetingbaas_calendars_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meetingbaas_calendars"
    ADD CONSTRAINT "meetingbaas_calendars_user_id_raw_calendar_id_key" UNIQUE ("user_id", "raw_calendar_id");

ALTER TABLE ONLY "public"."meetings"
    ADD CONSTRAINT "meetings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meetings_waitlist"
    ADD CONSTRAINT "meetings_waitlist_email_key" UNIQUE ("email");

ALTER TABLE ONLY "public"."meetings_waitlist"
    ADD CONSTRAINT "meetings_waitlist_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."meetings_waitlist"
    ADD CONSTRAINT "meetings_waitlist_referral_code_key" UNIQUE ("referral_code");

ALTER TABLE ONLY "public"."next_action_suggestions"
    ADD CONSTRAINT "next_action_suggestions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."node_executions"
    ADD CONSTRAINT "node_executions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."node_fixtures"
    ADD CONSTRAINT "node_fixtures_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."node_fixtures"
    ADD CONSTRAINT "node_fixtures_workflow_id_node_id_fixture_name_environment_key" UNIQUE ("workflow_id", "node_id", "fixture_name", "environment");

ALTER TABLE ONLY "public"."notetaker_user_settings"
    ADD CONSTRAINT "notetaker_user_settings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."notetaker_user_settings"
    ADD CONSTRAINT "notetaker_user_settings_user_id_org_id_key" UNIQUE ("user_id", "org_id");

ALTER TABLE ONLY "public"."notification_feedback"
    ADD CONSTRAINT "notification_feedback_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."notification_interactions"
    ADD CONSTRAINT "notification_interactions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."notification_queue"
    ADD CONSTRAINT "notification_queue_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."notification_rate_limits"
    ADD CONSTRAINT "notification_rate_limits_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."org_ai_preferences"
    ADD CONSTRAINT "org_ai_preferences_org_id_key" UNIQUE ("org_id");

ALTER TABLE ONLY "public"."org_ai_preferences"
    ADD CONSTRAINT "org_ai_preferences_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."org_call_types"
    ADD CONSTRAINT "org_call_types_org_id_name_key" UNIQUE ("org_id", "name");

ALTER TABLE ONLY "public"."org_call_types"
    ADD CONSTRAINT "org_call_types_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."org_email_categorization_settings"
    ADD CONSTRAINT "org_email_categorization_settings_org_id_key" UNIQUE ("org_id");

ALTER TABLE ONLY "public"."org_email_categorization_settings"
    ADD CONSTRAINT "org_email_categorization_settings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."org_file_search_stores"
    ADD CONSTRAINT "org_file_search_stores_org_id_key" UNIQUE ("org_id");

ALTER TABLE ONLY "public"."org_file_search_stores"
    ADD CONSTRAINT "org_file_search_stores_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."org_proposal_workflows"
    ADD CONSTRAINT "org_proposal_workflows_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."org_proposal_workflows"
    ADD CONSTRAINT "org_proposal_workflows_unique_name" UNIQUE ("org_id", "name");

ALTER TABLE ONLY "public"."organization_context"
    ADD CONSTRAINT "organization_context_organization_id_context_key_key" UNIQUE ("organization_id", "context_key");

ALTER TABLE ONLY "public"."organization_context"
    ADD CONSTRAINT "organization_context_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."organization_enrichment"
    ADD CONSTRAINT "organization_enrichment_organization_id_key" UNIQUE ("organization_id");

ALTER TABLE ONLY "public"."organization_enrichment"
    ADD CONSTRAINT "organization_enrichment_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."organization_feature_flags"
    ADD CONSTRAINT "organization_feature_flags_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."organization_invitations"
    ADD CONSTRAINT "organization_invitations_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."organization_invitations"
    ADD CONSTRAINT "organization_invitations_token_key" UNIQUE ("token");

ALTER TABLE ONLY "public"."organization_memberships"
    ADD CONSTRAINT "organization_memberships_pkey" PRIMARY KEY ("org_id", "user_id");

ALTER TABLE ONLY "public"."organization_skills_history"
    ADD CONSTRAINT "organization_skills_history_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."organization_skills"
    ADD CONSTRAINT "organization_skills_organization_id_skill_id_key" UNIQUE ("organization_id", "skill_id");

ALTER TABLE ONLY "public"."organization_skills"
    ADD CONSTRAINT "organization_skills_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."organization_subscriptions"
    ADD CONSTRAINT "organization_subscriptions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."organization_subscriptions"
    ADD CONSTRAINT "organization_subscriptions_stripe_subscription_id_key" UNIQUE ("stripe_subscription_id");

ALTER TABLE ONLY "public"."organization_usage"
    ADD CONSTRAINT "organization_usage_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."organizations"
    ADD CONSTRAINT "organizations_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."page_views"
    ADD CONSTRAINT "page_views_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."partial_signups"
    ADD CONSTRAINT "partial_signups_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."pipeline_automation_log"
    ADD CONSTRAINT "pipeline_automation_log_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."pipeline_automation_rules"
    ADD CONSTRAINT "pipeline_automation_rules_org_id_name_key" UNIQUE ("org_id", "name");

ALTER TABLE ONLY "public"."pipeline_automation_rules"
    ADD CONSTRAINT "pipeline_automation_rules_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."pipeline_stage_recommendations"
    ADD CONSTRAINT "pipeline_stage_recommendations_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."platform_skills_history"
    ADD CONSTRAINT "platform_skills_history_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."platform_skills"
    ADD CONSTRAINT "platform_skills_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."platform_skills"
    ADD CONSTRAINT "platform_skills_skill_key_key" UNIQUE ("skill_key");

ALTER TABLE ONLY "public"."pricing_plans"
    ADD CONSTRAINT "pricing_plans_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."process_map_coverage_snapshots"
    ADD CONSTRAINT "process_map_coverage_snapshots_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."process_map_fixtures"
    ADD CONSTRAINT "process_map_fixtures_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."process_map_mocks"
    ADD CONSTRAINT "process_map_mocks_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."process_map_scenario_runs"
    ADD CONSTRAINT "process_map_scenario_runs_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."process_map_step_results"
    ADD CONSTRAINT "process_map_step_results_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."process_map_test_runs"
    ADD CONSTRAINT "process_map_test_runs_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."process_map_test_scenarios"
    ADD CONSTRAINT "process_map_test_scenarios_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."process_map_workflows"
    ADD CONSTRAINT "process_map_workflows_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."process_map_workflows"
    ADD CONSTRAINT "process_map_workflows_process_map_id_version_key" UNIQUE ("process_map_id", "version");

ALTER TABLE ONLY "public"."process_maps"
    ADD CONSTRAINT "process_maps_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_clerk_user_id_key" UNIQUE ("clerk_user_id");

ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_email_key" UNIQUE ("email");

ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."proposal_jobs"
    ADD CONSTRAINT "proposal_jobs_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."proposal_templates"
    ADD CONSTRAINT "proposal_templates_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."proposals"
    ADD CONSTRAINT "proposals_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."proposals"
    ADD CONSTRAINT "proposals_share_token_key" UNIQUE ("share_token");

ALTER TABLE ONLY "public"."rate_limit"
    ADD CONSTRAINT "rate_limit_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."recording_rules"
    ADD CONSTRAINT "recording_rules_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."recording_usage"
    ADD CONSTRAINT "recording_usage_org_id_period_start_key" UNIQUE ("org_id", "period_start");

ALTER TABLE ONLY "public"."recording_usage"
    ADD CONSTRAINT "recording_usage_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."recordings"
    ADD CONSTRAINT "recordings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."reengagement_log"
    ADD CONSTRAINT "reengagement_log_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."relationship_health_history"
    ADD CONSTRAINT "relationship_health_history_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."relationship_health_scores"
    ADD CONSTRAINT "relationship_health_scores_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."relationship_health_scores"
    ADD CONSTRAINT "relationship_health_scores_user_id_relationship_type_contac_key" UNIQUE ("user_id", "relationship_type", "contact_id", "company_id");

ALTER TABLE ONLY "public"."roadmap_comments"
    ADD CONSTRAINT "roadmap_comments_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."roadmap_suggestions"
    ADD CONSTRAINT "roadmap_suggestions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."roadmap_suggestions"
    ADD CONSTRAINT "roadmap_suggestions_ticket_id_key" UNIQUE ("ticket_id");

ALTER TABLE ONLY "public"."roadmap_votes"
    ADD CONSTRAINT "roadmap_votes_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."roadmap_votes"
    ADD CONSTRAINT "roadmap_votes_suggestion_id_user_id_key" UNIQUE ("suggestion_id", "user_id");

ALTER TABLE ONLY "public"."savvycal_integration_secrets"
    ADD CONSTRAINT "savvycal_integration_secrets_pkey" PRIMARY KEY ("integration_id");

ALTER TABLE ONLY "public"."savvycal_integrations"
    ADD CONSTRAINT "savvycal_integrations_org_id_unique" UNIQUE ("org_id");

ALTER TABLE ONLY "public"."savvycal_integrations"
    ADD CONSTRAINT "savvycal_integrations_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."savvycal_integrations"
    ADD CONSTRAINT "savvycal_integrations_webhook_token_key" UNIQUE ("webhook_token");

ALTER TABLE ONLY "public"."savvycal_link_mappings"
    ADD CONSTRAINT "savvycal_link_mappings_link_id_key" UNIQUE ("link_id");

ALTER TABLE ONLY "public"."savvycal_link_mappings"
    ADD CONSTRAINT "savvycal_link_mappings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."savvycal_source_mappings"
    ADD CONSTRAINT "savvycal_source_mappings_link_id_org_id_key" UNIQUE ("link_id", "org_id");

ALTER TABLE ONLY "public"."savvycal_source_mappings"
    ADD CONSTRAINT "savvycal_source_mappings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."scenario_fixtures"
    ADD CONSTRAINT "scenario_fixtures_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."scenario_fixtures"
    ADD CONSTRAINT "scenario_fixtures_workflow_id_scenario_name_key" UNIQUE ("workflow_id", "scenario_name");

ALTER TABLE ONLY "public"."sentiment_alerts"
    ADD CONSTRAINT "sentiment_alerts_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."sentry_bridge_config"
    ADD CONSTRAINT "sentry_bridge_config_org_unique" UNIQUE ("org_id");

ALTER TABLE ONLY "public"."sentry_bridge_config"
    ADD CONSTRAINT "sentry_bridge_config_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."sentry_bridge_metrics"
    ADD CONSTRAINT "sentry_bridge_metrics_bucket" UNIQUE ("org_id", "bucket_start");

ALTER TABLE ONLY "public"."sentry_bridge_metrics"
    ADD CONSTRAINT "sentry_bridge_metrics_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."sentry_bridge_queue"
    ADD CONSTRAINT "sentry_bridge_queue_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."sentry_dead_letter_queue"
    ADD CONSTRAINT "sentry_dead_letter_queue_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."sentry_issue_mappings"
    ADD CONSTRAINT "sentry_issue_mappings_dedupe" UNIQUE ("org_id", "sentry_issue_id");

ALTER TABLE ONLY "public"."sentry_issue_mappings"
    ADD CONSTRAINT "sentry_issue_mappings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."sentry_routing_rules"
    ADD CONSTRAINT "sentry_routing_rules_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."sentry_triage_queue"
    ADD CONSTRAINT "sentry_triage_queue_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."sentry_webhook_events"
    ADD CONSTRAINT "sentry_webhook_events_dedupe" UNIQUE ("event_dedupe_key");

ALTER TABLE ONLY "public"."sentry_webhook_events"
    ADD CONSTRAINT "sentry_webhook_events_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."sentry_webhook_queue"
    ADD CONSTRAINT "sentry_webhook_queue_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."sequence_executions"
    ADD CONSTRAINT "sequence_executions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."sequence_hitl_requests"
    ADD CONSTRAINT "sequence_hitl_requests_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."sequence_references_archive"
    ADD CONSTRAINT "sequence_references_archive_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."sequence_token_budgets"
    ADD CONSTRAINT "sequence_token_budgets_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."skill_output_storage"
    ADD CONSTRAINT "skill_output_storage_organization_id_path_key" UNIQUE ("organization_id", "path");

ALTER TABLE ONLY "public"."skill_output_storage"
    ADD CONSTRAINT "skill_output_storage_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."slack_channels"
    ADD CONSTRAINT "slack_channels_integration_id_channel_id_key" UNIQUE ("integration_id", "channel_id");

ALTER TABLE ONLY "public"."slack_channels"
    ADD CONSTRAINT "slack_channels_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."slack_deal_rooms"
    ADD CONSTRAINT "slack_deal_rooms_deal_id_key" UNIQUE ("deal_id");

ALTER TABLE ONLY "public"."slack_deal_rooms"
    ADD CONSTRAINT "slack_deal_rooms_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."slack_integrations"
    ADD CONSTRAINT "slack_integrations_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."slack_integrations"
    ADD CONSTRAINT "slack_integrations_user_id_team_id_key" UNIQUE ("user_id", "team_id");

ALTER TABLE ONLY "public"."slack_notification_settings"
    ADD CONSTRAINT "slack_notification_settings_org_id_feature_key" UNIQUE ("org_id", "feature");

ALTER TABLE ONLY "public"."slack_notification_settings"
    ADD CONSTRAINT "slack_notification_settings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."slack_notifications_sent"
    ADD CONSTRAINT "slack_notifications_sent_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."slack_org_settings"
    ADD CONSTRAINT "slack_org_settings_org_id_key" UNIQUE ("org_id");

ALTER TABLE ONLY "public"."slack_org_settings"
    ADD CONSTRAINT "slack_org_settings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."slack_user_mappings"
    ADD CONSTRAINT "slack_user_mappings_org_id_slack_user_id_key" UNIQUE ("org_id", "slack_user_id");

ALTER TABLE ONLY "public"."slack_user_mappings"
    ADD CONSTRAINT "slack_user_mappings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."smart_task_templates"
    ADD CONSTRAINT "smart_task_templates_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."smart_task_templates"
    ADD CONSTRAINT "smart_task_templates_trigger_activity_type_task_title_key" UNIQUE ("trigger_activity_type", "task_title");

ALTER TABLE ONLY "public"."solutions"
    ADD CONSTRAINT "solutions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."stages"
    ADD CONSTRAINT "stages_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."subscription_plans"
    ADD CONSTRAINT "subscription_plans_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."subscription_plans"
    ADD CONSTRAINT "subscription_plans_slug_key" UNIQUE ("slug");

ALTER TABLE ONLY "public"."subscription_seat_usage"
    ADD CONSTRAINT "subscription_seat_usage_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."system_config"
    ADD CONSTRAINT "system_config_pkey" PRIMARY KEY ("key");

ALTER TABLE ONLY "public"."targets"
    ADD CONSTRAINT "targets_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."task_notifications"
    ADD CONSTRAINT "task_notifications_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."tasks"
    ADD CONSTRAINT "tasks_google_task_id_user_unique" UNIQUE ("google_task_id", "assigned_to");

ALTER TABLE ONLY "public"."tasks"
    ADD CONSTRAINT "tasks_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."team_members"
    ADD CONSTRAINT "team_members_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."team_members"
    ADD CONSTRAINT "team_members_team_id_user_id_key" UNIQUE ("team_id", "user_id");

ALTER TABLE ONLY "public"."teams"
    ADD CONSTRAINT "teams_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."topic_aggregation_queue"
    ADD CONSTRAINT "topic_aggregation_queue_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."topic_aggregation_queue"
    ADD CONSTRAINT "topic_aggregation_queue_user_id_meeting_id_topic_index_key" UNIQUE ("user_id", "meeting_id", "topic_index");

ALTER TABLE ONLY "public"."organization_subscriptions"
    ADD CONSTRAINT "unique_active_subscription" UNIQUE ("org_id");

ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "unique_deal_conversion" UNIQUE ("deal_id");

ALTER TABLE ONLY "public"."organization_feature_flags"
    ADD CONSTRAINT "unique_org_feature" UNIQUE ("org_id", "feature_key");

ALTER TABLE ONLY "public"."organization_usage"
    ADD CONSTRAINT "unique_org_period" UNIQUE ("org_id", "period_start");

ALTER TABLE ONLY "public"."organization_invitations"
    ADD CONSTRAINT "unique_pending_invitation" UNIQUE NULLS NOT DISTINCT ("org_id", "email", "accepted_at");

ALTER TABLE ONLY "public"."billing_event_log"
    ADD CONSTRAINT "unique_provider_event" UNIQUE ("provider", "provider_event_id");

ALTER TABLE ONLY "public"."subscription_seat_usage"
    ADD CONSTRAINT "unique_subscription_period" UNIQUE ("subscription_id", "period_start");

ALTER TABLE ONLY "public"."usage_events"
    ADD CONSTRAINT "usage_events_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_activation_events"
    ADD CONSTRAINT "user_activation_events_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_activity_events"
    ADD CONSTRAINT "user_activity_events_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_ai_feature_settings"
    ADD CONSTRAINT "user_ai_feature_settings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_ai_feature_settings"
    ADD CONSTRAINT "user_ai_feature_settings_user_id_feature_key_key" UNIQUE ("user_id", "feature_key");

ALTER TABLE ONLY "public"."user_ai_preferences"
    ADD CONSTRAINT "user_ai_preferences_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_ai_preferences"
    ADD CONSTRAINT "user_ai_preferences_user_id_key" UNIQUE ("user_id");

ALTER TABLE ONLY "public"."user_automation_rules"
    ADD CONSTRAINT "user_automation_rules_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_coaching_preferences"
    ADD CONSTRAINT "user_coaching_preferences_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_coaching_preferences"
    ADD CONSTRAINT "user_coaching_preferences_user_id_is_active_key" UNIQUE ("user_id", "is_active");

ALTER TABLE ONLY "public"."user_engagement_metrics"
    ADD CONSTRAINT "user_engagement_metrics_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_file_search_stores"
    ADD CONSTRAINT "user_file_search_stores_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_file_search_stores"
    ADD CONSTRAINT "user_file_search_stores_user_id_key" UNIQUE ("user_id");

ALTER TABLE ONLY "public"."user_notifications"
    ADD CONSTRAINT "user_notifications_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_onboarding_progress"
    ADD CONSTRAINT "user_onboarding_progress_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_onboarding_progress"
    ADD CONSTRAINT "user_onboarding_progress_user_id_key" UNIQUE ("user_id");

ALTER TABLE ONLY "public"."user_preferences"
    ADD CONSTRAINT "user_preferences_pkey" PRIMARY KEY ("user_id");

ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_email_key" UNIQUE ("email");

ALTER TABLE ONLY "public"."user_profiles"
    ADD CONSTRAINT "user_profiles_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_name_key" UNIQUE ("name");

ALTER TABLE ONLY "public"."user_roles"
    ADD CONSTRAINT "user_roles_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_settings"
    ADD CONSTRAINT "user_settings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_settings"
    ADD CONSTRAINT "user_settings_user_id_key" UNIQUE ("user_id");

ALTER TABLE ONLY "public"."user_sync_status"
    ADD CONSTRAINT "user_sync_status_pkey" PRIMARY KEY ("user_id");

ALTER TABLE ONLY "public"."user_tone_settings"
    ADD CONSTRAINT "user_tone_settings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."user_tone_settings"
    ADD CONSTRAINT "user_tone_settings_user_id_content_type_key" UNIQUE ("user_id", "content_type");

ALTER TABLE ONLY "public"."user_writing_styles"
    ADD CONSTRAINT "user_writing_styles_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."variable_storage"
    ADD CONSTRAINT "variable_storage_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."voice_recordings"
    ADD CONSTRAINT "voice_recordings_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."voice_recordings"
    ADD CONSTRAINT "voice_recordings_share_token_key" UNIQUE ("share_token");

ALTER TABLE ONLY "public"."vsl_video_analytics"
    ADD CONSTRAINT "vsl_video_analytics_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."waitlist_admin_actions"
    ADD CONSTRAINT "waitlist_admin_actions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."waitlist_email_invites"
    ADD CONSTRAINT "waitlist_email_invites_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."waitlist_email_templates"
    ADD CONSTRAINT "waitlist_email_templates_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."waitlist_invite_codes"
    ADD CONSTRAINT "waitlist_invite_codes_code_key" UNIQUE ("code");

ALTER TABLE ONLY "public"."waitlist_invite_codes"
    ADD CONSTRAINT "waitlist_invite_codes_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."waitlist_onboarding_progress"
    ADD CONSTRAINT "waitlist_onboarding_progress_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."waitlist_onboarding_progress"
    ADD CONSTRAINT "waitlist_onboarding_progress_user_id_key" UNIQUE ("user_id");

ALTER TABLE ONLY "public"."waitlist_shares"
    ADD CONSTRAINT "waitlist_shares_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."webhook_events"
    ADD CONSTRAINT "webhook_events_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."webhook_mirror_config"
    ADD CONSTRAINT "webhook_mirror_config_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."webhook_mirror_config"
    ADD CONSTRAINT "webhook_mirror_config_workflow_id_source_environment_target_key" UNIQUE ("workflow_id", "source_environment", "target_environment");

ALTER TABLE ONLY "public"."workflow_batch_windows"
    ADD CONSTRAINT "workflow_batch_windows_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."workflow_batch_windows"
    ADD CONSTRAINT "workflow_batch_windows_workflow_id_node_id_key" UNIQUE ("workflow_id", "node_id");

ALTER TABLE ONLY "public"."workflow_circuit_breakers"
    ADD CONSTRAINT "workflow_circuit_breakers_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."workflow_circuit_breakers"
    ADD CONSTRAINT "workflow_circuit_breakers_workflow_id_node_id_key" UNIQUE ("workflow_id", "node_id");

ALTER TABLE ONLY "public"."workflow_contracts"
    ADD CONSTRAINT "workflow_contracts_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."workflow_contracts"
    ADD CONSTRAINT "workflow_contracts_workflow_id_node_id_version_key" UNIQUE ("workflow_id", "node_id", "version");

ALTER TABLE ONLY "public"."workflow_dead_letter_queue"
    ADD CONSTRAINT "workflow_dead_letter_queue_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."workflow_environment_promotions"
    ADD CONSTRAINT "workflow_environment_promotions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."workflow_environments"
    ADD CONSTRAINT "workflow_environments_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."workflow_environments"
    ADD CONSTRAINT "workflow_environments_workflow_id_environment_key" UNIQUE ("workflow_id", "environment");

ALTER TABLE ONLY "public"."workflow_executions"
    ADD CONSTRAINT "workflow_executions_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."workflow_forms"
    ADD CONSTRAINT "workflow_forms_form_id_key" UNIQUE ("form_id");

ALTER TABLE ONLY "public"."workflow_forms"
    ADD CONSTRAINT "workflow_forms_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."workflow_idempotency_keys"
    ADD CONSTRAINT "workflow_idempotency_keys_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."workflow_idempotency_keys"
    ADD CONSTRAINT "workflow_idempotency_keys_workflow_id_idempotency_key_key" UNIQUE ("workflow_id", "idempotency_key");

ALTER TABLE ONLY "public"."workflow_mcp_logs"
    ADD CONSTRAINT "workflow_mcp_logs_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."workflow_rate_limits"
    ADD CONSTRAINT "workflow_rate_limits_pkey" PRIMARY KEY ("id");

ALTER TABLE ONLY "public"."workflow_rate_limits"
    ADD CONSTRAINT "workflow_rate_limits_workflow_id_node_id_limit_key_key" UNIQUE ("workflow_id", "node_id", "limit_key");

CREATE INDEX "activities_client_name_idx" ON "public"."activities" USING "btree" ("client_name");

CREATE INDEX "activities_date_idx" ON "public"."activities" USING "btree" ("date");

CREATE INDEX "activities_deal_id_idx" ON "public"."activities" USING "btree" ("deal_id");

CREATE INDEX "activities_quantity_idx" ON "public"."activities" USING "btree" ("quantity");

CREATE INDEX "activities_sales_rep_idx" ON "public"."activities" USING "btree" ("sales_rep");

CREATE INDEX "activities_type_idx" ON "public"."activities" USING "btree" ("type");

CREATE INDEX "audit_logs_action_idx" ON "public"."audit_logs" USING "btree" ("action");

CREATE INDEX "audit_logs_changed_at_idx" ON "public"."audit_logs" USING "btree" ("changed_at" DESC);

CREATE INDEX "audit_logs_record_id_idx" ON "public"."audit_logs" USING "btree" ("record_id");

CREATE INDEX "audit_logs_table_name_idx" ON "public"."audit_logs" USING "btree" ("table_name");

CREATE UNIQUE INDEX "audit_logs_unique_idx" ON "public"."audit_logs" USING "btree" ("table_name", "record_id", "changed_at", "id");

CREATE INDEX "audit_logs_user_id_idx" ON "public"."audit_logs" USING "btree" ("user_id");

CREATE UNIQUE INDEX "hubspot_object_mappings_unique_sixty_id_not_null" ON "public"."hubspot_object_mappings" USING "btree" ("org_id", "object_type", "sixty_id") WHERE ("sixty_id" IS NOT NULL);

CREATE UNIQUE INDEX "hubspot_object_mappings_unique_sixty_key_not_null" ON "public"."hubspot_object_mappings" USING "btree" ("org_id", "object_type", "sixty_key") WHERE ("sixty_key" IS NOT NULL);

CREATE INDEX "idx_action_items_assignee_id" ON "public"."action_items" USING "btree" ("assignee_id");

CREATE INDEX "idx_action_items_contact_id" ON "public"."action_items" USING "btree" ("contact_id");

CREATE INDEX "idx_action_items_deal_id" ON "public"."action_items" USING "btree" ("deal_id");

CREATE INDEX "idx_action_items_meeting_id" ON "public"."action_items" USING "btree" ("meeting_id");

CREATE INDEX "idx_action_items_user_id" ON "public"."action_items" USING "btree" ("user_id");

CREATE INDEX "idx_activation_events_created_at" ON "public"."user_activation_events" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_activation_events_org_id" ON "public"."user_activation_events" USING "btree" ("org_id");

CREATE INDEX "idx_activation_events_type" ON "public"."user_activation_events" USING "btree" ("event_type");

CREATE INDEX "idx_activation_events_user_id" ON "public"."user_activation_events" USING "btree" ("user_id");

CREATE INDEX "idx_activities_company_fk" ON "public"."activities" USING "btree" ("company_id");

CREATE INDEX "idx_activities_contact_fk" ON "public"."activities" USING "btree" ("contact_id");

CREATE INDEX "idx_activities_deal_meeting_lookup" ON "public"."activities" USING "btree" ("deal_id", "meeting_id") WHERE (("deal_id" IS NOT NULL) AND ("meeting_id" IS NOT NULL));

CREATE INDEX "idx_activities_meeting_id" ON "public"."activities" USING "btree" ("meeting_id");

CREATE UNIQUE INDEX "idx_activities_meeting_user_type_unique" ON "public"."activities" USING "btree" ("meeting_id", "user_id", "type") WHERE ("meeting_id" IS NOT NULL);

COMMENT ON INDEX "public"."idx_activities_meeting_user_type_unique" IS 'Prevents duplicate activities for the same meeting - one activity per (meeting_id, user_id, type) combination';

CREATE INDEX "idx_activities_original_activity_id" ON "public"."activities" USING "btree" ("original_activity_id");

CREATE INDEX "idx_activities_owner_id" ON "public"."activities" USING "btree" ("owner_id");

CREATE INDEX "idx_activities_type_processed" ON "public"."activities" USING "btree" ("type", "is_processed");

CREATE INDEX "idx_activities_user_id" ON "public"."activities" USING "btree" ("user_id");

CREATE INDEX "idx_activity_sync_rules_owner_fk" ON "public"."activity_sync_rules" USING "btree" ("owner_id");

CREATE INDEX "idx_admin_actions_admin_id" ON "public"."waitlist_admin_actions" USING "btree" ("admin_user_id");

CREATE INDEX "idx_admin_actions_created" ON "public"."waitlist_admin_actions" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_admin_actions_entry_id" ON "public"."waitlist_admin_actions" USING "btree" ("waitlist_entry_id");

CREATE INDEX "idx_admin_actions_type" ON "public"."waitlist_admin_actions" USING "btree" ("action_type");

CREATE INDEX "idx_ai_cost_events_org_id" ON "public"."ai_cost_events" USING "btree" ("org_id");

CREATE INDEX "idx_ai_cost_events_user_fk" ON "public"."ai_cost_events" USING "btree" ("user_id");

CREATE INDEX "idx_ai_feedback_action" ON "public"."ai_feedback" USING "btree" ("action");

CREATE INDEX "idx_ai_feedback_action_type" ON "public"."ai_feedback" USING "btree" ("action_type");

CREATE INDEX "idx_ai_feedback_created_at" ON "public"."ai_feedback" USING "btree" ("created_at");

CREATE INDEX "idx_ai_feedback_org_id" ON "public"."ai_feedback" USING "btree" ("org_id");

CREATE INDEX "idx_ai_feedback_suggestion_id" ON "public"."ai_feedback" USING "btree" ("suggestion_id");

CREATE INDEX "idx_ai_feedback_user_action_date" ON "public"."ai_feedback" USING "btree" ("user_id", "action", "created_at" DESC);

CREATE INDEX "idx_ai_feedback_user_id" ON "public"."ai_feedback" USING "btree" ("user_id");

CREATE INDEX "idx_ai_insights_contact_id" ON "public"."ai_insights" USING "btree" ("contact_id");

CREATE INDEX "idx_ai_insights_deal_id" ON "public"."ai_insights" USING "btree" ("deal_id");

CREATE INDEX "idx_ai_insights_user_id" ON "public"."ai_insights" USING "btree" ("user_id");

CREATE INDEX "idx_ai_prompt_template_history_created_by" ON "public"."ai_prompt_template_history" USING "btree" ("created_by");

CREATE INDEX "idx_ai_prompt_template_history_template" ON "public"."ai_prompt_template_history" USING "btree" ("template_id", "version" DESC);

CREATE INDEX "idx_ai_prompt_templates_category" ON "public"."ai_prompt_templates" USING "btree" ("category");

CREATE INDEX "idx_ai_prompt_templates_created_by" ON "public"."ai_prompt_templates" USING "btree" ("created_by");

CREATE INDEX "idx_ai_prompt_templates_org_category" ON "public"."ai_prompt_templates" USING "btree" ("organization_id", "category");

CREATE INDEX "idx_ai_prompt_templates_public_category" ON "public"."ai_prompt_templates" USING "btree" ("is_public", "category") WHERE ("is_public" = true);

CREATE INDEX "idx_ai_prompt_templates_user_category" ON "public"."ai_prompt_templates" USING "btree" ("user_id", "category");

CREATE INDEX "idx_ai_usage_logs_user_id" ON "public"."ai_usage_logs" USING "btree" ("user_id");

CREATE INDEX "idx_api_key_usage_api_key_id" ON "public"."api_key_usage" USING "btree" ("api_key_id");

CREATE INDEX "idx_api_keys_user_id" ON "public"."api_keys" USING "btree" ("user_id");

CREATE INDEX "idx_api_monitor_improvements_shipped_at" ON "public"."api_monitor_improvements" USING "btree" ("shipped_at" DESC);

CREATE INDEX "idx_api_monitor_rollups_date" ON "public"."api_monitor_rollups_daily" USING "btree" ("date" DESC);

CREATE INDEX "idx_api_monitor_rollups_total" ON "public"."api_monitor_rollups_daily" USING "btree" ("date" DESC) WHERE ("user_id" IS NULL);

CREATE INDEX "idx_api_monitor_rollups_user_date" ON "public"."api_monitor_rollups_daily" USING "btree" ("user_id", "date" DESC);

CREATE INDEX "idx_api_monitor_snapshots_snapshot_time" ON "public"."api_monitor_snapshots" USING "btree" ("snapshot_time" DESC);

CREATE INDEX "idx_api_monitor_snapshots_source" ON "public"."api_monitor_snapshots" USING "btree" ("source");

CREATE INDEX "idx_api_monitor_snapshots_time_bucket" ON "public"."api_monitor_snapshots" USING "btree" ("time_bucket_start" DESC, "bucket_type");

CREATE INDEX "idx_api_requests_api_key_id" ON "public"."api_requests" USING "btree" ("api_key_id");

CREATE INDEX "idx_api_requests_user_fk" ON "public"."api_requests" USING "btree" ("user_id");

CREATE INDEX "idx_app_settings_updated_at" ON "public"."app_settings" USING "btree" ("updated_at");

CREATE INDEX "idx_automation_executions_activity_id" ON "public"."automation_executions" USING "btree" ("activity_id");

CREATE INDEX "idx_automation_executions_deal_id" ON "public"."automation_executions" USING "btree" ("deal_id");

CREATE INDEX "idx_automation_executions_executed_by_fk" ON "public"."automation_executions" USING "btree" ("executed_by");

CREATE INDEX "idx_automation_executions_task_fk" ON "public"."automation_executions" USING "btree" ("task_id");

CREATE INDEX "idx_billing_event_log_event_type" ON "public"."billing_event_log" USING "btree" ("event_type");

CREATE INDEX "idx_billing_event_log_occurred_at" ON "public"."billing_event_log" USING "btree" ("occurred_at");

CREATE INDEX "idx_billing_event_log_org_id" ON "public"."billing_event_log" USING "btree" ("org_id");

CREATE INDEX "idx_billing_event_log_org_type_date" ON "public"."billing_event_log" USING "btree" ("org_id", "event_type", "occurred_at");

CREATE INDEX "idx_billing_event_log_processed_at" ON "public"."billing_event_log" USING "btree" ("processed_at") WHERE ("processed_at" IS NULL);

CREATE INDEX "idx_billing_event_log_provider" ON "public"."billing_event_log" USING "btree" ("provider");

CREATE INDEX "idx_billing_history_org_id" ON "public"."billing_history" USING "btree" ("org_id");

CREATE INDEX "idx_billing_history_subscription_id" ON "public"."billing_history" USING "btree" ("subscription_id");

CREATE INDEX "idx_bot_deployments_bot" ON "public"."bot_deployments" USING "btree" ("bot_id");

CREATE INDEX "idx_bot_deployments_org" ON "public"."bot_deployments" USING "btree" ("org_id");

CREATE INDEX "idx_bot_deployments_recording" ON "public"."bot_deployments" USING "btree" ("recording_id");

CREATE INDEX "idx_bot_deployments_status" ON "public"."bot_deployments" USING "btree" ("status");

CREATE INDEX "idx_branding_settings_created_by_fk" ON "public"."branding_settings" USING "btree" ("created_by");

CREATE UNIQUE INDEX "idx_branding_settings_org_unique" ON "public"."branding_settings" USING "btree" ("org_id") WHERE ("org_id" IS NOT NULL);

CREATE INDEX "idx_calendar_attendees_event_fk" ON "public"."calendar_attendees" USING "btree" ("event_id");

CREATE INDEX "idx_calendar_calendars_org" ON "public"."calendar_calendars" USING "btree" ("org_id");

CREATE INDEX "idx_calendar_calendars_user_fk" ON "public"."calendar_calendars" USING "btree" ("user_id");

CREATE INDEX "idx_calendar_channels_active" ON "public"."google_calendar_channels" USING "btree" ("is_active", "expiration_time") WHERE ("is_active" = true);

CREATE INDEX "idx_calendar_channels_channel_id" ON "public"."google_calendar_channels" USING "btree" ("channel_id");

CREATE INDEX "idx_calendar_channels_message_number" ON "public"."google_calendar_channels" USING "btree" ("last_message_number");

CREATE INDEX "idx_calendar_channels_org" ON "public"."google_calendar_channels" USING "btree" ("org_id");

CREATE INDEX "idx_calendar_channels_user" ON "public"."google_calendar_channels" USING "btree" ("user_id");

CREATE INDEX "idx_calendar_events_attendees" ON "public"."calendar_events" USING "gin" ("attendees");

CREATE INDEX "idx_calendar_events_auto_join" ON "public"."calendar_events" USING "btree" ("org_id", "start_time") WHERE ("meeting_url" IS NOT NULL);

CREATE INDEX "idx_calendar_events_calendar_id" ON "public"."calendar_events" USING "btree" ("calendar_id");

CREATE INDEX "idx_calendar_events_company_id" ON "public"."calendar_events" USING "btree" ("company_id") WHERE ("company_id" IS NOT NULL);

CREATE INDEX "idx_calendar_events_contact_id" ON "public"."calendar_events" USING "btree" ("contact_id") WHERE ("contact_id" IS NOT NULL);

CREATE INDEX "idx_calendar_events_mcp_connection_fk" ON "public"."calendar_events" USING "btree" ("mcp_connection_id");

CREATE INDEX "idx_calendar_events_start_time" ON "public"."calendar_events" USING "btree" ("start_time");

CREATE INDEX "idx_calendar_events_upcoming_with_url" ON "public"."calendar_events" USING "btree" ("org_id", "start_time") WHERE ("meeting_url" IS NOT NULL);

CREATE INDEX "idx_calendar_events_user_date_range" ON "public"."calendar_events" USING "btree" ("user_id", "start_time", "end_time");

CREATE UNIQUE INDEX "idx_calendar_events_user_external_unique" ON "public"."calendar_events" USING "btree" ("user_id", "external_id");

COMMENT ON INDEX "public"."idx_calendar_events_user_external_unique" IS 'Ensures calendar events are unique per user and external_id (works without org_id)';

CREATE INDEX "idx_calendar_events_user_id" ON "public"."calendar_events" USING "btree" ("user_id");

CREATE INDEX "idx_calendar_reminders_event_fk" ON "public"."calendar_reminders" USING "btree" ("event_id");

CREATE INDEX "idx_calendar_sync_logs_calendar_id" ON "public"."calendar_sync_logs" USING "btree" ("calendar_id");

CREATE INDEX "idx_calendar_sync_logs_user_id" ON "public"."calendar_sync_logs" USING "btree" ("user_id");

CREATE INDEX "idx_call_action_items_call_id" ON "public"."call_action_items" USING "btree" ("call_id");

CREATE INDEX "idx_call_action_items_importance" ON "public"."call_action_items" USING "btree" ("importance") WHERE ("importance" IS NOT NULL);

CREATE INDEX "idx_call_action_items_linked_task_id" ON "public"."call_action_items" USING "btree" ("linked_task_id");

CREATE INDEX "idx_call_action_items_org_id" ON "public"."call_action_items" USING "btree" ("org_id");

CREATE INDEX "idx_call_action_items_synced" ON "public"."call_action_items" USING "btree" ("call_id", "synced_to_task") WHERE ("synced_to_task" = false);

CREATE INDEX "idx_call_file_search_index_org_id" ON "public"."call_file_search_index" USING "btree" ("org_id");

CREATE INDEX "idx_call_file_search_index_owner_user_id" ON "public"."call_file_search_index" USING "btree" ("owner_user_id");

CREATE INDEX "idx_call_file_search_index_status" ON "public"."call_file_search_index" USING "btree" ("status");

CREATE INDEX "idx_call_index_queue_org_id" ON "public"."call_index_queue" USING "btree" ("org_id");

CREATE INDEX "idx_call_index_queue_owner_user_id" ON "public"."call_index_queue" USING "btree" ("owner_user_id");

CREATE INDEX "idx_call_index_queue_priority" ON "public"."call_index_queue" USING "btree" ("priority" DESC, "created_at");

CREATE INDEX "idx_call_transcript_queue_org_id" ON "public"."call_transcript_queue" USING "btree" ("org_id");

CREATE INDEX "idx_call_transcript_queue_priority" ON "public"."call_transcript_queue" USING "btree" ("priority" DESC, "created_at");

CREATE INDEX "idx_calls_company_id" ON "public"."calls" USING "btree" ("company_id");

CREATE INDEX "idx_calls_contact_id" ON "public"."calls" USING "btree" ("contact_id");

CREATE INDEX "idx_calls_deal_id" ON "public"."calls" USING "btree" ("deal_id");

CREATE INDEX "idx_calls_org_id_company_id" ON "public"."calls" USING "btree" ("org_id", "company_id");

CREATE INDEX "idx_calls_org_id_contact_id" ON "public"."calls" USING "btree" ("org_id", "contact_id");

CREATE INDEX "idx_calls_org_id_owner_user_id" ON "public"."calls" USING "btree" ("org_id", "owner_user_id");

CREATE INDEX "idx_calls_org_id_started_at" ON "public"."calls" USING "btree" ("org_id", "started_at" DESC);

CREATE INDEX "idx_calls_owner_user_id" ON "public"."calls" USING "btree" ("owner_user_id");

CREATE INDEX "idx_challenge_features_challenge_fk" ON "public"."challenge_features" USING "btree" ("challenge_id");

CREATE UNIQUE INDEX "idx_circuit_breakers_unique" ON "public"."workflow_circuit_breakers" USING "btree" ("workflow_id", "node_id") WHERE ("workflow_id" IS NOT NULL);

CREATE INDEX "idx_clients_owner_id" ON "public"."clients" USING "btree" ("owner_id");

CREATE INDEX "idx_coaching_scorecard_templates_active" ON "public"."coaching_scorecard_templates" USING "btree" ("is_active") WHERE ("is_active" = true);

CREATE INDEX "idx_coaching_scorecard_templates_call_type_id" ON "public"."coaching_scorecard_templates" USING "btree" ("call_type_id");

CREATE INDEX "idx_coaching_scorecard_templates_created_by" ON "public"."coaching_scorecard_templates" USING "btree" ("created_by");

CREATE INDEX "idx_coaching_scorecard_templates_meeting_type" ON "public"."coaching_scorecard_templates" USING "btree" ("meeting_type");

CREATE INDEX "idx_coaching_scorecard_templates_org_id" ON "public"."coaching_scorecard_templates" USING "btree" ("org_id");

CREATE INDEX "idx_coaching_templates_call_type" ON "public"."coaching_scorecard_templates" USING "btree" ("org_id", "call_type_id") WHERE ("call_type_id" IS NOT NULL);

CREATE INDEX "idx_communication_events_company_id" ON "public"."communication_events" USING "btree" ("company_id");

CREATE INDEX "idx_communication_events_contact_id" ON "public"."communication_events" USING "btree" ("contact_id");

CREATE INDEX "idx_communication_events_deal_id" ON "public"."communication_events" USING "btree" ("deal_id");

CREATE INDEX "idx_communication_events_previous_event_fk" ON "public"."communication_events" USING "btree" ("previous_event_id");

CREATE INDEX "idx_communication_events_user" ON "public"."communication_events" USING "btree" ("user_id");

CREATE INDEX "idx_companies_owner_id" ON "public"."companies" USING "btree" ("owner_id");

CREATE INDEX "idx_contact_insights_contact" ON "public"."contact_meeting_insights" USING "btree" ("contact_id");

CREATE INDEX "idx_contact_notes_contact_pinned" ON "public"."contact_notes" USING "btree" ("contact_id", "is_pinned" DESC, "created_at" DESC);

CREATE INDEX "idx_contact_notes_created_by" ON "public"."contact_notes" USING "btree" ("created_by");

CREATE INDEX "idx_contacts_company_fk" ON "public"."contacts" USING "btree" ("company_id");

CREATE INDEX "idx_contacts_owner_id" ON "public"."contacts" USING "btree" ("owner_id");

CREATE INDEX "idx_copilot_analytics_conversation_id" ON "public"."copilot_analytics" USING "btree" ("conversation_id");

CREATE INDEX "idx_copilot_analytics_user_id" ON "public"."copilot_analytics" USING "btree" ("user_id");

CREATE INDEX "idx_copilot_conversations_org_id" ON "public"."copilot_conversations" USING "btree" ("org_id");

CREATE INDEX "idx_copilot_conversations_updated_at" ON "public"."copilot_conversations" USING "btree" ("updated_at" DESC);

CREATE INDEX "idx_copilot_conversations_user_id" ON "public"."copilot_conversations" USING "btree" ("user_id");

CREATE INDEX "idx_copilot_messages_conversation_id" ON "public"."copilot_messages" USING "btree" ("conversation_id");

CREATE INDEX "idx_copilot_messages_created_at" ON "public"."copilot_messages" USING "btree" ("conversation_id", "created_at");

CREATE INDEX "idx_cron_job_logs_user_id" ON "public"."cron_job_logs" USING "btree" ("user_id");

-- CREATE INDEX "idx_cron_notification_subscribers_created_by" ON "public"."cron_notification_subscribers" USING "btree" ("created_by");

-- CREATE INDEX "idx_cron_notifications_log_created_at" ON "public"."cron_notifications_log" USING "btree" ("created_at" DESC);

-- CREATE INDEX "idx_cron_notifications_log_job_name" ON "public"."cron_notifications_log" USING "btree" ("job_name");

CREATE INDEX "idx_csv_mapping_templates_user_id" ON "public"."csv_mapping_templates" USING "btree" ("user_id");

CREATE INDEX "idx_deal_activities_activity_id" ON "public"."deal_activities" USING "btree" ("activity_id");

CREATE INDEX "idx_deal_activities_deal_fk" ON "public"."deal_activities" USING "btree" ("deal_id");

CREATE INDEX "idx_deal_activities_deal_id_created" ON "public"."deal_activities" USING "btree" ("deal_id", "created_at" DESC);

CREATE INDEX "idx_deal_activities_user_id" ON "public"."deal_activities" USING "btree" ("user_id");

CREATE INDEX "idx_deal_clarity_scores_clarity" ON "public"."deal_clarity_scores" USING "btree" ("clarity_score");

CREATE INDEX "idx_deal_clarity_scores_momentum" ON "public"."deal_clarity_scores" USING "btree" ("momentum_score");

CREATE INDEX "idx_deal_clarity_scores_org_id" ON "public"."deal_clarity_scores" USING "btree" ("org_id");

CREATE INDEX "idx_deal_close_plan_items_deal_id" ON "public"."deal_close_plan_items" USING "btree" ("deal_id");

CREATE INDEX "idx_deal_close_plan_items_due_date" ON "public"."deal_close_plan_items" USING "btree" ("due_date") WHERE ("due_date" IS NOT NULL);

CREATE INDEX "idx_deal_close_plan_items_org_id" ON "public"."deal_close_plan_items" USING "btree" ("org_id");

CREATE INDEX "idx_deal_close_plan_items_owner_id" ON "public"."deal_close_plan_items" USING "btree" ("owner_id") WHERE ("owner_id" IS NOT NULL);

CREATE INDEX "idx_deal_close_plan_items_status" ON "public"."deal_close_plan_items" USING "btree" ("status");

CREATE INDEX "idx_deal_health_alerts_acknowledged_by_fk" ON "public"."deal_health_alerts" USING "btree" ("acknowledged_by");

CREATE INDEX "idx_deal_health_alerts_deal_id" ON "public"."deal_health_alerts" USING "btree" ("deal_id");

CREATE INDEX "idx_deal_health_alerts_health_score_fk" ON "public"."deal_health_alerts" USING "btree" ("health_score_id");

CREATE INDEX "idx_deal_health_alerts_status" ON "public"."deal_health_alerts" USING "btree" ("status");

CREATE INDEX "idx_deal_health_alerts_user" ON "public"."deal_health_alerts" USING "btree" ("user_id");

CREATE INDEX "idx_deal_health_history_deal" ON "public"."deal_health_history" USING "btree" ("deal_id");

CREATE INDEX "idx_deal_health_rules_created_by_fk" ON "public"."deal_health_rules" USING "btree" ("created_by");

CREATE INDEX "idx_deal_health_scores_deal" ON "public"."deal_health_scores" USING "btree" ("deal_id");

CREATE INDEX "idx_deal_health_scores_user" ON "public"."deal_health_scores" USING "btree" ("user_id");

CREATE INDEX "idx_deal_migration_reviews_deal_id" ON "public"."deal_migration_reviews" USING "btree" ("deal_id");

CREATE INDEX "idx_deal_migration_reviews_resolved_by_fk" ON "public"."deal_migration_reviews" USING "btree" ("resolved_by");

CREATE INDEX "idx_deal_migration_reviews_suggested_company_fk" ON "public"."deal_migration_reviews" USING "btree" ("suggested_company_id");

CREATE INDEX "idx_deal_migration_reviews_suggested_contact_fk" ON "public"."deal_migration_reviews" USING "btree" ("suggested_contact_id");

CREATE INDEX "idx_deal_notes_created_by" ON "public"."deal_notes" USING "btree" ("created_by");

CREATE INDEX "idx_deal_notes_deal_id" ON "public"."deal_notes" USING "btree" ("deal_id");

CREATE INDEX "idx_deal_risk_aggregates_deal_id" ON "public"."deal_risk_aggregates" USING "btree" ("deal_id");

CREATE INDEX "idx_deal_risk_aggregates_org_id" ON "public"."deal_risk_aggregates" USING "btree" ("org_id");

CREATE INDEX "idx_deal_risk_aggregates_risk_level" ON "public"."deal_risk_aggregates" USING "btree" ("overall_risk_level");

CREATE INDEX "idx_deal_risk_aggregates_risk_score" ON "public"."deal_risk_aggregates" USING "btree" ("risk_score" DESC);

CREATE INDEX "idx_deal_risk_signals_deal_id" ON "public"."deal_risk_signals" USING "btree" ("deal_id");

CREATE INDEX "idx_deal_risk_signals_detected_at" ON "public"."deal_risk_signals" USING "btree" ("detected_at" DESC);

CREATE INDEX "idx_deal_risk_signals_is_resolved" ON "public"."deal_risk_signals" USING "btree" ("is_resolved") WHERE ("is_resolved" = false);

CREATE INDEX "idx_deal_risk_signals_org_id" ON "public"."deal_risk_signals" USING "btree" ("org_id");

CREATE INDEX "idx_deal_risk_signals_resolved_by" ON "public"."deal_risk_signals" USING "btree" ("resolved_by");

CREATE INDEX "idx_deal_risk_signals_severity" ON "public"."deal_risk_signals" USING "btree" ("severity");

CREATE INDEX "idx_deal_risk_signals_signal_type" ON "public"."deal_risk_signals" USING "btree" ("signal_type");

CREATE INDEX "idx_deal_risk_signals_source_meeting" ON "public"."deal_risk_signals" USING "btree" ("source_meeting_id");

CREATE INDEX "idx_deal_splits_user_id" ON "public"."deal_splits" USING "btree" ("user_id");

CREATE INDEX "idx_deal_stage_history_changed_at" ON "public"."deal_stage_history" USING "btree" ("changed_at");

CREATE INDEX "idx_deal_stage_history_deal_id" ON "public"."deal_stage_history" USING "btree" ("deal_id");

CREATE INDEX "idx_deal_stage_history_stage_fk" ON "public"."deal_stage_history" USING "btree" ("stage_id");

CREATE INDEX "idx_deal_stage_history_user_fk" ON "public"."deal_stage_history" USING "btree" ("user_id");

CREATE INDEX "idx_deal_truth_fields_confidence" ON "public"."deal_truth_fields" USING "btree" ("confidence") WHERE ("confidence" < 0.6);

CREATE INDEX "idx_deal_truth_fields_contact_id" ON "public"."deal_truth_fields" USING "btree" ("contact_id") WHERE ("contact_id" IS NOT NULL);

CREATE INDEX "idx_deal_truth_fields_deal_id" ON "public"."deal_truth_fields" USING "btree" ("deal_id");

CREATE INDEX "idx_deal_truth_fields_field_key" ON "public"."deal_truth_fields" USING "btree" ("field_key");

CREATE INDEX "idx_deal_truth_fields_org_id" ON "public"."deal_truth_fields" USING "btree" ("org_id");

CREATE INDEX "idx_deals_company_fk" ON "public"."deals" USING "btree" ("company_id");

CREATE INDEX "idx_deals_contact_email" ON "public"."deals" USING "btree" ("contact_email");

CREATE INDEX "idx_deals_owner_id" ON "public"."deals" USING "btree" ("owner_id");

CREATE INDEX "idx_deals_owner_status" ON "public"."deals" USING "btree" ("owner_id", "status", "stage_id");

CREATE INDEX "idx_deals_primary_contact_id" ON "public"."deals" USING "btree" ("primary_contact_id");

CREATE INDEX "idx_deals_stage_id" ON "public"."deals" USING "btree" ("stage_id");

CREATE INDEX "idx_email_attachments_email_fk" ON "public"."email_attachments" USING "btree" ("email_id");

CREATE INDEX "idx_email_categorizations_communication_event_id" ON "public"."email_categorizations" USING "btree" ("communication_event_id");

CREATE INDEX "idx_email_categorizations_label_pending" ON "public"."email_categorizations" USING "btree" ("user_id", "category") WHERE ("gmail_label_applied" = false);

CREATE INDEX "idx_email_categorizations_org_category" ON "public"."email_categorizations" USING "btree" ("org_id", "category") WHERE ("org_id" IS NOT NULL);

CREATE INDEX "idx_email_categorizations_signals_gin" ON "public"."email_categorizations" USING "gin" ("signals");

CREATE INDEX "idx_email_categorizations_thread" ON "public"."email_categorizations" USING "btree" ("thread_id") WHERE ("thread_id" IS NOT NULL);

CREATE INDEX "idx_email_categorizations_user_category" ON "public"."email_categorizations" USING "btree" ("user_id", "category");

CREATE INDEX "idx_email_categorizations_user_processed" ON "public"."email_categorizations" USING "btree" ("user_id", "processed_at" DESC);

CREATE UNIQUE INDEX "idx_email_invites_unique" ON "public"."waitlist_email_invites" USING "btree" ("waitlist_entry_id", "email");

CREATE INDEX "idx_email_journeys_active" ON "public"."email_journeys" USING "btree" ("is_active") WHERE ("is_active" = true);

CREATE INDEX "idx_email_journeys_journey_name" ON "public"."email_journeys" USING "btree" ("journey_name");

CREATE INDEX "idx_email_journeys_trigger_event" ON "public"."email_journeys" USING "btree" ("trigger_event");

CREATE INDEX "idx_email_label_map_email_fk" ON "public"."email_label_map" USING "btree" ("email_id");

CREATE INDEX "idx_email_label_map_label_fk" ON "public"."email_label_map" USING "btree" ("label_id");

CREATE INDEX "idx_email_labels_user_fk" ON "public"."email_labels" USING "btree" ("user_id");

CREATE INDEX "idx_email_logs_created_at" ON "public"."email_logs" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_email_logs_email_type" ON "public"."email_logs" USING "btree" ("email_type");

CREATE INDEX "idx_email_logs_status" ON "public"."email_logs" USING "btree" ("status");

CREATE INDEX "idx_email_logs_to_email" ON "public"."email_logs" USING "btree" ("to_email");

CREATE INDEX "idx_email_logs_user_id" ON "public"."email_logs" USING "btree" ("user_id");

CREATE INDEX "idx_email_sends_email_type" ON "public"."email_sends" USING "btree" ("email_type");

CREATE INDEX "idx_email_sends_journey_id" ON "public"."email_sends" USING "btree" ("journey_id");

CREATE INDEX "idx_email_sends_sent_at" ON "public"."email_sends" USING "btree" ("sent_at" DESC);

CREATE INDEX "idx_email_sends_status" ON "public"."email_sends" USING "btree" ("status");

CREATE INDEX "idx_email_sends_user_id" ON "public"."email_sends" USING "btree" ("user_id");

CREATE INDEX "idx_email_sends_user_type" ON "public"."email_sends" USING "btree" ("user_id", "email_type");

CREATE INDEX "idx_email_templates_user_fk" ON "public"."email_templates" USING "btree" ("user_id");

CREATE INDEX "idx_email_threads_user_id" ON "public"."email_threads" USING "btree" ("user_id");

CREATE INDEX "idx_emails_mcp_connection_fk" ON "public"."emails" USING "btree" ("mcp_connection_id");

CREATE INDEX "idx_emails_thread_id" ON "public"."emails" USING "btree" ("thread_id");

CREATE INDEX "idx_emails_user_id" ON "public"."emails" USING "btree" ("user_id");

CREATE INDEX "idx_encharge_templates_active" ON "public"."encharge_email_templates" USING "btree" ("is_active") WHERE ("is_active" = true);

CREATE INDEX "idx_encharge_templates_type" ON "public"."encharge_email_templates" USING "btree" ("template_type");

CREATE INDEX "idx_fathom_integrations_user_id" ON "public"."fathom_integrations" USING "btree" ("user_id") WHERE ("is_active" = true);

CREATE INDEX "idx_fathom_oauth_states_org_id" ON "public"."fathom_oauth_states" USING "btree" ("org_id");

CREATE INDEX "idx_fathom_oauth_states_user_id" ON "public"."fathom_oauth_states" USING "btree" ("user_id");

CREATE INDEX "idx_fathom_org_credentials_token_expires_at" ON "public"."fathom_org_credentials" USING "btree" ("token_expires_at");

CREATE INDEX "idx_fathom_org_integrations_connected_by_user_id" ON "public"."fathom_org_integrations" USING "btree" ("connected_by_user_id");

CREATE INDEX "idx_fathom_org_integrations_email" ON "public"."fathom_org_integrations" USING "btree" ("lower"("fathom_user_email")) WHERE ("fathom_user_email" IS NOT NULL);

CREATE INDEX "idx_fathom_org_integrations_fathom_user_id" ON "public"."fathom_org_integrations" USING "btree" ("fathom_user_id");

CREATE INDEX "idx_fathom_org_integrations_org_id" ON "public"."fathom_org_integrations" USING "btree" ("org_id") WHERE ("is_active" = true);

CREATE INDEX "idx_fathom_org_sync_state_org_id" ON "public"."fathom_org_sync_state" USING "btree" ("org_id");

CREATE INDEX "idx_fathom_org_sync_state_status" ON "public"."fathom_org_sync_state" USING "btree" ("sync_status") WHERE ("sync_status" = 'syncing'::"text");

CREATE INDEX "idx_fathom_sync_state_user_id" ON "public"."fathom_sync_state" USING "btree" ("user_id");

CREATE INDEX "idx_fathom_transcript_retry_jobs_user_fk" ON "public"."fathom_transcript_retry_jobs" USING "btree" ("user_id");

CREATE INDEX "idx_fathom_user_mappings_org_email" ON "public"."fathom_user_mappings" USING "btree" ("org_id", "fathom_user_email");

CREATE INDEX "idx_fathom_user_mappings_sixty_user" ON "public"."fathom_user_mappings" USING "btree" ("sixty_user_id");

CREATE INDEX "idx_fathom_user_mappings_unmapped" ON "public"."fathom_user_mappings" USING "btree" ("org_id") WHERE ("sixty_user_id" IS NULL);

CREATE INDEX "idx_ghost_detection_signals_relationship_health_id" ON "public"."ghost_detection_signals" USING "btree" ("relationship_health_id");

CREATE INDEX "idx_ghost_signals_user" ON "public"."ghost_detection_signals" USING "btree" ("user_id");

CREATE INDEX "idx_global_topic_sources_company_id" ON "public"."global_topic_sources" USING "btree" ("company_id");

CREATE INDEX "idx_global_topic_sources_contact_id" ON "public"."global_topic_sources" USING "btree" ("contact_id");

CREATE INDEX "idx_global_topic_sources_meeting_id" ON "public"."global_topic_sources" USING "btree" ("meeting_id");

CREATE INDEX "idx_global_topics_user_id" ON "public"."global_topics" USING "btree" ("user_id");

CREATE INDEX "idx_gmail_label_mappings_label_id" ON "public"."gmail_label_mappings" USING "btree" ("gmail_label_id");

CREATE INDEX "idx_gmail_label_mappings_org" ON "public"."gmail_label_mappings" USING "btree" ("org_id") WHERE ("org_id" IS NOT NULL);

CREATE INDEX "idx_gmail_label_mappings_user" ON "public"."gmail_label_mappings" USING "btree" ("user_id");

CREATE INDEX "idx_google_docs_templates_user_id" ON "public"."google_docs_templates" USING "btree" ("user_id");

CREATE INDEX "idx_google_integrations_last_refresh" ON "public"."google_integrations" USING "btree" ("last_token_refresh") WHERE ("is_active" = true);

CREATE INDEX "idx_google_integrations_token_status" ON "public"."google_integrations" USING "btree" ("token_status") WHERE ("token_status" <> 'valid'::"text");

CREATE INDEX "idx_google_oauth_states_user_fk" ON "public"."google_oauth_states" USING "btree" ("user_id");

CREATE INDEX "idx_google_service_logs_integration_id" ON "public"."google_service_logs" USING "btree" ("integration_id");

CREATE INDEX "idx_google_task_mappings_user_id" ON "public"."google_task_mappings" USING "btree" ("user_id");

CREATE INDEX "idx_google_tasks_sync_conflicts_task_id" ON "public"."google_tasks_sync_conflicts" USING "btree" ("task_id");

CREATE INDEX "idx_hitl_pending_approvals_actioned_by" ON "public"."hitl_pending_approvals" USING "btree" ("actioned_by");

CREATE INDEX "idx_hitl_pending_approvals_created_by" ON "public"."hitl_pending_approvals" USING "btree" ("created_by");

CREATE INDEX "idx_hitl_pending_dashboard" ON "public"."hitl_pending_approvals" USING "btree" ("org_id", "user_id", "status", "created_at" DESC);

CREATE INDEX "idx_hitl_pending_expires" ON "public"."hitl_pending_approvals" USING "btree" ("expires_at") WHERE ("status" = 'pending'::"text");

CREATE INDEX "idx_hitl_pending_org_status" ON "public"."hitl_pending_approvals" USING "btree" ("org_id", "status", "created_at" DESC);

CREATE INDEX "idx_hitl_pending_resource" ON "public"."hitl_pending_approvals" USING "btree" ("resource_type", "resource_id");

CREATE INDEX "idx_hitl_pending_slack_message" ON "public"."hitl_pending_approvals" USING "btree" ("slack_channel_id", "slack_message_ts");

CREATE INDEX "idx_hitl_pending_user_status" ON "public"."hitl_pending_approvals" USING "btree" ("user_id", "status") WHERE ("status" = 'pending'::"text");

CREATE INDEX "idx_hitl_requests_assigned" ON "public"."sequence_hitl_requests" USING "btree" ("assigned_to_user_id");

CREATE INDEX "idx_hitl_requests_assigned_user" ON "public"."hitl_requests" USING "btree" ("assigned_to_user_id", "status") WHERE ("assigned_to_user_id" IS NOT NULL);

CREATE INDEX "idx_hitl_requests_execution" ON "public"."hitl_requests" USING "btree" ("execution_id");

CREATE INDEX "idx_hitl_requests_expires" ON "public"."hitl_requests" USING "btree" ("expires_at") WHERE ("status" = 'pending'::"text");

CREATE INDEX "idx_hitl_requests_org" ON "public"."sequence_hitl_requests" USING "btree" ("organization_id");

CREATE INDEX "idx_hitl_requests_org_status" ON "public"."hitl_requests" USING "btree" ("organization_id", "status");

CREATE INDEX "idx_hitl_requests_pending" ON "public"."sequence_hitl_requests" USING "btree" ("organization_id", "status") WHERE ("status" = 'pending'::"text");

CREATE INDEX "idx_hitl_requests_status" ON "public"."sequence_hitl_requests" USING "btree" ("status");

CREATE INDEX "idx_hubspot_oauth_states_expires_at" ON "public"."hubspot_oauth_states" USING "btree" ("expires_at");

CREATE INDEX "idx_hubspot_oauth_states_org_id" ON "public"."hubspot_oauth_states" USING "btree" ("org_id");

CREATE INDEX "idx_hubspot_oauth_states_state" ON "public"."hubspot_oauth_states" USING "btree" ("state");

CREATE INDEX "idx_hubspot_oauth_states_user_id" ON "public"."hubspot_oauth_states" USING "btree" ("user_id");

CREATE INDEX "idx_hubspot_object_mappings_hubspot_id" ON "public"."hubspot_object_mappings" USING "btree" ("org_id", "hubspot_id");

CREATE INDEX "idx_hubspot_object_mappings_org_type" ON "public"."hubspot_object_mappings" USING "btree" ("org_id", "object_type");

CREATE INDEX "idx_hubspot_org_credentials_token_expires_at" ON "public"."hubspot_org_credentials" USING "btree" ("token_expires_at");

CREATE INDEX "idx_hubspot_org_integrations_clerk_org_id" ON "public"."hubspot_org_integrations" USING "btree" ("clerk_org_id") WHERE (("clerk_org_id" IS NOT NULL) AND ("clerk_org_id" <> ''::"text"));

CREATE INDEX "idx_hubspot_org_integrations_connected_by_user_id" ON "public"."hubspot_org_integrations" USING "btree" ("connected_by_user_id");

CREATE INDEX "idx_hubspot_org_integrations_org_id" ON "public"."hubspot_org_integrations" USING "btree" ("org_id") WHERE ("is_active" = true);

CREATE INDEX "idx_hubspot_org_integrations_webhook_token" ON "public"."hubspot_org_integrations" USING "btree" ("webhook_token");

CREATE INDEX "idx_hubspot_org_sync_state_org_id" ON "public"."hubspot_org_sync_state" USING "btree" ("org_id");

CREATE INDEX "idx_hubspot_org_sync_state_status" ON "public"."hubspot_org_sync_state" USING "btree" ("sync_status") WHERE ("sync_status" = 'syncing'::"text");

CREATE INDEX "idx_hubspot_sync_queue_clerk_org_id" ON "public"."hubspot_sync_queue" USING "btree" ("clerk_org_id") WHERE (("clerk_org_id" IS NOT NULL) AND ("clerk_org_id" <> ''::"text"));

CREATE INDEX "idx_hubspot_sync_queue_job_type" ON "public"."hubspot_sync_queue" USING "btree" ("job_type");

CREATE INDEX "idx_hubspot_sync_queue_org" ON "public"."hubspot_sync_queue" USING "btree" ("org_id");

CREATE UNIQUE INDEX "idx_hubspot_sync_queue_org_dedupe" ON "public"."hubspot_sync_queue" USING "btree" ("org_id", "dedupe_key") WHERE ("dedupe_key" IS NOT NULL);

CREATE INDEX "idx_hubspot_sync_queue_ready" ON "public"."hubspot_sync_queue" USING "btree" ("run_after", "priority" DESC, "created_at");

CREATE INDEX "idx_hubspot_webhook_events_org_received_at" ON "public"."hubspot_webhook_events" USING "btree" ("org_id", "received_at" DESC);

CREATE INDEX "idx_hubspot_webhook_events_org_type" ON "public"."hubspot_webhook_events" USING "btree" ("org_id", "event_type");

CREATE INDEX "idx_impersonation_logs_admin_id" ON "public"."impersonation_logs" USING "btree" ("admin_id");

CREATE INDEX "idx_impersonation_logs_created_at" ON "public"."impersonation_logs" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_impersonation_logs_target_user_id" ON "public"."impersonation_logs" USING "btree" ("target_user_id");

CREATE INDEX "idx_integration_alerts_acknowledged_by" ON "public"."integration_alerts" USING "btree" ("acknowledged_by");

CREATE INDEX "idx_integration_alerts_integration" ON "public"."integration_alerts" USING "btree" ("integration_name");

CREATE INDEX "idx_integration_alerts_resolved_by" ON "public"."integration_alerts" USING "btree" ("resolved_by");

CREATE INDEX "idx_integration_alerts_severity" ON "public"."integration_alerts" USING "btree" ("severity");

CREATE INDEX "idx_integration_alerts_test_result_id" ON "public"."integration_alerts" USING "btree" ("test_result_id");

CREATE INDEX "idx_integration_alerts_unresolved" ON "public"."integration_alerts" USING "btree" ("resolved_at") WHERE ("resolved_at" IS NULL);

CREATE INDEX "idx_integration_sync_logs_batch_id" ON "public"."integration_sync_logs" USING "btree" ("batch_id") WHERE ("batch_id" IS NOT NULL);

CREATE INDEX "idx_integration_sync_logs_created_at" ON "public"."integration_sync_logs" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_integration_sync_logs_dashboard" ON "public"."integration_sync_logs" USING "btree" ("org_id", "integration_name", "created_at" DESC);

CREATE INDEX "idx_integration_sync_logs_entity_type" ON "public"."integration_sync_logs" USING "btree" ("entity_type");

CREATE INDEX "idx_integration_sync_logs_integration" ON "public"."integration_sync_logs" USING "btree" ("integration_name");

CREATE INDEX "idx_integration_sync_logs_org_created" ON "public"."integration_sync_logs" USING "btree" ("org_id", "created_at" DESC);

CREATE INDEX "idx_integration_sync_logs_status" ON "public"."integration_sync_logs" USING "btree" ("status");

CREATE INDEX "idx_integration_sync_logs_user_id" ON "public"."integration_sync_logs" USING "btree" ("user_id");

CREATE INDEX "idx_integration_test_results_created_at" ON "public"."integration_test_results" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_integration_test_results_integration" ON "public"."integration_test_results" USING "btree" ("integration_name");

CREATE INDEX "idx_integration_test_results_integration_status" ON "public"."integration_test_results" USING "btree" ("integration_name", "status", "created_at" DESC);

CREATE INDEX "idx_integration_test_results_org_id" ON "public"."integration_test_results" USING "btree" ("org_id");

CREATE INDEX "idx_integration_test_results_status" ON "public"."integration_test_results" USING "btree" ("status");

CREATE INDEX "idx_integration_test_results_triggered_by_user_id" ON "public"."integration_test_results" USING "btree" ("triggered_by_user_id");

CREATE INDEX "idx_internal_users_added_by_fk" ON "public"."internal_users" USING "btree" ("added_by");

CREATE INDEX "idx_intervention_templates_parent_template_id" ON "public"."intervention_templates" USING "btree" ("parent_template_id");

CREATE INDEX "idx_intervention_templates_user_id" ON "public"."intervention_templates" USING "btree" ("user_id");

CREATE INDEX "idx_interventions_company_id" ON "public"."interventions" USING "btree" ("company_id");

CREATE INDEX "idx_interventions_contact_id" ON "public"."interventions" USING "btree" ("contact_id");

CREATE INDEX "idx_interventions_deal_id" ON "public"."interventions" USING "btree" ("deal_id");

CREATE INDEX "idx_interventions_relationship_health_id" ON "public"."interventions" USING "btree" ("relationship_health_id");

CREATE INDEX "idx_interventions_template_id" ON "public"."interventions" USING "btree" ("template_id");

CREATE INDEX "idx_interventions_user" ON "public"."interventions" USING "btree" ("user_id");

CREATE INDEX "idx_justcall_integration_secrets_org_id" ON "public"."justcall_integration_secrets" USING "btree" ("org_id");

CREATE INDEX "idx_justcall_integrations_connected_by_user_id" ON "public"."justcall_integrations" USING "btree" ("connected_by_user_id");

CREATE INDEX "idx_justcall_integrations_org_id" ON "public"."justcall_integrations" USING "btree" ("org_id");

CREATE INDEX "idx_justcall_oauth_states_org_id" ON "public"."justcall_oauth_states" USING "btree" ("org_id");

CREATE INDEX "idx_justcall_oauth_states_state" ON "public"."justcall_oauth_states" USING "btree" ("state");

CREATE INDEX "idx_justcall_oauth_states_user_id" ON "public"."justcall_oauth_states" USING "btree" ("user_id");

CREATE INDEX "idx_launch_checklist_category" ON "public"."launch_checklist_items" USING "btree" ("category");

CREATE INDEX "idx_launch_checklist_items_completed_by" ON "public"."launch_checklist_items" USING "btree" ("completed_by");

CREATE INDEX "idx_launch_checklist_status" ON "public"."launch_checklist_items" USING "btree" ("status");

CREATE INDEX "idx_lead_events_lead_id" ON "public"."lead_events" USING "btree" ("lead_id");

CREATE INDEX "idx_lead_prep_notes_created_by_fk" ON "public"."lead_prep_notes" USING "btree" ("created_by");

CREATE INDEX "idx_lead_prep_notes_lead_id" ON "public"."lead_prep_notes" USING "btree" ("lead_id");

CREATE INDEX "idx_lead_sources_default_owner_fk" ON "public"."lead_sources" USING "btree" ("default_owner_id");

CREATE INDEX "idx_leads_company_fk" ON "public"."leads" USING "btree" ("company_id");

CREATE INDEX "idx_leads_contact_fk" ON "public"."leads" USING "btree" ("contact_id");

CREATE INDEX "idx_leads_converted_deal_fk" ON "public"."leads" USING "btree" ("converted_deal_id");

CREATE INDEX "idx_leads_created_at" ON "public"."leads" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_leads_created_by_fk" ON "public"."leads" USING "btree" ("created_by");

CREATE INDEX "idx_leads_owner_id" ON "public"."leads" USING "btree" ("owner_id");

CREATE INDEX "idx_leads_source_id" ON "public"."leads" USING "btree" ("source_id");

CREATE INDEX "idx_links_content_id" ON "public"."content_topic_links" USING "btree" ("content_id");

CREATE INDEX "idx_mcp_connections_user_id" ON "public"."mcp_connections" USING "btree" ("user_id");

CREATE INDEX "idx_meeting_action_items_linked_task_id" ON "public"."meeting_action_items" USING "btree" ("linked_task_id");

CREATE INDEX "idx_meeting_action_items_meeting_id" ON "public"."meeting_action_items" USING "btree" ("meeting_id");

CREATE INDEX "idx_meeting_aggregate_metrics_org_id" ON "public"."meeting_aggregate_metrics" USING "btree" ("org_id");

CREATE INDEX "idx_meeting_aggregate_metrics_org_period" ON "public"."meeting_aggregate_metrics" USING "btree" ("org_id", "period_type", "period_start" DESC);

CREATE INDEX "idx_meeting_aggregate_metrics_period" ON "public"."meeting_aggregate_metrics" USING "btree" ("period_type", "period_start" DESC);

CREATE INDEX "idx_meeting_attendees_email" ON "public"."meeting_attendees" USING "btree" ("email");

CREATE INDEX "idx_meeting_attendees_meeting_id" ON "public"."meeting_attendees" USING "btree" ("meeting_id");

CREATE INDEX "idx_meeting_classifications_competitor" ON "public"."meeting_classifications" USING "btree" ("org_id", "has_competitor_mention") WHERE ("has_competitor_mention" = true);

CREATE INDEX "idx_meeting_classifications_forward_movement" ON "public"."meeting_classifications" USING "btree" ("org_id", "has_forward_movement") WHERE ("has_forward_movement" = true);

CREATE INDEX "idx_meeting_classifications_meeting_id" ON "public"."meeting_classifications" USING "btree" ("meeting_id");

CREATE INDEX "idx_meeting_classifications_objection" ON "public"."meeting_classifications" USING "btree" ("org_id", "has_objection") WHERE ("has_objection" = true);

CREATE INDEX "idx_meeting_classifications_org_id" ON "public"."meeting_classifications" USING "btree" ("org_id");

CREATE INDEX "idx_meeting_classifications_org_outcome" ON "public"."meeting_classifications" USING "btree" ("org_id", "outcome", "has_forward_movement");

CREATE INDEX "idx_meeting_classifications_outcome" ON "public"."meeting_classifications" USING "btree" ("org_id", "outcome");

CREATE INDEX "idx_meeting_classifications_pricing" ON "public"."meeting_classifications" USING "btree" ("org_id", "has_pricing_discussion") WHERE ("has_pricing_discussion" = true);

CREATE INDEX "idx_meeting_classifications_proposal_request" ON "public"."meeting_classifications" USING "btree" ("org_id", "has_proposal_request") WHERE ("has_proposal_request" = true);

CREATE INDEX "idx_meeting_contacts_contact" ON "public"."meeting_contacts" USING "btree" ("contact_id");

CREATE INDEX "idx_meeting_contacts_meeting" ON "public"."meeting_contacts" USING "btree" ("meeting_id");

CREATE INDEX "idx_meeting_content_topics_created_by" ON "public"."meeting_content_topics" USING "btree" ("created_by");

CREATE INDEX "idx_meeting_content_topics_meeting_id" ON "public"."meeting_content_topics" USING "btree" ("meeting_id");

CREATE INDEX "idx_meeting_content_topics_user_id" ON "public"."meeting_content_topics" USING "btree" ("user_id");

CREATE INDEX "idx_meeting_documents_user_id" ON "public"."meeting_documents" USING "btree" ("user_id");

CREATE INDEX "idx_meeting_file_search_index_meeting_id" ON "public"."meeting_file_search_index" USING "btree" ("meeting_id");

CREATE INDEX "idx_meeting_file_search_index_org_id" ON "public"."meeting_file_search_index" USING "btree" ("org_id");

CREATE INDEX "idx_meeting_file_search_index_owner" ON "public"."meeting_file_search_index" USING "btree" ("meeting_owner_id");

CREATE INDEX "idx_meeting_file_search_index_status" ON "public"."meeting_file_search_index" USING "btree" ("status");

CREATE INDEX "idx_meeting_file_search_index_user_id" ON "public"."meeting_file_search_index" USING "btree" ("user_id");

CREATE INDEX "idx_meeting_generated_content_created_by" ON "public"."meeting_generated_content" USING "btree" ("created_by");

CREATE INDEX "idx_meeting_generated_content_meeting_id" ON "public"."meeting_generated_content" USING "btree" ("meeting_id");

CREATE INDEX "idx_meeting_generated_content_parent_fk" ON "public"."meeting_generated_content" USING "btree" ("parent_id");

CREATE INDEX "idx_meeting_index_queue_priority" ON "public"."meeting_index_queue" USING "btree" ("priority" DESC, "created_at");

CREATE INDEX "idx_meeting_index_queue_user_id" ON "public"."meeting_index_queue" USING "btree" ("user_id");

CREATE INDEX "idx_meeting_intelligence_queries_user_fk" ON "public"."meeting_intelligence_queries" USING "btree" ("user_id");

CREATE INDEX "idx_meeting_metrics_meeting_fk" ON "public"."meeting_metrics" USING "btree" ("meeting_id");

CREATE INDEX "idx_meeting_scorecards_created_at" ON "public"."meeting_scorecards" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_meeting_scorecards_meeting_id" ON "public"."meeting_scorecards" USING "btree" ("meeting_id");

CREATE INDEX "idx_meeting_scorecards_org_id" ON "public"."meeting_scorecards" USING "btree" ("org_id");

CREATE INDEX "idx_meeting_scorecards_overall_score" ON "public"."meeting_scorecards" USING "btree" ("overall_score");

CREATE INDEX "idx_meeting_scorecards_rep_user_id" ON "public"."meeting_scorecards" USING "btree" ("rep_user_id");

CREATE INDEX "idx_meeting_scorecards_template_id" ON "public"."meeting_scorecards" USING "btree" ("template_id");

CREATE INDEX "idx_meeting_structured_summaries_competitor_mentions" ON "public"."meeting_structured_summaries" USING "gin" ("competitor_mentions");

CREATE INDEX "idx_meeting_structured_summaries_meeting_id" ON "public"."meeting_structured_summaries" USING "btree" ("meeting_id");

CREATE INDEX "idx_meeting_structured_summaries_objections" ON "public"."meeting_structured_summaries" USING "gin" ("objections");

CREATE INDEX "idx_meeting_structured_summaries_org_id" ON "public"."meeting_structured_summaries" USING "btree" ("org_id");

CREATE INDEX "idx_meeting_structured_summaries_outcome_signals" ON "public"."meeting_structured_summaries" USING "gin" ("outcome_signals");

CREATE INDEX "idx_meeting_topics_meeting_fk" ON "public"."meeting_topics" USING "btree" ("meeting_id");

CREATE INDEX "idx_meetingbaas_calendars_active" ON "public"."meetingbaas_calendars" USING "btree" ("is_active") WHERE ("is_active" = true);

CREATE INDEX "idx_meetingbaas_calendars_mb_id" ON "public"."meetingbaas_calendars" USING "btree" ("meetingbaas_calendar_id");

CREATE INDEX "idx_meetingbaas_calendars_org" ON "public"."meetingbaas_calendars" USING "btree" ("org_id");

CREATE INDEX "idx_meetingbaas_calendars_user" ON "public"."meetingbaas_calendars" USING "btree" ("user_id");

CREATE INDEX "idx_meetings_call_type_id" ON "public"."meetings" USING "btree" ("call_type_id") WHERE ("call_type_id" IS NOT NULL);

CREATE INDEX "idx_meetings_company_fk" ON "public"."meetings" USING "btree" ("company_id");

CREATE INDEX "idx_meetings_contact_date" ON "public"."meetings" USING "btree" ("primary_contact_id", "meeting_start" DESC) WHERE ("primary_contact_id" IS NOT NULL);

CREATE INDEX "idx_meetings_contact_fk" ON "public"."meetings" USING "btree" ("contact_id");

CREATE INDEX "idx_meetings_created_by_fk" ON "public"."meetings" USING "btree" ("created_by");

CREATE INDEX "idx_meetings_fathom_recording_id" ON "public"."meetings" USING "btree" ("fathom_recording_id") WHERE ("fathom_recording_id" IS NOT NULL);

CREATE INDEX "idx_meetings_historical_import" ON "public"."meetings" USING "btree" ("org_id", "is_historical_import") WHERE ("is_historical_import" = false);

CREATE INDEX "idx_meetings_meeting_start_desc" ON "public"."meetings" USING "btree" ("meeting_start" DESC);

CREATE INDEX "idx_meetings_org_id" ON "public"."meetings" USING "btree" ("org_id");

CREATE INDEX "idx_meetings_org_meeting_start" ON "public"."meetings" USING "btree" ("org_id", "meeting_start" DESC) WHERE ("meeting_start" IS NOT NULL);

CREATE INDEX "idx_meetings_owner_meeting_start" ON "public"."meetings" USING "btree" ("owner_user_id", "meeting_start" DESC) WHERE ("meeting_start" IS NOT NULL);

CREATE INDEX "idx_meetings_owner_user_id" ON "public"."meetings" USING "btree" ("owner_user_id");

CREATE INDEX "idx_meetings_primary_contact" ON "public"."meetings" USING "btree" ("primary_contact_id");

CREATE INDEX "idx_meetings_sentiment_start" ON "public"."meetings" USING "btree" ("meeting_start" DESC) WHERE ("sentiment_score" IS NOT NULL);

CREATE INDEX "idx_meetings_source_type" ON "public"."meetings" USING "btree" ("source_type");

CREATE INDEX "idx_meetings_summary_status" ON "public"."meetings" USING "btree" ("summary_status") WHERE ("summary_status" = ANY (ARRAY['pending'::"public"."meeting_processing_status", 'processing'::"public"."meeting_processing_status"]));

CREATE INDEX "idx_meetings_thumbnail_status" ON "public"."meetings" USING "btree" ("thumbnail_status") WHERE ("thumbnail_status" = ANY (ARRAY['pending'::"public"."meeting_processing_status", 'processing'::"public"."meeting_processing_status"]));

CREATE INDEX "idx_meetings_transcript_retry" ON "public"."meetings" USING "btree" ("last_transcript_fetch_at", "transcript_fetch_attempts") WHERE (("transcript_text" IS NULL) AND ("transcript_fetch_attempts" < 5) AND ("fathom_recording_id" IS NOT NULL));

CREATE INDEX "idx_meetings_transcript_status" ON "public"."meetings" USING "btree" ("transcript_status") WHERE ("transcript_status" = ANY (ARRAY['pending'::"public"."meeting_processing_status", 'processing'::"public"."meeting_processing_status"]));

CREATE INDEX "idx_meetings_voice_recording_id" ON "public"."meetings" USING "btree" ("voice_recording_id") WHERE ("voice_recording_id" IS NOT NULL);

CREATE INDEX "idx_meetings_waitlist_access_granted_by_fk" ON "public"."meetings_waitlist" USING "btree" ("access_granted_by");

CREATE INDEX "idx_meetings_waitlist_granted_by_fk" ON "public"."meetings_waitlist" USING "btree" ("granted_by");

CREATE INDEX "idx_meetings_waitlist_invite_code" ON "public"."meetings_waitlist" USING "btree" ("invite_code_used");

CREATE INDEX "idx_meetings_waitlist_released_by_fk" ON "public"."meetings_waitlist" USING "btree" ("released_by");

CREATE INDEX "idx_meetings_waitlist_signup_source" ON "public"."meetings_waitlist" USING "btree" ("signup_source");

CREATE INDEX "idx_next_action_suggestions_contact_fk" ON "public"."next_action_suggestions" USING "btree" ("contact_id");

CREATE INDEX "idx_next_action_suggestions_user_fk" ON "public"."next_action_suggestions" USING "btree" ("user_id");

CREATE INDEX "idx_next_actions_activity" ON "public"."next_action_suggestions" USING "btree" ("activity_id", "activity_type");

CREATE INDEX "idx_next_actions_company" ON "public"."next_action_suggestions" USING "btree" ("company_id") WHERE ("company_id" IS NOT NULL);

CREATE INDEX "idx_next_actions_deal" ON "public"."next_action_suggestions" USING "btree" ("deal_id") WHERE ("deal_id" IS NOT NULL);

CREATE INDEX "idx_next_actions_user_status" ON "public"."next_action_suggestions" USING "btree" ("user_id", "status") WHERE ("status" = 'pending'::"text");

CREATE INDEX "idx_notetaker_user_settings_calendar" ON "public"."notetaker_user_settings" USING "btree" ("selected_calendar_id") WHERE ("selected_calendar_id" IS NOT NULL);

CREATE INDEX "idx_notetaker_user_settings_enabled" ON "public"."notetaker_user_settings" USING "btree" ("org_id", "is_enabled");

CREATE INDEX "idx_notetaker_user_settings_org" ON "public"."notetaker_user_settings" USING "btree" ("org_id");

CREATE INDEX "idx_notetaker_user_settings_user" ON "public"."notetaker_user_settings" USING "btree" ("user_id");

CREATE INDEX "idx_notification_rate_limits_user_fk" ON "public"."notification_rate_limits" USING "btree" ("user_id");

CREATE INDEX "idx_notification_rate_limits_user_type_created" ON "public"."notification_rate_limits" USING "btree" ("user_id", "notification_type", "created_at" DESC);

CREATE INDEX "idx_notifications_created_by_fk" ON "public"."notifications" USING "btree" ("created_by");

CREATE INDEX "idx_notifications_user_created" ON "public"."notifications" USING "btree" ("user_id", "created_at" DESC);

CREATE INDEX "idx_notifications_user_fk" ON "public"."notifications" USING "btree" ("user_id");

CREATE INDEX "idx_org_ai_preferences_org_id" ON "public"."org_ai_preferences" USING "btree" ("org_id");

CREATE INDEX "idx_org_call_types_active" ON "public"."org_call_types" USING "btree" ("org_id", "is_active") WHERE ("is_active" = true);

CREATE INDEX "idx_org_call_types_display_order" ON "public"."org_call_types" USING "btree" ("org_id", "display_order");

CREATE INDEX "idx_org_call_types_org_id" ON "public"."org_call_types" USING "btree" ("org_id");

CREATE INDEX "idx_org_context_key" ON "public"."organization_context" USING "btree" ("context_key");

CREATE INDEX "idx_org_context_lookup" ON "public"."organization_context" USING "btree" ("organization_id", "context_key");

CREATE INDEX "idx_org_context_org_id" ON "public"."organization_context" USING "btree" ("organization_id");

CREATE INDEX "idx_org_email_categorization_settings_org" ON "public"."org_email_categorization_settings" USING "btree" ("org_id");

CREATE INDEX "idx_org_email_categorization_settings_updated_by" ON "public"."org_email_categorization_settings" USING "btree" ("updated_by");

CREATE INDEX "idx_org_enrichment_domain" ON "public"."organization_enrichment" USING "btree" ("domain");

CREATE INDEX "idx_org_enrichment_org_id" ON "public"."organization_enrichment" USING "btree" ("organization_id");

CREATE INDEX "idx_org_enrichment_status" ON "public"."organization_enrichment" USING "btree" ("status");

CREATE INDEX "idx_org_proposal_workflows_active" ON "public"."org_proposal_workflows" USING "btree" ("org_id", "is_active");

CREATE INDEX "idx_org_proposal_workflows_created_by" ON "public"."org_proposal_workflows" USING "btree" ("created_by");

CREATE INDEX "idx_org_proposal_workflows_org_id" ON "public"."org_proposal_workflows" USING "btree" ("org_id");

CREATE INDEX "idx_org_skills_active" ON "public"."organization_skills" USING "btree" ("is_active") WHERE ("is_active" = true);

CREATE INDEX "idx_org_skills_compilation" ON "public"."organization_skills" USING "btree" ("organization_id", "is_enabled") WHERE (("is_enabled" = true) AND ("last_compiled_at" IS NOT NULL));

CREATE INDEX "idx_org_skills_enabled" ON "public"."organization_skills" USING "btree" ("is_enabled") WHERE ("is_enabled" = true);

CREATE INDEX "idx_org_skills_history_skill" ON "public"."organization_skills_history" USING "btree" ("skill_record_id");

CREATE INDEX "idx_org_skills_org_id" ON "public"."organization_skills" USING "btree" ("organization_id");

CREATE INDEX "idx_org_skills_platform_skill" ON "public"."organization_skills" USING "btree" ("platform_skill_id");

CREATE INDEX "idx_org_skills_skill_id" ON "public"."organization_skills" USING "btree" ("skill_id");

CREATE INDEX "idx_org_subscriptions_customer_country" ON "public"."organization_subscriptions" USING "btree" ("customer_country") WHERE ("customer_country" IS NOT NULL);

CREATE INDEX "idx_org_subscriptions_first_payment" ON "public"."organization_subscriptions" USING "btree" ("first_payment_at") WHERE ("first_payment_at" IS NOT NULL);

CREATE INDEX "idx_org_subscriptions_org_id" ON "public"."organization_subscriptions" USING "btree" ("org_id");

CREATE INDEX "idx_org_subscriptions_plan_id" ON "public"."organization_subscriptions" USING "btree" ("plan_id");

CREATE INDEX "idx_org_subscriptions_recurring_amount" ON "public"."organization_subscriptions" USING "btree" ("current_recurring_amount_cents") WHERE ("current_recurring_amount_cents" IS NOT NULL);

CREATE INDEX "idx_org_subscriptions_recurring_interval" ON "public"."organization_subscriptions" USING "btree" ("recurring_interval");

CREATE INDEX "idx_org_usage_period" ON "public"."organization_usage" USING "btree" ("period_start", "period_end");

CREATE INDEX "idx_organization_feature_flags_enabled_by_fk" ON "public"."organization_feature_flags" USING "btree" ("enabled_by");

CREATE INDEX "idx_organization_invitations_email" ON "public"."organization_invitations" USING "btree" ("email");

CREATE INDEX "idx_organization_invitations_expires_at" ON "public"."organization_invitations" USING "btree" ("expires_at") WHERE ("accepted_at" IS NULL);

CREATE INDEX "idx_organization_invitations_invited_by_fk" ON "public"."organization_invitations" USING "btree" ("invited_by");

CREATE INDEX "idx_organization_invitations_org_id" ON "public"."organization_invitations" USING "btree" ("org_id");

CREATE INDEX "idx_organization_invitations_token" ON "public"."organization_invitations" USING "btree" ("token");

CREATE INDEX "idx_organization_memberships_org_id" ON "public"."organization_memberships" USING "btree" ("org_id");

CREATE INDEX "idx_organization_memberships_role" ON "public"."organization_memberships" USING "btree" ("role");

CREATE INDEX "idx_organization_memberships_user_id" ON "public"."organization_memberships" USING "btree" ("user_id");

CREATE INDEX "idx_organization_skills_created_by" ON "public"."organization_skills" USING "btree" ("created_by");

CREATE INDEX "idx_organization_skills_history_changed_by" ON "public"."organization_skills_history" USING "btree" ("changed_by");

CREATE INDEX "idx_organization_skills_history_organization_id" ON "public"."organization_skills_history" USING "btree" ("organization_id");

CREATE INDEX "idx_organizations_company_domain" ON "public"."organizations" USING "btree" ("company_domain");

CREATE INDEX "idx_organizations_company_enrichment_status" ON "public"."organizations" USING "btree" ("company_enrichment_status");

CREATE INDEX "idx_organizations_created_at" ON "public"."organizations" USING "btree" ("created_at");

CREATE INDEX "idx_organizations_created_by" ON "public"."organizations" USING "btree" ("created_by");

CREATE INDEX "idx_organizations_is_active" ON "public"."organizations" USING "btree" ("is_active");

CREATE INDEX "idx_page_views_created_at" ON "public"."page_views" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_page_views_landing_page" ON "public"."page_views" USING "btree" ("landing_page");

CREATE INDEX "idx_page_views_session_id" ON "public"."page_views" USING "btree" ("session_id");

CREATE INDEX "idx_page_views_utm_composite" ON "public"."page_views" USING "btree" ("utm_source", "utm_campaign", "utm_content", "landing_page");

CREATE INDEX "idx_page_views_utm_source" ON "public"."page_views" USING "btree" ("utm_source");

CREATE INDEX "idx_page_views_visitor_id" ON "public"."page_views" USING "btree" ("visitor_id");

CREATE INDEX "idx_partial_signups_converted" ON "public"."partial_signups" USING "btree" ("converted") WHERE ("converted" = false);

CREATE INDEX "idx_partial_signups_created_at" ON "public"."partial_signups" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_partial_signups_email" ON "public"."partial_signups" USING "btree" ("email");

CREATE UNIQUE INDEX "idx_partial_signups_email_session" ON "public"."partial_signups" USING "btree" ("email", "session_id");

CREATE INDEX "idx_partial_signups_landing_page" ON "public"."partial_signups" USING "btree" ("landing_page");

CREATE INDEX "idx_partial_signups_session" ON "public"."partial_signups" USING "btree" ("session_id");

CREATE INDEX "idx_pipeline_automation_log_rule_id" ON "public"."pipeline_automation_log" USING "btree" ("rule_id");

CREATE INDEX "idx_pipeline_automation_rules_created_by" ON "public"."pipeline_automation_rules" USING "btree" ("created_by");

CREATE INDEX "idx_pipeline_log_deal" ON "public"."pipeline_automation_log" USING "btree" ("deal_id", "created_at" DESC);

CREATE INDEX "idx_pipeline_log_meeting" ON "public"."pipeline_automation_log" USING "btree" ("meeting_id");

CREATE INDEX "idx_pipeline_log_org" ON "public"."pipeline_automation_log" USING "btree" ("org_id", "created_at" DESC);

CREATE INDEX "idx_pipeline_recommendations_meeting" ON "public"."pipeline_stage_recommendations" USING "btree" ("meeting_id");

CREATE INDEX "idx_pipeline_recommendations_user" ON "public"."pipeline_stage_recommendations" USING "btree" ("user_id");

CREATE INDEX "idx_pipeline_rules_org" ON "public"."pipeline_automation_rules" USING "btree" ("org_id", "is_active");

CREATE INDEX "idx_pipeline_rules_trigger" ON "public"."pipeline_automation_rules" USING "btree" ("org_id", "trigger_type") WHERE ("is_active" = true);

CREATE INDEX "idx_pipeline_stage_recommendations_company_id" ON "public"."pipeline_stage_recommendations" USING "btree" ("company_id");

CREATE INDEX "idx_pipeline_stage_recommendations_contact_fk" ON "public"."pipeline_stage_recommendations" USING "btree" ("contact_id");

CREATE INDEX "idx_pipeline_stage_recommendations_deal_id" ON "public"."pipeline_stage_recommendations" USING "btree" ("deal_id");

CREATE INDEX "idx_pipeline_stage_recommendations_reviewed_by_fk" ON "public"."pipeline_stage_recommendations" USING "btree" ("reviewed_by");

CREATE INDEX "idx_platform_skills_active" ON "public"."platform_skills" USING "btree" ("is_active") WHERE ("is_active" = true);

CREATE INDEX "idx_platform_skills_category" ON "public"."platform_skills" USING "btree" ("category");

CREATE INDEX "idx_platform_skills_created_by" ON "public"."platform_skills" USING "btree" ("created_by");

CREATE INDEX "idx_platform_skills_history_changed_by" ON "public"."platform_skills_history" USING "btree" ("changed_by");

CREATE INDEX "idx_platform_skills_history_skill" ON "public"."platform_skills_history" USING "btree" ("skill_id");

CREATE INDEX "idx_platform_skills_history_version" ON "public"."platform_skills_history" USING "btree" ("skill_id", "version");

CREATE INDEX "idx_platform_skills_key" ON "public"."platform_skills" USING "btree" ("skill_key");

CREATE INDEX "idx_pm_coverage_calculated" ON "public"."process_map_coverage_snapshots" USING "btree" ("calculated_at" DESC);

CREATE INDEX "idx_pm_coverage_org" ON "public"."process_map_coverage_snapshots" USING "btree" ("org_id");

CREATE INDEX "idx_pm_coverage_process_map" ON "public"."process_map_coverage_snapshots" USING "btree" ("process_map_id");

CREATE INDEX "idx_pm_coverage_workflow" ON "public"."process_map_coverage_snapshots" USING "btree" ("workflow_id");

CREATE INDEX "idx_pm_fixtures_org" ON "public"."process_map_fixtures" USING "btree" ("org_id");

CREATE INDEX "idx_pm_fixtures_type" ON "public"."process_map_fixtures" USING "btree" ("fixture_type");

CREATE INDEX "idx_pm_fixtures_workflow" ON "public"."process_map_fixtures" USING "btree" ("workflow_id");

CREATE INDEX "idx_pm_mocks_integration" ON "public"."process_map_mocks" USING "btree" ("integration");

CREATE INDEX "idx_pm_mocks_org" ON "public"."process_map_mocks" USING "btree" ("org_id");

CREATE INDEX "idx_pm_mocks_workflow" ON "public"."process_map_mocks" USING "btree" ("workflow_id");

CREATE INDEX "idx_pm_scenario_runs_executed" ON "public"."process_map_scenario_runs" USING "btree" ("executed_at" DESC);

CREATE INDEX "idx_pm_scenario_runs_scenario" ON "public"."process_map_scenario_runs" USING "btree" ("scenario_id");

CREATE INDEX "idx_pm_scenario_runs_test_run" ON "public"."process_map_scenario_runs" USING "btree" ("test_run_id");

CREATE INDEX "idx_pm_scenarios_hash" ON "public"."process_map_test_scenarios" USING "btree" ("process_structure_hash");

CREATE INDEX "idx_pm_scenarios_org" ON "public"."process_map_test_scenarios" USING "btree" ("org_id");

CREATE INDEX "idx_pm_scenarios_process_map" ON "public"."process_map_test_scenarios" USING "btree" ("process_map_id");

CREATE INDEX "idx_pm_scenarios_type" ON "public"."process_map_test_scenarios" USING "btree" ("scenario_type");

CREATE INDEX "idx_pm_scenarios_workflow" ON "public"."process_map_test_scenarios" USING "btree" ("workflow_id");

CREATE INDEX "idx_pm_step_results_run" ON "public"."process_map_step_results" USING "btree" ("test_run_id");

CREATE INDEX "idx_pm_step_results_step" ON "public"."process_map_step_results" USING "btree" ("step_id");

CREATE INDEX "idx_pm_test_runs_created" ON "public"."process_map_test_runs" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_pm_test_runs_org" ON "public"."process_map_test_runs" USING "btree" ("org_id");

CREATE INDEX "idx_pm_test_runs_status" ON "public"."process_map_test_runs" USING "btree" ("status");

CREATE INDEX "idx_pm_test_runs_workflow" ON "public"."process_map_test_runs" USING "btree" ("workflow_id");

CREATE INDEX "idx_pm_workflows_org" ON "public"."process_map_workflows" USING "btree" ("org_id");

CREATE INDEX "idx_pm_workflows_process_map" ON "public"."process_map_workflows" USING "btree" ("process_map_id");

CREATE INDEX "idx_process_map_test_runs_run_by" ON "public"."process_map_test_runs" USING "btree" ("run_by");

CREATE INDEX "idx_process_maps_generated_by" ON "public"."process_maps" USING "btree" ("generated_by");

CREATE INDEX "idx_process_maps_org_id" ON "public"."process_maps" USING "btree" ("org_id");

CREATE INDEX "idx_process_maps_org_type_name" ON "public"."process_maps" USING "btree" ("org_id", "process_type", "process_name");

CREATE INDEX "idx_process_maps_process_name" ON "public"."process_maps" USING "btree" ("process_name");

CREATE INDEX "idx_process_maps_process_type" ON "public"."process_maps" USING "btree" ("process_type");

CREATE INDEX "idx_process_maps_structure_nodes" ON "public"."process_maps" USING "gin" ((("process_structure" -> 'nodes'::"text")));

CREATE INDEX "idx_process_maps_structure_version" ON "public"."process_maps" USING "btree" ((("process_structure" ->> 'schemaVersion'::"text")));

CREATE INDEX "idx_profiles_timezone" ON "public"."profiles" USING "btree" ("timezone") WHERE ("timezone" IS NOT NULL);

CREATE INDEX "idx_proposal_jobs_user_fk" ON "public"."proposal_jobs" USING "btree" ("user_id");

CREATE INDEX "idx_proposal_jobs_user_status" ON "public"."proposal_jobs" USING "btree" ("user_id", "status");

CREATE INDEX "idx_proposal_templates_user_fk" ON "public"."proposal_templates" USING "btree" ("user_id");

CREATE INDEX "idx_proposals_contact_fk" ON "public"."proposals" USING "btree" ("contact_id");

CREATE INDEX "idx_proposals_meeting_fk" ON "public"."proposals" USING "btree" ("meeting_id");

CREATE INDEX "idx_proposals_user_fk" ON "public"."proposals" USING "btree" ("user_id");

CREATE INDEX "idx_rate_limit_created_at" ON "public"."rate_limit" USING "btree" ("created_at");

CREATE INDEX "idx_rate_limit_user_endpoint" ON "public"."rate_limit" USING "btree" ("user_id", "endpoint");

CREATE INDEX "idx_rate_limit_user_fk" ON "public"."rate_limit" USING "btree" ("user_id");

CREATE UNIQUE INDEX "idx_rate_limits_unique" ON "public"."workflow_rate_limits" USING "btree" ("workflow_id", "node_id", "limit_key") WHERE (("workflow_id" IS NOT NULL) AND ("node_id" IS NOT NULL));

CREATE UNIQUE INDEX "idx_rate_limits_unique_global" ON "public"."workflow_rate_limits" USING "btree" ("limit_key") WHERE (("workflow_id" IS NULL) AND ("node_id" IS NULL));

CREATE INDEX "idx_recording_rules_active" ON "public"."recording_rules" USING "btree" ("org_id", "is_active", "priority" DESC);

CREATE INDEX "idx_recording_rules_org" ON "public"."recording_rules" USING "btree" ("org_id");

CREATE INDEX "idx_recording_rules_user" ON "public"."recording_rules" USING "btree" ("user_id");

CREATE INDEX "idx_recording_usage_org_period" ON "public"."recording_usage" USING "btree" ("org_id", "period_start" DESC);

CREATE INDEX "idx_recordings_bot" ON "public"."recordings" USING "btree" ("bot_id");

CREATE INDEX "idx_recordings_calendar_event" ON "public"."recordings" USING "btree" ("calendar_event_id");

CREATE INDEX "idx_recordings_created" ON "public"."recordings" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_recordings_crm_synced" ON "public"."recordings" USING "btree" ("crm_synced") WHERE ("crm_synced" = false);

CREATE INDEX "idx_recordings_deal" ON "public"."recordings" USING "btree" ("crm_deal_id");

CREATE INDEX "idx_recordings_org" ON "public"."recordings" USING "btree" ("org_id");

CREATE INDEX "idx_recordings_status" ON "public"."recordings" USING "btree" ("status");

CREATE INDEX "idx_recordings_transcript_search" ON "public"."recordings" USING "gin" ("to_tsvector"('"english"'::"regconfig", "transcript_text"));

CREATE INDEX "idx_recordings_user" ON "public"."recordings" USING "btree" ("user_id");

CREATE INDEX "idx_reengagement_log_org" ON "public"."reengagement_log" USING "btree" ("org_id", "sent_at" DESC);

CREATE INDEX "idx_reengagement_log_segment" ON "public"."reengagement_log" USING "btree" ("segment_at_send", "sent_at" DESC);

CREATE INDEX "idx_reengagement_log_type" ON "public"."reengagement_log" USING "btree" ("reengagement_type", "sent_at" DESC);

CREATE INDEX "idx_reengagement_log_user" ON "public"."reengagement_log" USING "btree" ("user_id", "sent_at" DESC);

CREATE INDEX "idx_relationship_health_company" ON "public"."relationship_health_scores" USING "btree" ("company_id") WHERE ("company_id" IS NOT NULL);

CREATE INDEX "idx_relationship_health_contact" ON "public"."relationship_health_scores" USING "btree" ("contact_id") WHERE ("contact_id" IS NOT NULL);

CREATE INDEX "idx_relationship_health_user" ON "public"."relationship_health_scores" USING "btree" ("user_id");

CREATE INDEX "idx_relationship_history_relationship_time" ON "public"."relationship_health_history" USING "btree" ("relationship_health_id", "snapshot_at" DESC);

CREATE INDEX "idx_relationship_history_user" ON "public"."relationship_health_history" USING "btree" ("user_id");

CREATE INDEX "idx_roadmap_comments_user_fk" ON "public"."roadmap_comments" USING "btree" ("user_id");

CREATE INDEX "idx_savvycal_integration_secrets_org_id" ON "public"."savvycal_integration_secrets" USING "btree" ("org_id");

CREATE INDEX "idx_savvycal_integrations_connected_by_user_id" ON "public"."savvycal_integrations" USING "btree" ("connected_by_user_id");

CREATE INDEX "idx_savvycal_integrations_org_id" ON "public"."savvycal_integrations" USING "btree" ("org_id") WHERE ("is_active" = true);

CREATE INDEX "idx_savvycal_integrations_webhook_token" ON "public"."savvycal_integrations" USING "btree" ("webhook_token");

CREATE INDEX "idx_savvycal_source_mappings_created_by_fk" ON "public"."savvycal_source_mappings" USING "btree" ("created_by");

CREATE INDEX "idx_savvycal_source_mappings_source_id" ON "public"."savvycal_source_mappings" USING "btree" ("source_id");

CREATE INDEX "idx_sentiment_alerts_contact_id" ON "public"."sentiment_alerts" USING "btree" ("contact_id");

CREATE INDEX "idx_sentiment_alerts_meeting_id" ON "public"."sentiment_alerts" USING "btree" ("meeting_id");

CREATE INDEX "idx_sentiment_alerts_user_id" ON "public"."sentiment_alerts" USING "btree" ("user_id");

CREATE INDEX "idx_sentry_bridge_metrics_bucket" ON "public"."sentry_bridge_metrics" USING "btree" ("org_id", "bucket_start" DESC);

CREATE INDEX "idx_sentry_bridge_queue_org_id" ON "public"."sentry_bridge_queue" USING "btree" ("org_id");

CREATE INDEX "idx_sentry_bridge_queue_pending" ON "public"."sentry_bridge_queue" USING "btree" ("next_attempt_at") WHERE ("status" = 'pending'::"text");

CREATE INDEX "idx_sentry_bridge_queue_processing" ON "public"."sentry_bridge_queue" USING "btree" ("locked_at") WHERE ("status" = 'processing'::"text");

CREATE INDEX "idx_sentry_bridge_queue_routing_rule_id" ON "public"."sentry_bridge_queue" USING "btree" ("routing_rule_id");

CREATE INDEX "idx_sentry_bridge_queue_webhook_event_id" ON "public"."sentry_bridge_queue" USING "btree" ("webhook_event_id");

CREATE INDEX "idx_sentry_dead_letter_queue_resolved_by" ON "public"."sentry_dead_letter_queue" USING "btree" ("resolved_by");

CREATE INDEX "idx_sentry_dead_letter_queue_webhook_event_id" ON "public"."sentry_dead_letter_queue" USING "btree" ("webhook_event_id");

CREATE INDEX "idx_sentry_dlq_org" ON "public"."sentry_dead_letter_queue" USING "btree" ("org_id", "status");

CREATE INDEX "idx_sentry_dlq_pending" ON "public"."sentry_dead_letter_queue" USING "btree" ("created_at") WHERE ("status" = 'pending'::"text");

CREATE INDEX "idx_sentry_issue_mappings_dev_hub" ON "public"."sentry_issue_mappings" USING "btree" ("dev_hub_task_id");

CREATE INDEX "idx_sentry_issue_mappings_error_hash" ON "public"."sentry_issue_mappings" USING "btree" ("error_hash");

CREATE INDEX "idx_sentry_issue_mappings_sentry_id" ON "public"."sentry_issue_mappings" USING "btree" ("sentry_issue_id");

CREATE INDEX "idx_sentry_routing_rules_config_id" ON "public"."sentry_routing_rules" USING "btree" ("config_id");

CREATE INDEX "idx_sentry_routing_rules_org" ON "public"."sentry_routing_rules" USING "btree" ("org_id");

CREATE INDEX "idx_sentry_routing_rules_priority" ON "public"."sentry_routing_rules" USING "btree" ("org_id", "priority") WHERE ("enabled" = true);

CREATE INDEX "idx_sentry_triage_queue_matched_rule_id" ON "public"."sentry_triage_queue" USING "btree" ("matched_rule_id");

CREATE INDEX "idx_sentry_triage_queue_org" ON "public"."sentry_triage_queue" USING "btree" ("org_id", "status");

CREATE INDEX "idx_sentry_triage_queue_pending" ON "public"."sentry_triage_queue" USING "btree" ("created_at") WHERE ("status" = 'pending'::"text");

CREATE INDEX "idx_sentry_triage_queue_triaged_by" ON "public"."sentry_triage_queue" USING "btree" ("triaged_by");

CREATE INDEX "idx_sentry_triage_queue_webhook_event_id" ON "public"."sentry_triage_queue" USING "btree" ("webhook_event_id");

CREATE INDEX "idx_sentry_webhook_events_org" ON "public"."sentry_webhook_events" USING "btree" ("org_id");

CREATE INDEX "idx_sentry_webhook_events_received" ON "public"."sentry_webhook_events" USING "btree" ("received_at" DESC);

CREATE INDEX "idx_sentry_webhook_events_status" ON "public"."sentry_webhook_events" USING "btree" ("status") WHERE ("status" = ANY (ARRAY['received'::"text", 'processing'::"text"]));

CREATE INDEX "idx_sentry_webhook_queue_org_id" ON "public"."sentry_webhook_queue" USING "btree" ("org_id");

CREATE INDEX "idx_sentry_webhook_queue_status" ON "public"."sentry_webhook_queue" USING "btree" ("status", "priority", "created_at") WHERE ("status" = ANY (ARRAY['pending'::"text", 'retrying'::"text"]));

CREATE INDEX "idx_sequence_executions_created" ON "public"."sequence_executions" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_sequence_executions_hitl_waiting" ON "public"."sequence_executions" USING "btree" ("waiting_for_hitl") WHERE ("waiting_for_hitl" = true);

CREATE INDEX "idx_sequence_executions_org" ON "public"."sequence_executions" USING "btree" ("organization_id");

CREATE INDEX "idx_sequence_executions_sequence_key" ON "public"."sequence_executions" USING "btree" ("sequence_key");

CREATE INDEX "idx_sequence_executions_simulation" ON "public"."sequence_executions" USING "btree" ("is_simulation");

CREATE INDEX "idx_sequence_executions_status" ON "public"."sequence_executions" USING "btree" ("status");

CREATE INDEX "idx_sequence_executions_user" ON "public"."sequence_executions" USING "btree" ("user_id");

CREATE INDEX "idx_sequence_refs_instance" ON "public"."sequence_references_archive" USING "btree" ("sequence_instance_id");

CREATE INDEX "idx_sequence_refs_org" ON "public"."sequence_references_archive" USING "btree" ("organization_id");

CREATE INDEX "idx_sequence_refs_type" ON "public"."sequence_references_archive" USING "btree" ("reference_type");

CREATE INDEX "idx_skill_output_storage_created" ON "public"."skill_output_storage" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_skill_output_storage_expires" ON "public"."skill_output_storage" USING "btree" ("expires_at") WHERE ("expires_at" IS NOT NULL);

CREATE INDEX "idx_skill_output_storage_org" ON "public"."skill_output_storage" USING "btree" ("organization_id");

CREATE INDEX "idx_skill_output_storage_path" ON "public"."skill_output_storage" USING "btree" ("path");

CREATE INDEX "idx_skill_output_storage_type" ON "public"."skill_output_storage" USING "btree" ("content_type");

CREATE INDEX "idx_slack_deal_rooms_org_id" ON "public"."slack_deal_rooms" USING "btree" ("org_id");

CREATE INDEX "idx_slack_notification_settings_org_fk" ON "public"."slack_notification_settings" USING "btree" ("org_id");

CREATE INDEX "idx_slack_notifications_sent_dedupe_key" ON "public"."slack_notifications_sent" USING "btree" ("org_id", "dedupe_key") WHERE (("dedupe_key" IS NOT NULL) AND ("dedupe_key" <> ''::"text"));

CREATE INDEX "idx_slack_notifications_sent_dedupe_recent" ON "public"."slack_notifications_sent" USING "btree" ("dedupe_key", "sent_at" DESC) WHERE (("dedupe_key" IS NOT NULL) AND ("dedupe_key" <> ''::"text"));

CREATE INDEX "idx_slack_notifications_sent_org_fk" ON "public"."slack_notifications_sent" USING "btree" ("org_id");

CREATE INDEX "idx_slack_org_settings_connected_by_fk" ON "public"."slack_org_settings" USING "btree" ("connected_by");

CREATE INDEX "idx_slack_org_settings_org_id" ON "public"."slack_org_settings" USING "btree" ("org_id");

CREATE INDEX "idx_slack_user_mappings_org_fk" ON "public"."slack_user_mappings" USING "btree" ("org_id");

CREATE INDEX "idx_slack_user_mappings_org_slack" ON "public"."slack_user_mappings" USING "btree" ("org_id", "slack_user_id");

CREATE INDEX "idx_slack_user_mappings_sixty_user_id" ON "public"."slack_user_mappings" USING "btree" ("sixty_user_id");

CREATE INDEX "idx_smart_task_templates_created_by_fk" ON "public"."smart_task_templates" USING "btree" ("created_by");

CREATE INDEX "idx_solutions_challenge_fk" ON "public"."solutions" USING "btree" ("challenge_id");

CREATE INDEX "idx_subscription_plans_is_active" ON "public"."subscription_plans" USING "btree" ("is_active");

CREATE INDEX "idx_subscription_plans_is_public" ON "public"."subscription_plans" USING "btree" ("is_public");

CREATE INDEX "idx_subscription_seat_usage_org_id" ON "public"."subscription_seat_usage" USING "btree" ("org_id");

CREATE INDEX "idx_sync_conflicts_user_id" ON "public"."google_tasks_sync_conflicts" USING "btree" ("user_id");

CREATE INDEX "idx_system_config_key" ON "public"."system_config" USING "btree" ("key");

CREATE INDEX "idx_targets_closed_by_fk" ON "public"."targets" USING "btree" ("closed_by");

CREATE INDEX "idx_targets_created_by_fk" ON "public"."targets" USING "btree" ("created_by");

CREATE INDEX "idx_targets_previous_target_fk" ON "public"."targets" USING "btree" ("previous_target_id");

CREATE INDEX "idx_targets_team_fk" ON "public"."targets" USING "btree" ("team_id");

CREATE INDEX "idx_targets_user_fk" ON "public"."targets" USING "btree" ("user_id");

CREATE INDEX "idx_task_notifications_created_at" ON "public"."task_notifications" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_task_notifications_meeting_id" ON "public"."task_notifications" USING "btree" ("meeting_id");

CREATE INDEX "idx_task_notifications_user_id" ON "public"."task_notifications" USING "btree" ("user_id");

CREATE INDEX "idx_tasks_assigned_to" ON "public"."tasks" USING "btree" ("assigned_to");

CREATE INDEX "idx_tasks_call_action_item_id" ON "public"."tasks" USING "btree" ("call_action_item_id") WHERE ("call_action_item_id" IS NOT NULL);

CREATE INDEX "idx_tasks_call_id" ON "public"."tasks" USING "btree" ("call_id") WHERE ("call_id" IS NOT NULL);

CREATE INDEX "idx_tasks_company_fk" ON "public"."tasks" USING "btree" ("company_id");

CREATE INDEX "idx_tasks_contact_fk" ON "public"."tasks" USING "btree" ("contact_id");

CREATE INDEX "idx_tasks_created_by" ON "public"."tasks" USING "btree" ("created_by");

CREATE INDEX "idx_tasks_deal_fk" ON "public"."tasks" USING "btree" ("deal_id");

CREATE INDEX "idx_tasks_meeting_action_item_id" ON "public"."tasks" USING "btree" ("meeting_action_item_id");

CREATE INDEX "idx_tasks_meeting_id" ON "public"."tasks" USING "btree" ("meeting_id");

CREATE INDEX "idx_tasks_owner_id" ON "public"."tasks" USING "btree" ("owner_id");

CREATE INDEX "idx_tasks_parent_task_id" ON "public"."tasks" USING "btree" ("parent_task_id");

CREATE INDEX "idx_tasks_source_id" ON "public"."tasks" USING "btree" ("source_id") WHERE ("source_id" IS NOT NULL);

CREATE INDEX "idx_team_members_team_fk" ON "public"."team_members" USING "btree" ("team_id");

CREATE INDEX "idx_team_members_user_fk" ON "public"."team_members" USING "btree" ("user_id");

CREATE INDEX "idx_token_budgets_instance" ON "public"."sequence_token_budgets" USING "btree" ("sequence_instance_id");

CREATE INDEX "idx_token_budgets_org" ON "public"."sequence_token_budgets" USING "btree" ("organization_id");

CREATE INDEX "idx_token_budgets_over" ON "public"."sequence_token_budgets" USING "btree" ("organization_id", "over_budget") WHERE ("over_budget" = true);

CREATE INDEX "idx_tone_settings_user" ON "public"."user_tone_settings" USING "btree" ("user_id");

CREATE INDEX "idx_topic_aggregation_queue_meeting_fk" ON "public"."topic_aggregation_queue" USING "btree" ("meeting_id");

CREATE INDEX "idx_topic_aggregation_queue_user_fk" ON "public"."topic_aggregation_queue" USING "btree" ("user_id");

CREATE INDEX "idx_transcript_retry_jobs_failed" ON "public"."fathom_transcript_retry_jobs" USING "btree" ("status", "updated_at") WHERE ("status" = 'failed'::"text");

CREATE INDEX "idx_transcript_retry_jobs_meeting" ON "public"."fathom_transcript_retry_jobs" USING "btree" ("meeting_id");

CREATE INDEX "idx_transcript_retry_jobs_pending" ON "public"."fathom_transcript_retry_jobs" USING "btree" ("status", "next_retry_at") WHERE ("status" = ANY (ARRAY['pending'::"text", 'processing'::"text"]));

CREATE UNIQUE INDEX "idx_transcript_retry_jobs_unique_pending" ON "public"."fathom_transcript_retry_jobs" USING "btree" ("meeting_id") WHERE ("status" = ANY (ARRAY['pending'::"text", 'processing'::"text"]));

CREATE INDEX "idx_transcript_retry_jobs_user" ON "public"."fathom_transcript_retry_jobs" USING "btree" ("user_id", "status");

CREATE INDEX "idx_usage_events_org_id" ON "public"."usage_events" USING "btree" ("org_id");

CREATE INDEX "idx_usage_events_user_id" ON "public"."usage_events" USING "btree" ("user_id");

CREATE INDEX "idx_user_ai_feature_settings_user_id" ON "public"."user_ai_feature_settings" USING "btree" ("user_id");

CREATE INDEX "idx_user_ai_preferences_user_id" ON "public"."user_ai_preferences" USING "btree" ("user_id");

CREATE INDEX "idx_user_automation_rules_trigger_type" ON "public"."user_automation_rules" USING "btree" ("trigger_type") WHERE ("is_active" = true);

CREATE INDEX "idx_user_automation_rules_user_id" ON "public"."user_automation_rules" USING "btree" ("user_id");

CREATE INDEX "idx_user_coaching_preferences_user_id" ON "public"."user_coaching_preferences" USING "btree" ("user_id");

CREATE INDEX "idx_user_notifications_org_id" ON "public"."user_notifications" USING "btree" ("org_id");

CREATE INDEX "idx_user_notifications_user_id" ON "public"."user_notifications" USING "btree" ("user_id");

CREATE INDEX "idx_user_onboarding_progress_user_id" ON "public"."user_onboarding_progress" USING "btree" ("user_id");

CREATE INDEX "idx_user_writing_styles_user_id" ON "public"."user_writing_styles" USING "btree" ("user_id");

CREATE UNIQUE INDEX "idx_variable_storage_unique_global" ON "public"."variable_storage" USING "btree" ("scope", "key") WHERE (("scope" = 'global'::"text") AND ("workflow_id" IS NULL));

CREATE UNIQUE INDEX "idx_variable_storage_unique_workflow" ON "public"."variable_storage" USING "btree" ("workflow_id", "scope", "key") WHERE ("workflow_id" IS NOT NULL);

CREATE INDEX "idx_voice_recordings_meeting_id" ON "public"."voice_recordings" USING "btree" ("meeting_id") WHERE ("meeting_id" IS NOT NULL);

CREATE INDEX "idx_voice_recordings_org_id" ON "public"."voice_recordings" USING "btree" ("org_id");

CREATE INDEX "idx_voice_recordings_recorded_at" ON "public"."voice_recordings" USING "btree" ("recorded_at" DESC);

CREATE INDEX "idx_voice_recordings_share_token" ON "public"."voice_recordings" USING "btree" ("share_token") WHERE ("is_public" = true);

CREATE INDEX "idx_voice_recordings_status" ON "public"."voice_recordings" USING "btree" ("status");

CREATE INDEX "idx_voice_recordings_type" ON "public"."voice_recordings" USING "btree" ("recording_type");

CREATE INDEX "idx_voice_recordings_user_id" ON "public"."voice_recordings" USING "btree" ("user_id");

CREATE INDEX "idx_vsl_analytics_created_at" ON "public"."vsl_video_analytics" USING "btree" ("created_at");

CREATE INDEX "idx_vsl_analytics_event_type" ON "public"."vsl_video_analytics" USING "btree" ("event_type");

CREATE INDEX "idx_vsl_analytics_session_id" ON "public"."vsl_video_analytics" USING "btree" ("session_id");

CREATE INDEX "idx_vsl_analytics_signup_source" ON "public"."vsl_video_analytics" USING "btree" ("signup_source");

CREATE INDEX "idx_vsl_analytics_source_event_date" ON "public"."vsl_video_analytics" USING "btree" ("signup_source", "event_type", "created_at");

CREATE INDEX "idx_waitlist_created_at" ON "public"."meetings_waitlist" USING "btree" ("created_at");

CREATE INDEX "idx_waitlist_display_rank" ON "public"."meetings_waitlist" USING "btree" ("display_rank");

CREATE INDEX "idx_waitlist_effective_position" ON "public"."meetings_waitlist" USING "btree" ("effective_position");

CREATE INDEX "idx_waitlist_email" ON "public"."meetings_waitlist" USING "btree" ("email");

CREATE INDEX "idx_waitlist_email_templates_created_by_fk" ON "public"."waitlist_email_templates" USING "btree" ("created_by");

CREATE INDEX "idx_waitlist_invite_codes_active" ON "public"."waitlist_invite_codes" USING "btree" ("is_active") WHERE ("is_active" = true);

CREATE UNIQUE INDEX "idx_waitlist_invite_codes_upper" ON "public"."waitlist_invite_codes" USING "btree" ("upper"("code"));

CREATE INDEX "idx_waitlist_invited_user" ON "public"."meetings_waitlist" USING "btree" ("invited_user_id") WHERE ("invited_user_id" IS NOT NULL);

CREATE INDEX "idx_waitlist_onboarding_progress_waitlist_entry_id" ON "public"."waitlist_onboarding_progress" USING "btree" ("waitlist_entry_id");

CREATE INDEX "idx_waitlist_onboarding_user_id" ON "public"."waitlist_onboarding_progress" USING "btree" ("user_id");

CREATE INDEX "idx_waitlist_referral_code" ON "public"."meetings_waitlist" USING "btree" ("referral_code");

CREATE INDEX "idx_waitlist_referred_by" ON "public"."meetings_waitlist" USING "btree" ("referred_by_code");

CREATE INDEX "idx_waitlist_registration_url" ON "public"."meetings_waitlist" USING "btree" ("registration_url");

CREATE INDEX "idx_waitlist_shares_waitlist_entry_id" ON "public"."waitlist_shares" USING "btree" ("waitlist_entry_id");

CREATE INDEX "idx_waitlist_status" ON "public"."meetings_waitlist" USING "btree" ("status");

CREATE INDEX "idx_waitlist_total_points" ON "public"."meetings_waitlist" USING "btree" ("total_points" DESC);

CREATE INDEX "idx_waitlist_user_id" ON "public"."meetings_waitlist" USING "btree" ("user_id");

CREATE INDEX "idx_webhook_events_created" ON "public"."webhook_events" USING "btree" ("created_at" DESC);

CREATE INDEX "idx_webhook_events_event_id" ON "public"."webhook_events" USING "btree" ("source", "event_id");

CREATE INDEX "idx_webhook_events_source_type" ON "public"."webhook_events" USING "btree" ("source", "event_type");

CREATE INDEX "idx_webhook_events_status" ON "public"."webhook_events" USING "btree" ("status");

CREATE INDEX "idx_workflow_executions_user_id" ON "public"."workflow_executions" USING "btree" ("user_id");

CREATE INDEX "idx_workflow_forms_created_by_fk" ON "public"."workflow_forms" USING "btree" ("created_by");

CREATE INDEX "idx_workflow_mcp_logs_user_fk" ON "public"."workflow_mcp_logs" USING "btree" ("user_id");

CREATE INDEX "idx_workflow_results_call_type" ON "public"."meeting_workflow_results" USING "btree" ("call_type_id");

CREATE INDEX "idx_workflow_results_meeting" ON "public"."meeting_workflow_results" USING "btree" ("meeting_id");

CREATE INDEX "idx_workflow_results_org" ON "public"."meeting_workflow_results" USING "btree" ("org_id");

CREATE INDEX "idx_workflow_results_pending_notifications" ON "public"."meeting_workflow_results" USING "btree" ("notifications_scheduled_at") WHERE (("notifications_sent_at" IS NULL) AND ("notifications_scheduled_at" IS NOT NULL));

CREATE INDEX "notification_feedback_type_idx" ON "public"."notification_feedback" USING "btree" ("feedback_type", "created_at" DESC);

CREATE INDEX "notification_feedback_user_time_idx" ON "public"."notification_feedback" USING "btree" ("user_id", "created_at" DESC);

CREATE INDEX "notification_interactions_slack_ref_idx" ON "public"."notification_interactions" USING "btree" ("slack_notification_sent_id");

CREATE INDEX "notification_interactions_type_time_idx" ON "public"."notification_interactions" USING "btree" ("notification_type", "delivered_at" DESC);

CREATE INDEX "notification_interactions_user_time_idx" ON "public"."notification_interactions" USING "btree" ("user_id", "delivered_at" DESC);

CREATE INDEX "notification_queue_batch_idx" ON "public"."notification_queue" USING "btree" ("batch_id") WHERE ("batch_id" IS NOT NULL);

CREATE INDEX "notification_queue_dedupe_idx" ON "public"."notification_queue" USING "btree" ("user_id", "dedupe_key", "created_at") WHERE ("dedupe_key" IS NOT NULL);

CREATE INDEX "notification_queue_entity_idx" ON "public"."notification_queue" USING "btree" ("related_entity_type", "related_entity_id");

CREATE INDEX "notification_queue_org_status_idx" ON "public"."notification_queue" USING "btree" ("org_id", "status");

CREATE INDEX "notification_queue_pending_idx" ON "public"."notification_queue" USING "btree" ("scheduled_for", "priority") WHERE ("status" = 'pending'::"text");

CREATE INDEX "notification_queue_retry_idx" ON "public"."notification_queue" USING "btree" ("status", "last_attempt_at", "attempts") WHERE (("status" = 'failed'::"text") AND ("attempts" < 3));

CREATE INDEX "notification_queue_user_status_idx" ON "public"."notification_queue" USING "btree" ("user_id", "status", "scheduled_for");

CREATE INDEX "roadmap_comments_created_at_idx" ON "public"."roadmap_comments" USING "btree" ("created_at" DESC);

CREATE INDEX "roadmap_comments_suggestion_id_idx" ON "public"."roadmap_comments" USING "btree" ("suggestion_id");

CREATE INDEX "roadmap_suggestions_assigned_to_idx" ON "public"."roadmap_suggestions" USING "btree" ("assigned_to");

CREATE INDEX "roadmap_suggestions_created_at_idx" ON "public"."roadmap_suggestions" USING "btree" ("created_at" DESC);

CREATE INDEX "roadmap_suggestions_priority_idx" ON "public"."roadmap_suggestions" USING "btree" ("priority");

CREATE INDEX "roadmap_suggestions_status_idx" ON "public"."roadmap_suggestions" USING "btree" ("status");

CREATE INDEX "roadmap_suggestions_submitted_by_idx" ON "public"."roadmap_suggestions" USING "btree" ("submitted_by");

CREATE INDEX "roadmap_suggestions_type_idx" ON "public"."roadmap_suggestions" USING "btree" ("type");

CREATE INDEX "roadmap_votes_suggestion_id_idx" ON "public"."roadmap_votes" USING "btree" ("suggestion_id");

CREATE INDEX "roadmap_votes_user_id_idx" ON "public"."roadmap_votes" USING "btree" ("user_id");

CREATE UNIQUE INDEX "uq_meetings_org_fathom_recording" ON "public"."meetings" USING "btree" ("org_id", "fathom_recording_id") WHERE (("org_id" IS NOT NULL) AND ("fathom_recording_id" IS NOT NULL));

CREATE UNIQUE INDEX "uq_meetings_user_fathom_recording" ON "public"."meetings" USING "btree" ("owner_user_id", "fathom_recording_id") WHERE (("owner_user_id" IS NOT NULL) AND ("fathom_recording_id" IS NOT NULL));

COMMENT ON INDEX "public"."uq_meetings_user_fathom_recording" IS 'Ensures unique Fathom recordings per user. Complements org-scoped uniqueness.';

CREATE INDEX "user_activity_events_org_time_idx" ON "public"."user_activity_events" USING "btree" ("org_id", "event_at" DESC);

CREATE INDEX "user_activity_events_session_idx" ON "public"."user_activity_events" USING "btree" ("session_id");

CREATE INDEX "user_activity_events_type_time_idx" ON "public"."user_activity_events" USING "btree" ("event_type", "event_at" DESC);

CREATE INDEX "user_activity_events_user_time_idx" ON "public"."user_activity_events" USING "btree" ("user_id", "event_at" DESC);

CREATE INDEX "user_engagement_metrics_org_engagement_idx" ON "public"."user_engagement_metrics" USING "btree" ("org_id", "overall_engagement_score");

CREATE INDEX "user_engagement_metrics_segment_idx" ON "public"."user_engagement_metrics" USING "btree" ("user_segment");

CREATE UNIQUE INDEX "user_engagement_metrics_user_id_idx" ON "public"."user_engagement_metrics" USING "btree" ("user_id");

CREATE OR REPLACE TRIGGER "aa_set_signup_position_trigger" BEFORE INSERT ON "public"."meetings_waitlist" FOR EACH ROW EXECUTE FUNCTION "public"."set_signup_position"();

CREATE OR REPLACE TRIGGER "app_settings_updated_at_trigger" BEFORE UPDATE ON "public"."app_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_app_settings_updated_at"();

CREATE OR REPLACE TRIGGER "audit_activities_trigger" AFTER INSERT OR DELETE OR UPDATE ON "public"."activities" FOR EACH ROW EXECUTE FUNCTION "public"."audit_trigger_function"();

CREATE OR REPLACE TRIGGER "audit_companies_trigger" AFTER INSERT OR DELETE OR UPDATE ON "public"."companies" FOR EACH ROW EXECUTE FUNCTION "public"."audit_trigger_function"();

CREATE OR REPLACE TRIGGER "audit_contacts_trigger" AFTER INSERT OR DELETE OR UPDATE ON "public"."contacts" FOR EACH ROW EXECUTE FUNCTION "public"."audit_trigger_function"();

CREATE OR REPLACE TRIGGER "audit_deals_trigger" AFTER INSERT OR DELETE OR UPDATE ON "public"."deals" FOR EACH ROW EXECUTE FUNCTION "public"."audit_trigger_function"();

CREATE OR REPLACE TRIGGER "audit_tasks_trigger" AFTER INSERT OR DELETE OR UPDATE ON "public"."tasks" FOR EACH ROW EXECUTE FUNCTION "public"."audit_trigger_function"();

CREATE OR REPLACE TRIGGER "auto_assign_sixty_seconds_org_profiles_trigger" AFTER INSERT OR UPDATE OF "email" ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."auto_assign_to_sixty_seconds_org"();

CREATE OR REPLACE TRIGGER "auto_record_new_calendar_event" AFTER INSERT ON "public"."calendar_events" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_auto_record_for_new_event"();

CREATE OR REPLACE TRIGGER "auto_record_updated_calendar_event" AFTER UPDATE OF "meeting_url" ON "public"."calendar_events" FOR EACH ROW WHEN ((("old"."meeting_url" IS DISTINCT FROM "new"."meeting_url") AND ("new"."meeting_url" IS NOT NULL))) EXECUTE FUNCTION "public"."trigger_auto_record_for_new_event"();

CREATE OR REPLACE TRIGGER "award_email_points_trigger" AFTER INSERT OR UPDATE OF "invite_status" ON "public"."waitlist_email_invites" FOR EACH ROW EXECUTE FUNCTION "public"."award_email_invite_points"();

CREATE OR REPLACE TRIGGER "branding_settings_updated_at" BEFORE UPDATE ON "public"."branding_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_branding_settings_updated_at"();

CREATE OR REPLACE TRIGGER "calculate_ai_usage_cost" BEFORE INSERT ON "public"."ai_usage_logs" FOR EACH ROW EXECUTE FUNCTION "public"."auto_calculate_cost"();

CREATE OR REPLACE TRIGGER "calculate_points_trigger" BEFORE INSERT OR UPDATE OF "referral_count", "linkedin_boost_claimed", "twitter_boost_claimed", "linkedin_share_claimed", "signup_position" ON "public"."meetings_waitlist" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_waitlist_points"();

CREATE OR REPLACE TRIGGER "calculate_position_trigger" BEFORE INSERT OR UPDATE OF "referral_count", "signup_position" ON "public"."meetings_waitlist" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_effective_position"();

CREATE OR REPLACE TRIGGER "calculate_split_amount_trigger" BEFORE INSERT OR UPDATE ON "public"."deal_splits" FOR EACH ROW EXECUTE FUNCTION "public"."update_split_amount"();

CREATE OR REPLACE TRIGGER "clean_activity_fields_trigger" BEFORE INSERT OR UPDATE ON "public"."activities" FOR EACH ROW EXECUTE FUNCTION "public"."clean_activity_fields"();

CREATE OR REPLACE TRIGGER "clerk_mapping_updated_at" BEFORE UPDATE ON "public"."clerk_user_mappings" FOR EACH ROW EXECUTE FUNCTION "public"."update_clerk_mapping_updated_at"();

CREATE OR REPLACE TRIGGER "create_org_email_settings" AFTER INSERT ON "public"."organizations" FOR EACH ROW EXECUTE FUNCTION "public"."create_default_email_categorization_settings"();

CREATE OR REPLACE TRIGGER "create_relationship_health_snapshot_trigger" AFTER INSERT OR UPDATE ON "public"."relationship_health_scores" FOR EACH ROW EXECUTE FUNCTION "public"."create_relationship_health_snapshot"();

CREATE OR REPLACE TRIGGER "ensure_task_sync_status_trigger" BEFORE INSERT ON "public"."tasks" FOR EACH ROW EXECUTE FUNCTION "public"."ensure_task_sync_status"();

CREATE OR REPLACE TRIGGER "increment_invite_code_trigger" AFTER INSERT ON "public"."meetings_waitlist" FOR EACH ROW EXECUTE FUNCTION "public"."increment_invite_code_usage"();

CREATE OR REPLACE TRIGGER "increment_referral_trigger" AFTER INSERT ON "public"."meetings_waitlist" FOR EACH ROW EXECUTE FUNCTION "public"."increment_referral_count"();

CREATE OR REPLACE TRIGGER "launch_checklist_updated_at" BEFORE UPDATE ON "public"."launch_checklist_items" FOR EACH ROW EXECUTE FUNCTION "public"."update_launch_checklist_updated_at"();

CREATE OR REPLACE TRIGGER "log_admin_action_trigger" AFTER UPDATE ON "public"."meetings_waitlist" FOR EACH ROW WHEN ((("old"."status" IS DISTINCT FROM "new"."status") OR ("old"."released_at" IS DISTINCT FROM "new"."released_at"))) EXECUTE FUNCTION "public"."log_waitlist_admin_action"();

CREATE OR REPLACE TRIGGER "on_invited_user_created" AFTER INSERT ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."add_invited_user_to_admin_org"();

CREATE OR REPLACE TRIGGER "on_org_created_add_proposal_workflows" AFTER INSERT ON "public"."organizations" FOR EACH ROW EXECUTE FUNCTION "public"."create_default_org_proposal_workflows"();

CREATE OR REPLACE TRIGGER "on_waitlist_signup" AFTER INSERT ON "public"."meetings_waitlist" FOR EACH ROW EXECUTE FUNCTION "public"."notify_waitlist_signup"();

COMMENT ON TRIGGER "on_waitlist_signup" ON "public"."meetings_waitlist" IS 'Triggers Slack notification on new waitlist signup';

CREATE OR REPLACE TRIGGER "on_waitlist_update" AFTER UPDATE ON "public"."meetings_waitlist" FOR EACH ROW EXECUTE FUNCTION "public"."notify_waitlist_update"();

COMMENT ON TRIGGER "on_waitlist_update" ON "public"."meetings_waitlist" IS 'Triggers Slack notifications for referral milestones and tier upgrades';

CREATE OR REPLACE TRIGGER "org_ai_preferences_updated_at" BEFORE UPDATE ON "public"."org_ai_preferences" FOR EACH ROW EXECUTE FUNCTION "public"."update_ai_preferences_timestamp"();

CREATE OR REPLACE TRIGGER "partial_signups_updated_at" BEFORE UPDATE ON "public"."partial_signups" FOR EACH ROW EXECUTE FUNCTION "public"."update_partial_signups_updated_at"();

CREATE OR REPLACE TRIGGER "platform_skill_updated" AFTER UPDATE ON "public"."platform_skills" FOR EACH ROW WHEN ((("old"."content_template" IS DISTINCT FROM "new"."content_template") OR ("old"."frontmatter" IS DISTINCT FROM "new"."frontmatter"))) EXECUTE FUNCTION "public"."notify_skill_update"();

CREATE OR REPLACE TRIGGER "platform_skill_version_history" BEFORE UPDATE ON "public"."platform_skills" FOR EACH ROW WHEN ((("old"."content_template" IS DISTINCT FROM "new"."content_template") OR ("old"."frontmatter" IS DISTINCT FROM "new"."frontmatter"))) EXECUTE FUNCTION "public"."save_platform_skill_history"();

CREATE OR REPLACE TRIGGER "queue_new_topics_for_aggregation" AFTER INSERT OR UPDATE OF "topics" ON "public"."meeting_content_topics" FOR EACH ROW WHEN (("new"."deleted_at" IS NULL)) EXECUTE FUNCTION "public"."queue_topics_for_aggregation"();

CREATE OR REPLACE TRIGGER "roadmap_sync_on_delete" AFTER DELETE ON "public"."roadmap_suggestions" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_roadmap_sync_webhook"();

CREATE OR REPLACE TRIGGER "roadmap_sync_on_insert" AFTER INSERT ON "public"."roadmap_suggestions" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_roadmap_sync_webhook"();

CREATE OR REPLACE TRIGGER "roadmap_sync_on_update" AFTER UPDATE ON "public"."roadmap_suggestions" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_roadmap_sync_webhook"();

CREATE OR REPLACE TRIGGER "sentry_bridge_config_updated_at" BEFORE UPDATE ON "public"."sentry_bridge_config" FOR EACH ROW EXECUTE FUNCTION "public"."update_sentry_bridge_updated_at"();

CREATE OR REPLACE TRIGGER "sentry_issue_mappings_updated_at" BEFORE UPDATE ON "public"."sentry_issue_mappings" FOR EACH ROW EXECUTE FUNCTION "public"."update_sentry_bridge_updated_at"();

CREATE OR REPLACE TRIGGER "sentry_routing_rules_updated_at" BEFORE UPDATE ON "public"."sentry_routing_rules" FOR EACH ROW EXECUTE FUNCTION "public"."update_sentry_bridge_updated_at"();

CREATE OR REPLACE TRIGGER "set_ai_prompt_templates_updated_at" BEFORE UPDATE ON "public"."ai_prompt_templates" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "set_calendar_event_org_id_trigger" BEFORE INSERT ON "public"."calendar_events" FOR EACH ROW EXECUTE FUNCTION "public"."set_calendar_event_org_id"();

CREATE OR REPLACE TRIGGER "set_referral_code_trigger" BEFORE INSERT ON "public"."meetings_waitlist" FOR EACH ROW EXECUTE FUNCTION "public"."set_referral_code"();

CREATE OR REPLACE TRIGGER "set_signup_position_trigger" BEFORE INSERT ON "public"."meetings_waitlist" FOR EACH ROW EXECUTE FUNCTION "public"."set_signup_position"();

CREATE OR REPLACE TRIGGER "set_updated_at" BEFORE UPDATE ON "public"."waitlist_email_invites" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "sync_action_item_completion" AFTER UPDATE OF "completed" ON "public"."meeting_action_items" FOR EACH ROW EXECUTE FUNCTION "public"."sync_action_item_completion_to_task"();

CREATE OR REPLACE TRIGGER "sync_action_item_on_insert" AFTER INSERT ON "public"."meeting_action_items" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_sync_action_item_to_task"();

CREATE OR REPLACE TRIGGER "sync_action_item_on_update" AFTER UPDATE ON "public"."meeting_action_items" FOR EACH ROW WHEN ((("old"."title" IS DISTINCT FROM "new"."title") OR ("old"."priority" IS DISTINCT FROM "new"."priority") OR ("old"."deadline_at" IS DISTINCT FROM "new"."deadline_at") OR ("old"."completed" IS DISTINCT FROM "new"."completed") OR ("old"."assignee_email" IS DISTINCT FROM "new"."assignee_email"))) EXECUTE FUNCTION "public"."trigger_sync_action_item_to_task"();

CREATE OR REPLACE TRIGGER "sync_deal_activity_trigger" AFTER INSERT OR UPDATE ON "public"."deal_activities" FOR EACH ROW EXECUTE FUNCTION "public"."sync_deal_activity_to_main_activities"();

CREATE OR REPLACE TRIGGER "sync_task_completion" AFTER UPDATE OF "completed" ON "public"."tasks" FOR EACH ROW EXECUTE FUNCTION "public"."sync_task_completion_to_action_item"();

CREATE OR REPLACE TRIGGER "sync_task_on_update" AFTER UPDATE ON "public"."tasks" FOR EACH ROW WHEN ((("old"."title" IS DISTINCT FROM "new"."title") OR ("old"."description" IS DISTINCT FROM "new"."description") OR ("old"."priority" IS DISTINCT FROM "new"."priority") OR ("old"."due_date" IS DISTINCT FROM "new"."due_date") OR ("old"."status" IS DISTINCT FROM "new"."status"))) EXECUTE FUNCTION "public"."trigger_sync_task_to_action_item"();

CREATE OR REPLACE TRIGGER "sync_task_type_columns_trigger" BEFORE INSERT OR UPDATE ON "public"."tasks" FOR EACH ROW EXECUTE FUNCTION "public"."sync_task_type_columns"();

CREATE OR REPLACE TRIGGER "system_config_updated_at" BEFORE UPDATE ON "public"."system_config" FOR EACH ROW EXECUTE FUNCTION "public"."update_system_config_updated_at"();

CREATE OR REPLACE TRIGGER "trg_enqueue_hubspot_contact_outbound" AFTER INSERT OR UPDATE OF "email", "first_name", "last_name", "phone", "company", "title", "updated_at" ON "public"."contacts" FOR EACH ROW EXECUTE FUNCTION "public"."enqueue_hubspot_contact_outbound"();

CREATE OR REPLACE TRIGGER "trg_enqueue_hubspot_deal_outbound" AFTER INSERT OR UPDATE OF "name", "value", "expected_close_date", "stage_id", "primary_contact_id", "updated_at" ON "public"."deals" FOR EACH ROW EXECUTE FUNCTION "public"."enqueue_hubspot_deal_outbound"();

CREATE OR REPLACE TRIGGER "trg_enqueue_hubspot_proposal_quote" AFTER INSERT OR UPDATE OF "status", "title", "content", "updated_at" ON "public"."proposals" FOR EACH ROW EXECUTE FUNCTION "public"."enqueue_hubspot_proposal_quote"();

CREATE OR REPLACE TRIGGER "trg_enqueue_hubspot_task_outbound" AFTER INSERT OR UPDATE OF "title", "description", "due_date", "completed", "status", "assigned_to", "deal_id", "contact_id", "updated_at" ON "public"."tasks" FOR EACH ROW EXECUTE FUNCTION "public"."enqueue_hubspot_task_outbound"();

CREATE OR REPLACE TRIGGER "trg_update_lead_prep_notes_updated_at" BEFORE UPDATE ON "public"."lead_prep_notes" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "trg_update_lead_sources_updated_at" BEFORE UPDATE ON "public"."lead_sources" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "trg_update_leads_updated_at" BEFORE UPDATE ON "public"."leads" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "trigger_auto_org_for_new_user" AFTER INSERT ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."auto_create_org_for_new_user"();

CREATE OR REPLACE TRIGGER "trigger_auto_populate_suggestion_user_id" BEFORE INSERT ON "public"."next_action_suggestions" FOR EACH ROW EXECUTE FUNCTION "public"."auto_populate_suggestion_user_id"();

CREATE OR REPLACE TRIGGER "trigger_auto_process_activity_insert" BEFORE INSERT ON "public"."activities" FOR EACH ROW EXECUTE FUNCTION "public"."auto_process_activity"();

CREATE OR REPLACE TRIGGER "trigger_auto_process_activity_update" BEFORE UPDATE ON "public"."activities" FOR EACH ROW WHEN ((("old"."contact_identifier" IS DISTINCT FROM "new"."contact_identifier") AND ("new"."contact_identifier" IS NOT NULL) AND ("old"."contact_identifier" IS NULL))) EXECUTE FUNCTION "public"."auto_process_activity"();

CREATE OR REPLACE TRIGGER "trigger_auto_reset_stuck_fathom_sync" BEFORE UPDATE ON "public"."fathom_org_sync_state" FOR EACH ROW EXECUTE FUNCTION "public"."auto_reset_stuck_fathom_sync"();

CREATE OR REPLACE TRIGGER "trigger_auto_suggest_next_actions_activity" AFTER INSERT ON "public"."activities" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_suggest_next_actions_for_activity"();

CREATE OR REPLACE TRIGGER "trigger_close_plan_recalc_clarity" AFTER INSERT OR DELETE OR UPDATE ON "public"."deal_close_plan_items" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_recalculate_clarity_on_plan_change"();

CREATE OR REPLACE TRIGGER "trigger_create_client_from_won_deal" AFTER UPDATE ON "public"."deals" FOR EACH ROW EXECUTE FUNCTION "public"."create_client_from_won_deal"();

CREATE OR REPLACE TRIGGER "trigger_create_onboarding_progress" AFTER INSERT ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."create_onboarding_progress_for_new_user"();

CREATE OR REPLACE TRIGGER "trigger_create_smart_tasks" AFTER INSERT ON "public"."activities" FOR EACH ROW EXECUTE FUNCTION "public"."create_smart_tasks"();

CREATE OR REPLACE TRIGGER "trigger_deal_insert" AFTER INSERT ON "public"."deals" FOR EACH ROW EXECUTE FUNCTION "public"."handle_deal_insert"();

CREATE OR REPLACE TRIGGER "trigger_deal_insert_history" AFTER INSERT ON "public"."deals" FOR EACH ROW EXECUTE FUNCTION "public"."handle_deal_insert"();

CREATE OR REPLACE TRIGGER "trigger_deal_risk_signals_change" AFTER INSERT OR DELETE OR UPDATE ON "public"."deal_risk_signals" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_recalculate_deal_risk"();

CREATE OR REPLACE TRIGGER "trigger_deal_stage_change" AFTER UPDATE ON "public"."deals" FOR EACH ROW EXECUTE FUNCTION "public"."handle_deal_stage_change"();

CREATE OR REPLACE TRIGGER "trigger_deal_stage_change_history" AFTER UPDATE OF "stage_id" ON "public"."deals" FOR EACH ROW WHEN (("old"."stage_id" IS DISTINCT FROM "new"."stage_id")) EXECUTE FUNCTION "public"."handle_deal_stage_change"();

CREATE OR REPLACE TRIGGER "trigger_fathom_user_mappings_updated_at" BEFORE UPDATE ON "public"."fathom_user_mappings" FOR EACH ROW EXECUTE FUNCTION "public"."update_fathom_user_mappings_updated_at"();

CREATE OR REPLACE TRIGGER "trigger_notify_task_from_meeting" AFTER INSERT ON "public"."tasks" FOR EACH ROW WHEN (("new"."meeting_action_item_id" IS NOT NULL)) EXECUTE FUNCTION "public"."notify_task_from_meeting"();

CREATE OR REPLACE TRIGGER "trigger_notify_task_reassignment" AFTER UPDATE OF "assigned_to" ON "public"."tasks" FOR EACH ROW WHEN (("old"."assigned_to" IS DISTINCT FROM "new"."assigned_to")) EXECUTE FUNCTION "public"."notify_task_reassignment"();

CREATE OR REPLACE TRIGGER "trigger_prevent_task_circular_reference" BEFORE INSERT OR UPDATE ON "public"."tasks" FOR EACH ROW EXECUTE FUNCTION "public"."prevent_task_circular_reference"();

CREATE OR REPLACE TRIGGER "trigger_queue_call_index" AFTER INSERT OR UPDATE ON "public"."calls" FOR EACH ROW EXECUTE FUNCTION "public"."queue_call_for_indexing"();

CREATE OR REPLACE TRIGGER "trigger_truth_fields_recalc_clarity" AFTER INSERT OR DELETE OR UPDATE ON "public"."deal_truth_fields" FOR EACH ROW EXECUTE FUNCTION "public"."trigger_recalculate_clarity_on_truth_change"();

CREATE OR REPLACE TRIGGER "trigger_update_coaching_scorecard_templates_timestamp" BEFORE UPDATE ON "public"."coaching_scorecard_templates" FOR EACH ROW EXECUTE FUNCTION "public"."update_coaching_scorecard_templates_timestamp"();

CREATE OR REPLACE TRIGGER "trigger_update_conversation_on_message" AFTER INSERT ON "public"."copilot_messages" FOR EACH ROW EXECUTE FUNCTION "public"."update_copilot_conversation_updated_at"();

CREATE OR REPLACE TRIGGER "trigger_update_deal_clarity_scores_timestamp" BEFORE UPDATE ON "public"."deal_clarity_scores" FOR EACH ROW EXECUTE FUNCTION "public"."update_deal_clarity_scores_timestamp"();

CREATE OR REPLACE TRIGGER "trigger_update_deal_close_plan_timestamp" BEFORE UPDATE ON "public"."deal_close_plan_items" FOR EACH ROW EXECUTE FUNCTION "public"."update_deal_close_plan_timestamp"();

CREATE OR REPLACE TRIGGER "trigger_update_deal_risk_aggregates_timestamp" BEFORE UPDATE ON "public"."deal_risk_aggregates" FOR EACH ROW EXECUTE FUNCTION "public"."update_deal_risk_tables_timestamp"();

CREATE OR REPLACE TRIGGER "trigger_update_deal_risk_signals_timestamp" BEFORE UPDATE ON "public"."deal_risk_signals" FOR EACH ROW EXECUTE FUNCTION "public"."update_deal_risk_tables_timestamp"();

CREATE OR REPLACE TRIGGER "trigger_update_deal_truth_fields_timestamp" BEFORE UPDATE ON "public"."deal_truth_fields" FOR EACH ROW EXECUTE FUNCTION "public"."update_deal_truth_timestamp"();

CREATE OR REPLACE TRIGGER "trigger_update_meeting_classifications_timestamp" BEFORE UPDATE ON "public"."meeting_classifications" FOR EACH ROW EXECUTE FUNCTION "public"."update_deal_risk_tables_timestamp"();

CREATE OR REPLACE TRIGGER "trigger_update_meeting_scorecards_timestamp" BEFORE UPDATE ON "public"."meeting_scorecards" FOR EACH ROW EXECUTE FUNCTION "public"."update_coaching_scorecard_templates_timestamp"();

CREATE OR REPLACE TRIGGER "trigger_update_meeting_structured_summaries_timestamp" BEFORE UPDATE ON "public"."meeting_structured_summaries" FOR EACH ROW EXECUTE FUNCTION "public"."update_meeting_structured_summaries_timestamp"();

CREATE OR REPLACE TRIGGER "trigger_update_next_actions_count" AFTER INSERT OR DELETE ON "public"."next_action_suggestions" FOR EACH ROW EXECUTE FUNCTION "public"."update_next_actions_count"();

CREATE OR REPLACE TRIGGER "trigger_update_org_call_types_updated_at" BEFORE UPDATE ON "public"."org_call_types" FOR EACH ROW EXECUTE FUNCTION "public"."update_org_call_types_updated_at"();

CREATE OR REPLACE TRIGGER "trigger_update_pipeline_rules_updated_at" BEFORE UPDATE ON "public"."pipeline_automation_rules" FOR EACH ROW EXECUTE FUNCTION "public"."update_pipeline_rules_updated_at"();

CREATE OR REPLACE TRIGGER "trigger_update_pm_fixtures_updated_at" BEFORE UPDATE ON "public"."process_map_fixtures" FOR EACH ROW EXECUTE FUNCTION "public"."update_pm_workflows_updated_at"();

CREATE OR REPLACE TRIGGER "trigger_update_pm_mocks_updated_at" BEFORE UPDATE ON "public"."process_map_mocks" FOR EACH ROW EXECUTE FUNCTION "public"."update_pm_workflows_updated_at"();

CREATE OR REPLACE TRIGGER "trigger_update_pm_scenarios_updated_at" BEFORE UPDATE ON "public"."process_map_test_scenarios" FOR EACH ROW EXECUTE FUNCTION "public"."update_pm_workflows_updated_at"();

CREATE OR REPLACE TRIGGER "trigger_update_pm_workflows_updated_at" BEFORE UPDATE ON "public"."process_map_workflows" FOR EACH ROW EXECUTE FUNCTION "public"."update_pm_workflows_updated_at"();

CREATE OR REPLACE TRIGGER "trigger_update_process_maps_updated_at" BEFORE UPDATE ON "public"."process_maps" FOR EACH ROW EXECUTE FUNCTION "public"."update_process_maps_updated_at"();

CREATE OR REPLACE TRIGGER "trigger_update_segment_on_activity" AFTER INSERT ON "public"."user_activity_events" FOR EACH ROW EXECUTE FUNCTION "public"."on_user_activity_update_segment"();

CREATE OR REPLACE TRIGGER "trigger_update_suggestion_on_task_creation" BEFORE UPDATE ON "public"."next_action_suggestions" FOR EACH ROW WHEN ((("new"."created_task_id" IS NOT NULL) AND ("old"."created_task_id" IS NULL))) EXECUTE FUNCTION "public"."update_suggestion_on_task_creation"();

CREATE OR REPLACE TRIGGER "trigger_update_transcript_retry_job_updated_at" BEFORE UPDATE ON "public"."fathom_transcript_retry_jobs" FOR EACH ROW EXECUTE FUNCTION "public"."update_transcript_retry_job_updated_at"();

CREATE OR REPLACE TRIGGER "trigger_update_workflow_results_updated_at" BEFORE UPDATE ON "public"."meeting_workflow_results" FOR EACH ROW EXECUTE FUNCTION "public"."update_workflow_results_updated_at"();

CREATE OR REPLACE TRIGGER "update_action_items_updated_at" BEFORE UPDATE ON "public"."action_items" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_ai_insights_updated_at" BEFORE UPDATE ON "public"."ai_insights" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_api_keys_updated_at" BEFORE UPDATE ON "public"."api_keys" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_booking_sources_updated_at" BEFORE UPDATE ON "public"."booking_sources" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_bot_deployments_updated_at" BEFORE UPDATE ON "public"."bot_deployments" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_calendar_calendars_updated_at" BEFORE UPDATE ON "public"."calendar_calendars" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_calendar_events_updated_at" BEFORE UPDATE ON "public"."calendar_events" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_call_action_items_updated_at" BEFORE UPDATE ON "public"."call_action_items" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_calls_updated_at" BEFORE UPDATE ON "public"."calls" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_challenge_features_updated_at" BEFORE UPDATE ON "public"."challenge_features" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_challenges_updated_at" BEFORE UPDATE ON "public"."challenges" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_circuit_breakers_updated_at" BEFORE UPDATE ON "public"."workflow_circuit_breakers" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_clients_updated_at_trigger" BEFORE UPDATE ON "public"."clients" FOR EACH ROW EXECUTE FUNCTION "public"."update_clients_updated_at"();

CREATE OR REPLACE TRIGGER "update_contact_notes_updated_at" BEFORE UPDATE ON "public"."contact_notes" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_contact_stats_on_meeting_link" AFTER INSERT OR UPDATE ON "public"."meeting_contacts" FOR EACH ROW EXECUTE FUNCTION "public"."update_contact_meeting_stats"();

CREATE OR REPLACE TRIGGER "update_contact_stats_on_meeting_unlink" AFTER DELETE ON "public"."meeting_contacts" FOR EACH ROW EXECUTE FUNCTION "public"."update_contact_meeting_stats_on_delete"();

CREATE OR REPLACE TRIGGER "update_content_updated_at" BEFORE UPDATE ON "public"."content" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_copilot_analytics_updated_at" BEFORE UPDATE ON "public"."copilot_analytics" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_copilot_conversations_updated_at" BEFORE UPDATE ON "public"."copilot_conversations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_csv_mapping_templates_updated_at" BEFORE UPDATE ON "public"."csv_mapping_templates" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_deal_notes_updated_at" BEFORE UPDATE ON "public"."deal_notes" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_deal_revenue_trigger" BEFORE INSERT OR UPDATE ON "public"."deals" FOR EACH ROW EXECUTE FUNCTION "public"."update_deal_revenue_calculations"();

CREATE OR REPLACE TRIGGER "update_email_categorizations_updated_at" BEFORE UPDATE ON "public"."email_categorizations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_email_templates_updated_at" BEFORE UPDATE ON "public"."email_templates" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_email_threads_updated_at" BEFORE UPDATE ON "public"."email_threads" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_emails_updated_at" BEFORE UPDATE ON "public"."emails" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_fathom_integrations_updated_at" BEFORE UPDATE ON "public"."fathom_integrations" FOR EACH ROW EXECUTE FUNCTION "public"."update_fathom_updated_at"();

CREATE OR REPLACE TRIGGER "update_fathom_org_credentials_updated_at" BEFORE UPDATE ON "public"."fathom_org_credentials" FOR EACH ROW EXECUTE FUNCTION "public"."update_fathom_updated_at"();

CREATE OR REPLACE TRIGGER "update_fathom_org_integrations_updated_at" BEFORE UPDATE ON "public"."fathom_org_integrations" FOR EACH ROW EXECUTE FUNCTION "public"."update_fathom_updated_at"();

CREATE OR REPLACE TRIGGER "update_fathom_org_sync_state_updated_at" BEFORE UPDATE ON "public"."fathom_org_sync_state" FOR EACH ROW EXECUTE FUNCTION "public"."update_fathom_updated_at"();

CREATE OR REPLACE TRIGGER "update_fathom_sync_state_updated_at" BEFORE UPDATE ON "public"."fathom_sync_state" FOR EACH ROW EXECUTE FUNCTION "public"."update_fathom_updated_at"();

CREATE OR REPLACE TRIGGER "update_global_topics_updated_at" BEFORE UPDATE ON "public"."global_topics" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_gmail_label_mappings_updated_at" BEFORE UPDATE ON "public"."gmail_label_mappings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_google_calendars_updated_at" BEFORE UPDATE ON "public"."google_calendars" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_google_docs_templates_updated_at" BEFORE UPDATE ON "public"."google_docs_templates" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_google_drive_folders_updated_at" BEFORE UPDATE ON "public"."google_drive_folders" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_google_email_labels_updated_at" BEFORE UPDATE ON "public"."google_email_labels" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_google_integrations_updated_at" BEFORE UPDATE ON "public"."google_integrations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_google_tasks_sync_status_updated_at" BEFORE UPDATE ON "public"."google_tasks_sync_status" FOR EACH ROW EXECUTE FUNCTION "public"."update_google_tasks_updated_at"();

CREATE OR REPLACE TRIGGER "update_hitl_pending_approvals_updated_at" BEFORE UPDATE ON "public"."hitl_pending_approvals" FOR EACH ROW EXECUTE FUNCTION "public"."update_hitl_updated_at"();

CREATE OR REPLACE TRIGGER "update_hitl_requests_updated_at" BEFORE UPDATE ON "public"."hitl_requests" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_hitl_requests_updated_at" BEFORE UPDATE ON "public"."sequence_hitl_requests" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_hubspot_object_mappings_updated_at" BEFORE UPDATE ON "public"."hubspot_object_mappings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_hubspot_org_credentials_updated_at" BEFORE UPDATE ON "public"."hubspot_org_credentials" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_hubspot_org_integrations_updated_at" BEFORE UPDATE ON "public"."hubspot_org_integrations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_hubspot_org_sync_state_updated_at" BEFORE UPDATE ON "public"."hubspot_org_sync_state" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_hubspot_settings_updated_at" BEFORE UPDATE ON "public"."hubspot_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_intervention_templates_updated_at" BEFORE UPDATE ON "public"."intervention_templates" FOR EACH ROW EXECUTE FUNCTION "public"."update_intervention_templates_updated_at"();

CREATE OR REPLACE TRIGGER "update_interventions_updated_at" BEFORE UPDATE ON "public"."interventions" FOR EACH ROW EXECUTE FUNCTION "public"."update_interventions_updated_at"();

CREATE OR REPLACE TRIGGER "update_justcall_integration_secrets_updated_at" BEFORE UPDATE ON "public"."justcall_integration_secrets" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_justcall_integrations_updated_at" BEFORE UPDATE ON "public"."justcall_integrations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_mcp_connections_updated_at" BEFORE UPDATE ON "public"."mcp_connections" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_meeting_content_topics_updated_at" BEFORE UPDATE ON "public"."meeting_content_topics" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_meeting_documents_updated_at" BEFORE UPDATE ON "public"."meeting_documents" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_meeting_generated_content_updated_at" BEFORE UPDATE ON "public"."meeting_generated_content" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_meetingbaas_calendars_updated_at" BEFORE UPDATE ON "public"."meetingbaas_calendars" FOR EACH ROW EXECUTE FUNCTION "public"."update_meetingbaas_calendars_updated_at"();

CREATE OR REPLACE TRIGGER "update_node_fixtures_updated_at" BEFORE UPDATE ON "public"."node_fixtures" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_notetaker_user_settings_updated_at" BEFORE UPDATE ON "public"."notetaker_user_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_onboarding_progress_timestamp" BEFORE UPDATE ON "public"."user_onboarding_progress" FOR EACH ROW EXECUTE FUNCTION "public"."update_onboarding_progress_updated_at"();

CREATE OR REPLACE TRIGGER "update_org_context_updated_at" BEFORE UPDATE ON "public"."organization_context" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_org_email_categorization_settings_updated_at" BEFORE UPDATE ON "public"."org_email_categorization_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_org_enrichment_updated_at" BEFORE UPDATE ON "public"."organization_enrichment" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_org_proposal_workflows_updated_at" BEFORE UPDATE ON "public"."org_proposal_workflows" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_org_skills_updated_at" BEFORE UPDATE ON "public"."organization_skills" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_platform_skills_updated_at" BEFORE UPDATE ON "public"."platform_skills" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_pricing_plans_updated_at" BEFORE UPDATE ON "public"."pricing_plans" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_recording_rules_updated_at" BEFORE UPDATE ON "public"."recording_rules" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_recording_usage_updated_at" BEFORE UPDATE ON "public"."recording_usage" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_recordings_updated_at" BEFORE UPDATE ON "public"."recordings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_relationship_health_scores_updated_at" BEFORE UPDATE ON "public"."relationship_health_scores" FOR EACH ROW EXECUTE FUNCTION "public"."update_relationship_health_scores_updated_at"();

CREATE OR REPLACE TRIGGER "update_roadmap_comments_updated_at" BEFORE UPDATE ON "public"."roadmap_comments" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_roadmap_suggestions_updated_at" BEFORE UPDATE ON "public"."roadmap_suggestions" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_savvycal_integration_secrets_updated_at" BEFORE UPDATE ON "public"."savvycal_integration_secrets" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_savvycal_integrations_updated_at" BEFORE UPDATE ON "public"."savvycal_integrations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_savvycal_link_mappings_updated_at" BEFORE UPDATE ON "public"."savvycal_link_mappings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_savvycal_source_mappings_updated_at" BEFORE UPDATE ON "public"."savvycal_source_mappings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_scenario_fixtures_updated_at" BEFORE UPDATE ON "public"."scenario_fixtures" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_sentiment_alerts_timestamp" BEFORE UPDATE ON "public"."sentiment_alerts" FOR EACH ROW EXECUTE FUNCTION "public"."update_sentiment_alerts_updated_at"();

CREATE OR REPLACE TRIGGER "update_sequence_executions_updated_at" BEFORE UPDATE ON "public"."sequence_executions" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_slack_channels_updated_at" BEFORE UPDATE ON "public"."slack_channels" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_slack_integrations_updated_at" BEFORE UPDATE ON "public"."slack_integrations" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_slack_notification_settings_updated_at" BEFORE UPDATE ON "public"."slack_notification_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_slack_updated_at"();

CREATE OR REPLACE TRIGGER "update_slack_org_settings_updated_at" BEFORE UPDATE ON "public"."slack_org_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_slack_updated_at"();

CREATE OR REPLACE TRIGGER "update_slack_user_mappings_updated_at" BEFORE UPDATE ON "public"."slack_user_mappings" FOR EACH ROW EXECUTE FUNCTION "public"."update_slack_updated_at"();

CREATE OR REPLACE TRIGGER "update_solutions_updated_at" BEFORE UPDATE ON "public"."solutions" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_split_amounts_on_deal_change_trigger" AFTER UPDATE OF "value" ON "public"."deals" FOR EACH ROW WHEN (("old"."value" IS DISTINCT FROM "new"."value")) EXECUTE FUNCTION "public"."update_deal_split_amounts_on_deal_change"();

CREATE OR REPLACE TRIGGER "update_suggestion_votes_count_trigger" AFTER INSERT OR DELETE ON "public"."roadmap_votes" FOR EACH ROW EXECUTE FUNCTION "public"."update_suggestion_votes_count"();

CREATE OR REPLACE TRIGGER "update_task_sync_status_trigger" BEFORE INSERT OR UPDATE ON "public"."tasks" FOR EACH ROW EXECUTE FUNCTION "public"."update_task_sync_status"();

CREATE OR REPLACE TRIGGER "update_template_performance_on_intervention_change" AFTER UPDATE ON "public"."interventions" FOR EACH ROW WHEN (("old"."status" IS DISTINCT FROM "new"."status")) EXECUTE FUNCTION "public"."update_template_performance_on_intervention_change"();

CREATE OR REPLACE TRIGGER "update_thread_on_email_insert" AFTER INSERT ON "public"."emails" FOR EACH ROW WHEN (("new"."thread_id" IS NOT NULL)) EXECUTE FUNCTION "public"."update_thread_metadata"();

CREATE OR REPLACE TRIGGER "update_token_budgets_updated_at" BEFORE UPDATE ON "public"."sequence_token_budgets" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_user_ai_feature_settings_timestamp" BEFORE UPDATE ON "public"."user_ai_feature_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_user_ai_feature_settings_updated_at"();

CREATE OR REPLACE TRIGGER "update_user_coaching_preferences_updated_at" BEFORE UPDATE ON "public"."user_coaching_preferences" FOR EACH ROW EXECUTE FUNCTION "public"."update_user_coaching_preferences_updated_at"();

CREATE OR REPLACE TRIGGER "update_user_preferences_updated_at" BEFORE UPDATE ON "public"."user_preferences" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_user_settings_updated_at" BEFORE UPDATE ON "public"."user_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();

CREATE OR REPLACE TRIGGER "update_user_sync_status_timestamp" BEFORE UPDATE ON "public"."user_sync_status" FOR EACH ROW EXECUTE FUNCTION "public"."update_user_sync_status_updated_at"();

CREATE OR REPLACE TRIGGER "update_user_tone_settings_updated_at" BEFORE UPDATE ON "public"."user_tone_settings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_variable_storage_updated_at" BEFORE UPDATE ON "public"."variable_storage" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_waitlist_invite_codes_timestamp" BEFORE UPDATE ON "public"."waitlist_invite_codes" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();

CREATE OR REPLACE TRIGGER "update_waitlist_onboarding_completion" BEFORE INSERT OR UPDATE ON "public"."waitlist_onboarding_progress" FOR EACH ROW EXECUTE FUNCTION "public"."calculate_waitlist_onboarding_completion"();

CREATE OR REPLACE TRIGGER "update_waitlist_timestamp" BEFORE UPDATE ON "public"."meetings_waitlist" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at"();

CREATE OR REPLACE TRIGGER "update_webhook_events_updated_at" BEFORE UPDATE ON "public"."webhook_events" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_webhook_mirror_updated_at" BEFORE UPDATE ON "public"."webhook_mirror_config" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_workflow_contracts_updated_at" BEFORE UPDATE ON "public"."workflow_contracts" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_workflow_environments_updated_at" BEFORE UPDATE ON "public"."workflow_environments" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "update_workflow_stats_trigger" AFTER INSERT OR UPDATE ON "public"."automation_executions" FOR EACH ROW EXECUTE FUNCTION "public"."update_workflow_statistics"();

CREATE OR REPLACE TRIGGER "user_ai_preferences_updated_at" BEFORE UPDATE ON "public"."user_ai_preferences" FOR EACH ROW EXECUTE FUNCTION "public"."update_ai_preferences_timestamp"();

CREATE OR REPLACE TRIGGER "user_engagement_metrics_updated_at" BEFORE UPDATE ON "public"."user_engagement_metrics" FOR EACH ROW EXECUTE FUNCTION "public"."update_user_engagement_metrics_updated_at"();

CREATE OR REPLACE TRIGGER "validate_deal_splits_trigger" BEFORE INSERT OR UPDATE ON "public"."deal_splits" FOR EACH ROW EXECUTE FUNCTION "public"."validate_deal_split_percentages"();

CREATE OR REPLACE TRIGGER "voice_recordings_updated_at" BEFORE UPDATE ON "public"."voice_recordings" FOR EACH ROW EXECUTE FUNCTION "public"."update_updated_at_column"();

CREATE OR REPLACE TRIGGER "waitlist_email_templates_updated_at" BEFORE UPDATE ON "public"."waitlist_email_templates" FOR EACH ROW EXECUTE FUNCTION "public"."update_waitlist_email_template_timestamp"();

ALTER TABLE ONLY "public"."action_items"
    ADD CONSTRAINT "action_items_assignee_id_fkey" FOREIGN KEY ("assignee_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."action_items"
    ADD CONSTRAINT "action_items_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."action_items"
    ADD CONSTRAINT "action_items_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."action_items"
    ADD CONSTRAINT "action_items_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."action_items"
    ADD CONSTRAINT "action_items_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."activities"
    ADD CONSTRAINT "activities_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."activities"
    ADD CONSTRAINT "activities_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."activities"
    ADD CONSTRAINT "activities_original_activity_id_fkey" FOREIGN KEY ("original_activity_id") REFERENCES "public"."activities"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."activities"
    ADD CONSTRAINT "activities_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."activity_sync_rules"
    ADD CONSTRAINT "activity_sync_rules_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "public"."profiles"("id");

ALTER TABLE ONLY "public"."ai_cost_events"
    ADD CONSTRAINT "ai_cost_events_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."ai_cost_events"
    ADD CONSTRAINT "ai_cost_events_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."ai_feedback"
    ADD CONSTRAINT "ai_feedback_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."ai_feedback"
    ADD CONSTRAINT "ai_feedback_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."ai_insights"
    ADD CONSTRAINT "ai_insights_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."ai_insights"
    ADD CONSTRAINT "ai_insights_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."ai_insights"
    ADD CONSTRAINT "ai_insights_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."ai_prompt_template_history"
    ADD CONSTRAINT "ai_prompt_template_history_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."ai_prompt_template_history"
    ADD CONSTRAINT "ai_prompt_template_history_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."ai_prompt_templates"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."ai_prompt_templates"
    ADD CONSTRAINT "ai_prompt_templates_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."ai_prompt_templates"
    ADD CONSTRAINT "ai_prompt_templates_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."ai_prompt_templates"
    ADD CONSTRAINT "ai_prompt_templates_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."ai_usage_logs"
    ADD CONSTRAINT "ai_usage_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."api_key_usage"
    ADD CONSTRAINT "api_key_usage_api_key_id_fkey" FOREIGN KEY ("api_key_id") REFERENCES "public"."api_keys"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."api_keys"
    ADD CONSTRAINT "api_keys_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."api_monitor_rollups_daily"
    ADD CONSTRAINT "api_monitor_rollups_daily_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."api_requests"
    ADD CONSTRAINT "api_requests_api_key_id_fkey" FOREIGN KEY ("api_key_id") REFERENCES "public"."api_keys"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."api_requests"
    ADD CONSTRAINT "api_requests_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."audit_logs"
    ADD CONSTRAINT "audit_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."automation_executions"
    ADD CONSTRAINT "automation_executions_activity_id_fkey" FOREIGN KEY ("activity_id") REFERENCES "public"."activities"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."automation_executions"
    ADD CONSTRAINT "automation_executions_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."automation_executions"
    ADD CONSTRAINT "automation_executions_executed_by_fkey" FOREIGN KEY ("executed_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."automation_executions"
    ADD CONSTRAINT "automation_executions_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."tasks"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."billing_event_log"
    ADD CONSTRAINT "billing_event_log_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."billing_history"
    ADD CONSTRAINT "billing_history_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."billing_history"
    ADD CONSTRAINT "billing_history_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."organization_subscriptions"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."bot_deployments"
    ADD CONSTRAINT "bot_deployments_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."bot_deployments"
    ADD CONSTRAINT "bot_deployments_recording_id_fkey" FOREIGN KEY ("recording_id") REFERENCES "public"."recordings"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."branding_settings"
    ADD CONSTRAINT "branding_settings_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."branding_settings"
    ADD CONSTRAINT "branding_settings_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."calendar_attendees"
    ADD CONSTRAINT "calendar_attendees_event_id_fkey" FOREIGN KEY ("event_id") REFERENCES "public"."calendar_events"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."calendar_calendars"
    ADD CONSTRAINT "calendar_calendars_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."calendar_calendars"
    ADD CONSTRAINT "calendar_calendars_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."calendar_events"
    ADD CONSTRAINT "calendar_events_calendar_id_fkey" FOREIGN KEY ("calendar_id") REFERENCES "public"."calendar_calendars"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."calendar_events"
    ADD CONSTRAINT "calendar_events_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."calendar_events"
    ADD CONSTRAINT "calendar_events_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."calendar_events"
    ADD CONSTRAINT "calendar_events_mcp_connection_id_fkey" FOREIGN KEY ("mcp_connection_id") REFERENCES "public"."mcp_connections"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."calendar_events"
    ADD CONSTRAINT "calendar_events_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."calendar_reminders"
    ADD CONSTRAINT "calendar_reminders_event_id_fkey" FOREIGN KEY ("event_id") REFERENCES "public"."calendar_events"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."calendar_sync_logs"
    ADD CONSTRAINT "calendar_sync_logs_calendar_id_fkey" FOREIGN KEY ("calendar_id") REFERENCES "public"."calendar_calendars"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."calendar_sync_logs"
    ADD CONSTRAINT "calendar_sync_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."call_action_items"
    ADD CONSTRAINT "call_action_items_call_id_fkey" FOREIGN KEY ("call_id") REFERENCES "public"."calls"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."call_action_items"
    ADD CONSTRAINT "call_action_items_linked_task_id_fkey" FOREIGN KEY ("linked_task_id") REFERENCES "public"."tasks"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."call_action_items"
    ADD CONSTRAINT "call_action_items_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."call_file_search_index"
    ADD CONSTRAINT "call_file_search_index_call_id_fkey" FOREIGN KEY ("call_id") REFERENCES "public"."calls"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."call_file_search_index"
    ADD CONSTRAINT "call_file_search_index_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."call_file_search_index"
    ADD CONSTRAINT "call_file_search_index_owner_user_id_fkey" FOREIGN KEY ("owner_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."call_index_queue"
    ADD CONSTRAINT "call_index_queue_call_id_fkey" FOREIGN KEY ("call_id") REFERENCES "public"."calls"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."call_index_queue"
    ADD CONSTRAINT "call_index_queue_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."call_index_queue"
    ADD CONSTRAINT "call_index_queue_owner_user_id_fkey" FOREIGN KEY ("owner_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."call_transcript_queue"
    ADD CONSTRAINT "call_transcript_queue_call_id_fkey" FOREIGN KEY ("call_id") REFERENCES "public"."calls"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."call_transcript_queue"
    ADD CONSTRAINT "call_transcript_queue_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."calls"
    ADD CONSTRAINT "calls_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."calls"
    ADD CONSTRAINT "calls_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."calls"
    ADD CONSTRAINT "calls_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."calls"
    ADD CONSTRAINT "calls_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."calls"
    ADD CONSTRAINT "calls_owner_user_id_fkey" FOREIGN KEY ("owner_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."challenge_features"
    ADD CONSTRAINT "challenge_features_challenge_id_fkey" FOREIGN KEY ("challenge_id") REFERENCES "public"."challenges"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."coaching_scorecard_templates"
    ADD CONSTRAINT "coaching_scorecard_templates_call_type_id_fkey" FOREIGN KEY ("call_type_id") REFERENCES "public"."org_call_types"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."coaching_scorecard_templates"
    ADD CONSTRAINT "coaching_scorecard_templates_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."communication_events"
    ADD CONSTRAINT "communication_events_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."communication_events"
    ADD CONSTRAINT "communication_events_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."communication_events"
    ADD CONSTRAINT "communication_events_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."communication_events"
    ADD CONSTRAINT "communication_events_previous_event_id_fkey" FOREIGN KEY ("previous_event_id") REFERENCES "public"."communication_events"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."communication_events"
    ADD CONSTRAINT "communication_events_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."companies"
    ADD CONSTRAINT "companies_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "public"."profiles"("id");

ALTER TABLE ONLY "public"."company_meeting_insights"
    ADD CONSTRAINT "company_meeting_insights_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."contact_meeting_insights"
    ADD CONSTRAINT "contact_meeting_insights_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."contact_notes"
    ADD CONSTRAINT "contact_notes_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."contact_notes"
    ADD CONSTRAINT "contact_notes_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."content_topic_links"
    ADD CONSTRAINT "content_topic_links_content_id_fkey" FOREIGN KEY ("content_id") REFERENCES "public"."meeting_generated_content"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."copilot_analytics"
    ADD CONSTRAINT "copilot_analytics_conversation_id_fkey" FOREIGN KEY ("conversation_id") REFERENCES "public"."copilot_conversations"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."copilot_analytics"
    ADD CONSTRAINT "copilot_analytics_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."copilot_conversations"
    ADD CONSTRAINT "copilot_conversations_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."copilot_conversations"
    ADD CONSTRAINT "copilot_conversations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."copilot_messages"
    ADD CONSTRAINT "copilot_messages_conversation_id_fkey" FOREIGN KEY ("conversation_id") REFERENCES "public"."copilot_conversations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."cron_job_logs"
    ADD CONSTRAINT "cron_job_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."csv_mapping_templates"
    ADD CONSTRAINT "csv_mapping_templates_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_activities"
    ADD CONSTRAINT "deal_activities_activity_id_fkey" FOREIGN KEY ("activity_id") REFERENCES "public"."activities"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."deal_activities"
    ADD CONSTRAINT "deal_activities_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_activities"
    ADD CONSTRAINT "deal_activities_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."deal_clarity_scores"
    ADD CONSTRAINT "deal_clarity_scores_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_clarity_scores"
    ADD CONSTRAINT "deal_clarity_scores_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_close_plan_items"
    ADD CONSTRAINT "deal_close_plan_items_completed_by_fkey" FOREIGN KEY ("completed_by") REFERENCES "public"."profiles"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."deal_close_plan_items"
    ADD CONSTRAINT "deal_close_plan_items_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_close_plan_items"
    ADD CONSTRAINT "deal_close_plan_items_linked_task_id_fkey" FOREIGN KEY ("linked_task_id") REFERENCES "public"."tasks"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."deal_close_plan_items"
    ADD CONSTRAINT "deal_close_plan_items_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_close_plan_items"
    ADD CONSTRAINT "deal_close_plan_items_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "public"."profiles"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."deal_health_alerts"
    ADD CONSTRAINT "deal_health_alerts_acknowledged_by_fkey" FOREIGN KEY ("acknowledged_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."deal_health_alerts"
    ADD CONSTRAINT "deal_health_alerts_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_health_alerts"
    ADD CONSTRAINT "deal_health_alerts_health_score_id_fkey" FOREIGN KEY ("health_score_id") REFERENCES "public"."deal_health_scores"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_health_alerts"
    ADD CONSTRAINT "deal_health_alerts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_health_history"
    ADD CONSTRAINT "deal_health_history_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_health_rules"
    ADD CONSTRAINT "deal_health_rules_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."deal_health_scores"
    ADD CONSTRAINT "deal_health_scores_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_health_scores"
    ADD CONSTRAINT "deal_health_scores_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_migration_reviews"
    ADD CONSTRAINT "deal_migration_reviews_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_migration_reviews"
    ADD CONSTRAINT "deal_migration_reviews_resolved_by_fkey" FOREIGN KEY ("resolved_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."deal_migration_reviews"
    ADD CONSTRAINT "deal_migration_reviews_suggested_company_id_fkey" FOREIGN KEY ("suggested_company_id") REFERENCES "public"."companies"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."deal_migration_reviews"
    ADD CONSTRAINT "deal_migration_reviews_suggested_contact_id_fkey" FOREIGN KEY ("suggested_contact_id") REFERENCES "public"."contacts"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."deal_notes"
    ADD CONSTRAINT "deal_notes_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_notes"
    ADD CONSTRAINT "deal_notes_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_risk_aggregates"
    ADD CONSTRAINT "deal_risk_aggregates_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_risk_signals"
    ADD CONSTRAINT "deal_risk_signals_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_risk_signals"
    ADD CONSTRAINT "deal_risk_signals_resolved_by_fkey" FOREIGN KEY ("resolved_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."deal_risk_signals"
    ADD CONSTRAINT "deal_risk_signals_source_meeting_id_fkey" FOREIGN KEY ("source_meeting_id") REFERENCES "public"."meetings"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."deal_splits"
    ADD CONSTRAINT "deal_splits_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_splits"
    ADD CONSTRAINT "deal_splits_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_stage_history"
    ADD CONSTRAINT "deal_stage_history_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_stage_history"
    ADD CONSTRAINT "deal_stage_history_stage_id_fkey" FOREIGN KEY ("stage_id") REFERENCES "public"."deal_stages"("id");

ALTER TABLE ONLY "public"."deal_stage_history"
    ADD CONSTRAINT "deal_stage_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."deal_truth_fields"
    ADD CONSTRAINT "deal_truth_fields_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."deal_truth_fields"
    ADD CONSTRAINT "deal_truth_fields_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deal_truth_fields"
    ADD CONSTRAINT "deal_truth_fields_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deals"
    ADD CONSTRAINT "deals_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."deals"
    ADD CONSTRAINT "deals_primary_contact_id_fkey" FOREIGN KEY ("primary_contact_id") REFERENCES "public"."contacts"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."deals"
    ADD CONSTRAINT "deals_stage_id_fkey" FOREIGN KEY ("stage_id") REFERENCES "public"."deal_stages"("id");

ALTER TABLE ONLY "public"."email_attachments"
    ADD CONSTRAINT "email_attachments_email_id_fkey" FOREIGN KEY ("email_id") REFERENCES "public"."emails"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."email_categorizations"
    ADD CONSTRAINT "email_categorizations_communication_event_id_fkey" FOREIGN KEY ("communication_event_id") REFERENCES "public"."communication_events"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."email_categorizations"
    ADD CONSTRAINT "email_categorizations_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."email_categorizations"
    ADD CONSTRAINT "email_categorizations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."email_label_map"
    ADD CONSTRAINT "email_label_map_email_id_fkey" FOREIGN KEY ("email_id") REFERENCES "public"."emails"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."email_label_map"
    ADD CONSTRAINT "email_label_map_label_id_fkey" FOREIGN KEY ("label_id") REFERENCES "public"."email_labels"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."email_labels"
    ADD CONSTRAINT "email_labels_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."email_logs"
    ADD CONSTRAINT "email_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."email_sends"
    ADD CONSTRAINT "email_sends_journey_id_fkey" FOREIGN KEY ("journey_id") REFERENCES "public"."email_journeys"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."email_sends"
    ADD CONSTRAINT "email_sends_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."email_templates"
    ADD CONSTRAINT "email_templates_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."email_threads"
    ADD CONSTRAINT "email_threads_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."emails"
    ADD CONSTRAINT "emails_mcp_connection_id_fkey" FOREIGN KEY ("mcp_connection_id") REFERENCES "public"."mcp_connections"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."emails"
    ADD CONSTRAINT "emails_thread_id_fkey" FOREIGN KEY ("thread_id") REFERENCES "public"."email_threads"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."emails"
    ADD CONSTRAINT "emails_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."fathom_integrations"
    ADD CONSTRAINT "fathom_integrations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."fathom_oauth_states"
    ADD CONSTRAINT "fathom_oauth_states_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."fathom_oauth_states"
    ADD CONSTRAINT "fathom_oauth_states_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."fathom_org_credentials"
    ADD CONSTRAINT "fathom_org_credentials_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."fathom_org_integrations"
    ADD CONSTRAINT "fathom_org_integrations_connected_by_user_id_fkey" FOREIGN KEY ("connected_by_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."fathom_org_integrations"
    ADD CONSTRAINT "fathom_org_integrations_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."fathom_org_sync_state"
    ADD CONSTRAINT "fathom_org_sync_state_integration_id_fkey" FOREIGN KEY ("integration_id") REFERENCES "public"."fathom_org_integrations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."fathom_org_sync_state"
    ADD CONSTRAINT "fathom_org_sync_state_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."fathom_sync_state"
    ADD CONSTRAINT "fathom_sync_state_integration_id_fkey" FOREIGN KEY ("integration_id") REFERENCES "public"."fathom_integrations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."fathom_sync_state"
    ADD CONSTRAINT "fathom_sync_state_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."fathom_transcript_retry_jobs"
    ADD CONSTRAINT "fathom_transcript_retry_jobs_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."fathom_transcript_retry_jobs"
    ADD CONSTRAINT "fathom_transcript_retry_jobs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."fathom_user_mappings"
    ADD CONSTRAINT "fathom_user_mappings_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."fathom_user_mappings"
    ADD CONSTRAINT "fathom_user_mappings_sixty_user_id_fkey" FOREIGN KEY ("sixty_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."activities"
    ADD CONSTRAINT "fk_activities_company_id" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."activities"
    ADD CONSTRAINT "fk_activities_contact_id" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."activities"
    ADD CONSTRAINT "fk_activities_owner_id" FOREIGN KEY ("owner_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."contacts"
    ADD CONSTRAINT "fk_contacts_company_id" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."contacts"
    ADD CONSTRAINT "fk_contacts_owner_id" FOREIGN KEY ("owner_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deals"
    ADD CONSTRAINT "fk_deals_company_id" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."deals"
    ADD CONSTRAINT "fk_deals_owner" FOREIGN KEY ("owner_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."deals"
    ADD CONSTRAINT "fk_deals_owner_id" FOREIGN KEY ("owner_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meetings"
    ADD CONSTRAINT "fk_meetings_company_id" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."meetings"
    ADD CONSTRAINT "fk_meetings_contact_id" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."meetings"
    ADD CONSTRAINT "fk_meetings_created_by" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."tasks"
    ADD CONSTRAINT "fk_tasks_company_id" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."tasks"
    ADD CONSTRAINT "fk_tasks_contact_id" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."tasks"
    ADD CONSTRAINT "fk_tasks_owner_id" FOREIGN KEY ("owner_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."ghost_detection_signals"
    ADD CONSTRAINT "ghost_detection_signals_relationship_health_id_fkey" FOREIGN KEY ("relationship_health_id") REFERENCES "public"."relationship_health_scores"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."ghost_detection_signals"
    ADD CONSTRAINT "ghost_detection_signals_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."global_topic_sources"
    ADD CONSTRAINT "global_topic_sources_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."global_topic_sources"
    ADD CONSTRAINT "global_topic_sources_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."global_topic_sources"
    ADD CONSTRAINT "global_topic_sources_global_topic_id_fkey" FOREIGN KEY ("global_topic_id") REFERENCES "public"."global_topics"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."global_topic_sources"
    ADD CONSTRAINT "global_topic_sources_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."global_topics"
    ADD CONSTRAINT "global_topics_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."gmail_label_mappings"
    ADD CONSTRAINT "gmail_label_mappings_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."gmail_label_mappings"
    ADD CONSTRAINT "gmail_label_mappings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."google_calendar_channels"
    ADD CONSTRAINT "google_calendar_channels_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."google_calendar_channels"
    ADD CONSTRAINT "google_calendar_channels_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."google_calendars"
    ADD CONSTRAINT "google_calendars_integration_id_fkey" FOREIGN KEY ("integration_id") REFERENCES "public"."google_integrations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."google_docs_templates"
    ADD CONSTRAINT "google_docs_templates_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."google_drive_folders"
    ADD CONSTRAINT "google_drive_folders_integration_id_fkey" FOREIGN KEY ("integration_id") REFERENCES "public"."google_integrations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."google_email_labels"
    ADD CONSTRAINT "google_email_labels_integration_id_fkey" FOREIGN KEY ("integration_id") REFERENCES "public"."google_integrations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."google_integrations"
    ADD CONSTRAINT "google_integrations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."google_oauth_states"
    ADD CONSTRAINT "google_oauth_states_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."google_service_logs"
    ADD CONSTRAINT "google_service_logs_integration_id_fkey" FOREIGN KEY ("integration_id") REFERENCES "public"."google_integrations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."google_task_lists"
    ADD CONSTRAINT "google_task_lists_integration_id_fkey" FOREIGN KEY ("integration_id") REFERENCES "public"."google_integrations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."google_task_mappings"
    ADD CONSTRAINT "google_task_mappings_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."tasks"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."google_task_mappings"
    ADD CONSTRAINT "google_task_mappings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."google_tasks_list_configs"
    ADD CONSTRAINT "google_tasks_list_configs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."google_tasks_sync_conflicts"
    ADD CONSTRAINT "google_tasks_sync_conflicts_task_id_fkey" FOREIGN KEY ("task_id") REFERENCES "public"."tasks"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."google_tasks_sync_conflicts"
    ADD CONSTRAINT "google_tasks_sync_conflicts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."google_tasks_sync_status"
    ADD CONSTRAINT "google_tasks_sync_status_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."hitl_pending_approvals"
    ADD CONSTRAINT "hitl_pending_approvals_actioned_by_fkey" FOREIGN KEY ("actioned_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."hitl_pending_approvals"
    ADD CONSTRAINT "hitl_pending_approvals_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."hitl_pending_approvals"
    ADD CONSTRAINT "hitl_pending_approvals_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."hitl_pending_approvals"
    ADD CONSTRAINT "hitl_pending_approvals_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."hitl_requests"
    ADD CONSTRAINT "hitl_requests_assigned_to_user_id_fkey" FOREIGN KEY ("assigned_to_user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."hitl_requests"
    ADD CONSTRAINT "hitl_requests_assigned_to_user_id_profiles_fkey" FOREIGN KEY ("assigned_to_user_id") REFERENCES "public"."profiles"("id") ON DELETE SET NULL;

COMMENT ON CONSTRAINT "hitl_requests_assigned_to_user_id_profiles_fkey" ON "public"."hitl_requests" IS 'Foreign key to profiles table for PostgREST embedded queries (profiles:assigned_to_user_id)';

ALTER TABLE ONLY "public"."hitl_requests"
    ADD CONSTRAINT "hitl_requests_execution_id_fkey" FOREIGN KEY ("execution_id") REFERENCES "public"."sequence_executions"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."hitl_requests"
    ADD CONSTRAINT "hitl_requests_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."hitl_requests"
    ADD CONSTRAINT "hitl_requests_requested_by_user_id_fkey" FOREIGN KEY ("requested_by_user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."hitl_requests"
    ADD CONSTRAINT "hitl_requests_requested_by_user_id_profiles_fkey" FOREIGN KEY ("requested_by_user_id") REFERENCES "public"."profiles"("id") ON DELETE RESTRICT;

COMMENT ON CONSTRAINT "hitl_requests_requested_by_user_id_profiles_fkey" ON "public"."hitl_requests" IS 'Foreign key to profiles table for PostgREST embedded queries (profiles:requested_by_user_id)';

ALTER TABLE ONLY "public"."hitl_requests"
    ADD CONSTRAINT "hitl_requests_responded_by_user_id_fkey" FOREIGN KEY ("responded_by_user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."hitl_requests"
    ADD CONSTRAINT "hitl_requests_responded_by_user_id_profiles_fkey" FOREIGN KEY ("responded_by_user_id") REFERENCES "public"."profiles"("id") ON DELETE SET NULL;

COMMENT ON CONSTRAINT "hitl_requests_responded_by_user_id_profiles_fkey" ON "public"."hitl_requests" IS 'Foreign key to profiles table for PostgREST embedded queries (profiles:responded_by_user_id)';

ALTER TABLE ONLY "public"."hubspot_oauth_states"
    ADD CONSTRAINT "hubspot_oauth_states_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."hubspot_oauth_states"
    ADD CONSTRAINT "hubspot_oauth_states_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."hubspot_object_mappings"
    ADD CONSTRAINT "hubspot_object_mappings_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."hubspot_org_credentials"
    ADD CONSTRAINT "hubspot_org_credentials_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."hubspot_org_integrations"
    ADD CONSTRAINT "hubspot_org_integrations_connected_by_user_id_fkey" FOREIGN KEY ("connected_by_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."hubspot_org_integrations"
    ADD CONSTRAINT "hubspot_org_integrations_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."hubspot_org_sync_state"
    ADD CONSTRAINT "hubspot_org_sync_state_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."hubspot_settings"
    ADD CONSTRAINT "hubspot_settings_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."hubspot_sync_queue"
    ADD CONSTRAINT "hubspot_sync_queue_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."hubspot_webhook_events"
    ADD CONSTRAINT "hubspot_webhook_events_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."impersonation_logs"
    ADD CONSTRAINT "impersonation_logs_admin_id_fkey" FOREIGN KEY ("admin_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."impersonation_logs"
    ADD CONSTRAINT "impersonation_logs_target_user_id_fkey" FOREIGN KEY ("target_user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."integration_alerts"
    ADD CONSTRAINT "integration_alerts_acknowledged_by_fkey" FOREIGN KEY ("acknowledged_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."integration_alerts"
    ADD CONSTRAINT "integration_alerts_resolved_by_fkey" FOREIGN KEY ("resolved_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."integration_alerts"
    ADD CONSTRAINT "integration_alerts_test_result_id_fkey" FOREIGN KEY ("test_result_id") REFERENCES "public"."integration_test_results"("id");

ALTER TABLE ONLY "public"."integration_sync_logs"
    ADD CONSTRAINT "integration_sync_logs_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."integration_sync_logs"
    ADD CONSTRAINT "integration_sync_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."integration_test_results"
    ADD CONSTRAINT "integration_test_results_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."integration_test_results"
    ADD CONSTRAINT "integration_test_results_triggered_by_user_id_fkey" FOREIGN KEY ("triggered_by_user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."internal_users"
    ADD CONSTRAINT "internal_users_added_by_fkey" FOREIGN KEY ("added_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."intervention_templates"
    ADD CONSTRAINT "intervention_templates_parent_template_id_fkey" FOREIGN KEY ("parent_template_id") REFERENCES "public"."intervention_templates"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."intervention_templates"
    ADD CONSTRAINT "intervention_templates_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."interventions"
    ADD CONSTRAINT "interventions_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."interventions"
    ADD CONSTRAINT "interventions_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."interventions"
    ADD CONSTRAINT "interventions_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."interventions"
    ADD CONSTRAINT "interventions_relationship_health_id_fkey" FOREIGN KEY ("relationship_health_id") REFERENCES "public"."relationship_health_scores"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."interventions"
    ADD CONSTRAINT "interventions_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."intervention_templates"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."interventions"
    ADD CONSTRAINT "interventions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."justcall_integration_secrets"
    ADD CONSTRAINT "justcall_integration_secrets_integration_id_fkey" FOREIGN KEY ("integration_id") REFERENCES "public"."justcall_integrations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."justcall_integration_secrets"
    ADD CONSTRAINT "justcall_integration_secrets_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."justcall_integration_secrets"
    ADD CONSTRAINT "justcall_integration_secrets_org_matches_parent" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."justcall_integrations"
    ADD CONSTRAINT "justcall_integrations_connected_by_user_id_fkey" FOREIGN KEY ("connected_by_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."justcall_integrations"
    ADD CONSTRAINT "justcall_integrations_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."justcall_oauth_states"
    ADD CONSTRAINT "justcall_oauth_states_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."justcall_oauth_states"
    ADD CONSTRAINT "justcall_oauth_states_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."launch_checklist_items"
    ADD CONSTRAINT "launch_checklist_items_completed_by_fkey" FOREIGN KEY ("completed_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."lead_events"
    ADD CONSTRAINT "lead_events_lead_id_fkey" FOREIGN KEY ("lead_id") REFERENCES "public"."leads"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."lead_prep_notes"
    ADD CONSTRAINT "lead_prep_notes_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."lead_prep_notes"
    ADD CONSTRAINT "lead_prep_notes_lead_id_fkey" FOREIGN KEY ("lead_id") REFERENCES "public"."leads"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."lead_sources"
    ADD CONSTRAINT "lead_sources_default_owner_id_fkey" FOREIGN KEY ("default_owner_id") REFERENCES "public"."profiles"("id");

ALTER TABLE ONLY "public"."leads"
    ADD CONSTRAINT "leads_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");

ALTER TABLE ONLY "public"."leads"
    ADD CONSTRAINT "leads_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id");

ALTER TABLE ONLY "public"."leads"
    ADD CONSTRAINT "leads_converted_deal_id_fkey" FOREIGN KEY ("converted_deal_id") REFERENCES "public"."deals"("id");

ALTER TABLE ONLY "public"."leads"
    ADD CONSTRAINT "leads_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."leads"
    ADD CONSTRAINT "leads_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "public"."profiles"("id");

ALTER TABLE ONLY "public"."leads"
    ADD CONSTRAINT "leads_source_id_fkey" FOREIGN KEY ("source_id") REFERENCES "public"."lead_sources"("id");

ALTER TABLE ONLY "public"."mcp_connections"
    ADD CONSTRAINT "mcp_connections_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_action_items"
    ADD CONSTRAINT "meeting_action_items_linked_task_id_fkey" FOREIGN KEY ("linked_task_id") REFERENCES "public"."tasks"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."meeting_action_items"
    ADD CONSTRAINT "meeting_action_items_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_attendees"
    ADD CONSTRAINT "meeting_attendees_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_classifications"
    ADD CONSTRAINT "meeting_classifications_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_contacts"
    ADD CONSTRAINT "meeting_contacts_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_contacts"
    ADD CONSTRAINT "meeting_contacts_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_content_topics"
    ADD CONSTRAINT "meeting_content_topics_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."meeting_content_topics"
    ADD CONSTRAINT "meeting_content_topics_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_content_topics"
    ADD CONSTRAINT "meeting_content_topics_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."meeting_documents"
    ADD CONSTRAINT "meeting_documents_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."meeting_file_search_index"
    ADD CONSTRAINT "meeting_file_search_index_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_file_search_index"
    ADD CONSTRAINT "meeting_file_search_index_meeting_owner_id_fkey" FOREIGN KEY ("meeting_owner_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."meeting_file_search_index"
    ADD CONSTRAINT "meeting_file_search_index_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_generated_content"
    ADD CONSTRAINT "meeting_generated_content_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."meeting_generated_content"
    ADD CONSTRAINT "meeting_generated_content_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_generated_content"
    ADD CONSTRAINT "meeting_generated_content_parent_id_fkey" FOREIGN KEY ("parent_id") REFERENCES "public"."meeting_generated_content"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."meeting_index_queue"
    ADD CONSTRAINT "meeting_index_queue_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_index_queue"
    ADD CONSTRAINT "meeting_index_queue_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_intelligence_queries"
    ADD CONSTRAINT "meeting_intelligence_queries_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_metrics"
    ADD CONSTRAINT "meeting_metrics_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_scorecards"
    ADD CONSTRAINT "meeting_scorecards_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_scorecards"
    ADD CONSTRAINT "meeting_scorecards_rep_user_id_fkey" FOREIGN KEY ("rep_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_scorecards"
    ADD CONSTRAINT "meeting_scorecards_template_id_fkey" FOREIGN KEY ("template_id") REFERENCES "public"."coaching_scorecard_templates"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."meeting_structured_summaries"
    ADD CONSTRAINT "meeting_structured_summaries_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_topics"
    ADD CONSTRAINT "meeting_topics_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_workflow_results"
    ADD CONSTRAINT "meeting_workflow_results_call_type_id_fkey" FOREIGN KEY ("call_type_id") REFERENCES "public"."org_call_types"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."meeting_workflow_results"
    ADD CONSTRAINT "meeting_workflow_results_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meeting_workflow_results"
    ADD CONSTRAINT "meeting_workflow_results_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meetingbaas_calendars"
    ADD CONSTRAINT "meetingbaas_calendars_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meetingbaas_calendars"
    ADD CONSTRAINT "meetingbaas_calendars_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meetings"
    ADD CONSTRAINT "meetings_call_type_id_fkey" FOREIGN KEY ("call_type_id") REFERENCES "public"."org_call_types"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."meetings"
    ADD CONSTRAINT "meetings_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id");

ALTER TABLE ONLY "public"."meetings"
    ADD CONSTRAINT "meetings_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."meetings"
    ADD CONSTRAINT "meetings_owner_user_id_fkey" FOREIGN KEY ("owner_user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."meetings"
    ADD CONSTRAINT "meetings_primary_contact_id_fkey" FOREIGN KEY ("primary_contact_id") REFERENCES "public"."contacts"("id");

ALTER TABLE ONLY "public"."meetings"
    ADD CONSTRAINT "meetings_voice_recording_id_fkey" FOREIGN KEY ("voice_recording_id") REFERENCES "public"."voice_recordings"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."meetings_waitlist"
    ADD CONSTRAINT "meetings_waitlist_access_granted_by_fkey" FOREIGN KEY ("access_granted_by") REFERENCES "public"."profiles"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."meetings_waitlist"
    ADD CONSTRAINT "meetings_waitlist_granted_by_fkey" FOREIGN KEY ("granted_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."meetings_waitlist"
    ADD CONSTRAINT "meetings_waitlist_invited_user_id_fkey" FOREIGN KEY ("invited_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."meetings_waitlist"
    ADD CONSTRAINT "meetings_waitlist_referred_by_code_fkey" FOREIGN KEY ("referred_by_code") REFERENCES "public"."meetings_waitlist"("referral_code");

ALTER TABLE ONLY "public"."meetings_waitlist"
    ADD CONSTRAINT "meetings_waitlist_released_by_fkey" FOREIGN KEY ("released_by") REFERENCES "public"."profiles"("id");

ALTER TABLE ONLY "public"."meetings_waitlist"
    ADD CONSTRAINT "meetings_waitlist_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."next_action_suggestions"
    ADD CONSTRAINT "next_action_suggestions_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."next_action_suggestions"
    ADD CONSTRAINT "next_action_suggestions_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."next_action_suggestions"
    ADD CONSTRAINT "next_action_suggestions_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."next_action_suggestions"
    ADD CONSTRAINT "next_action_suggestions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."notetaker_user_settings"
    ADD CONSTRAINT "notetaker_user_settings_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."notetaker_user_settings"
    ADD CONSTRAINT "notetaker_user_settings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."notification_feedback"
    ADD CONSTRAINT "notification_feedback_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."notification_feedback"
    ADD CONSTRAINT "notification_feedback_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."notification_interactions"
    ADD CONSTRAINT "notification_interactions_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."notification_interactions"
    ADD CONSTRAINT "notification_interactions_slack_notification_sent_id_fkey" FOREIGN KEY ("slack_notification_sent_id") REFERENCES "public"."slack_notifications_sent"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."notification_interactions"
    ADD CONSTRAINT "notification_interactions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."notification_queue"
    ADD CONSTRAINT "notification_queue_notification_interaction_id_fkey" FOREIGN KEY ("notification_interaction_id") REFERENCES "public"."notification_interactions"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."notification_queue"
    ADD CONSTRAINT "notification_queue_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."notification_queue"
    ADD CONSTRAINT "notification_queue_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."notification_rate_limits"
    ADD CONSTRAINT "notification_rate_limits_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."profiles"("id");

ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."org_ai_preferences"
    ADD CONSTRAINT "org_ai_preferences_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."org_call_types"
    ADD CONSTRAINT "org_call_types_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."org_email_categorization_settings"
    ADD CONSTRAINT "org_email_categorization_settings_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."org_email_categorization_settings"
    ADD CONSTRAINT "org_email_categorization_settings_updated_by_fkey" FOREIGN KEY ("updated_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."org_proposal_workflows"
    ADD CONSTRAINT "org_proposal_workflows_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."org_proposal_workflows"
    ADD CONSTRAINT "org_proposal_workflows_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."organization_context"
    ADD CONSTRAINT "organization_context_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."organization_enrichment"
    ADD CONSTRAINT "organization_enrichment_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."organization_feature_flags"
    ADD CONSTRAINT "organization_feature_flags_enabled_by_fkey" FOREIGN KEY ("enabled_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."organization_feature_flags"
    ADD CONSTRAINT "organization_feature_flags_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."organization_invitations"
    ADD CONSTRAINT "organization_invitations_invited_by_fkey" FOREIGN KEY ("invited_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."organization_invitations"
    ADD CONSTRAINT "organization_invitations_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."organization_memberships"
    ADD CONSTRAINT "organization_memberships_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."organization_memberships"
    ADD CONSTRAINT "organization_memberships_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."organization_skills"
    ADD CONSTRAINT "organization_skills_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."organization_skills_history"
    ADD CONSTRAINT "organization_skills_history_changed_by_fkey" FOREIGN KEY ("changed_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."organization_skills_history"
    ADD CONSTRAINT "organization_skills_history_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."organization_skills_history"
    ADD CONSTRAINT "organization_skills_history_skill_record_id_fkey" FOREIGN KEY ("skill_record_id") REFERENCES "public"."organization_skills"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."organization_skills"
    ADD CONSTRAINT "organization_skills_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."organization_skills"
    ADD CONSTRAINT "organization_skills_platform_skill_id_fkey" FOREIGN KEY ("platform_skill_id") REFERENCES "public"."platform_skills"("id");

ALTER TABLE ONLY "public"."organization_subscriptions"
    ADD CONSTRAINT "organization_subscriptions_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."organization_subscriptions"
    ADD CONSTRAINT "organization_subscriptions_plan_id_fkey" FOREIGN KEY ("plan_id") REFERENCES "public"."subscription_plans"("id") ON DELETE RESTRICT;

ALTER TABLE ONLY "public"."organization_usage"
    ADD CONSTRAINT "organization_usage_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."organizations"
    ADD CONSTRAINT "organizations_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."pipeline_automation_log"
    ADD CONSTRAINT "pipeline_automation_log_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."pipeline_automation_log"
    ADD CONSTRAINT "pipeline_automation_log_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."pipeline_automation_log"
    ADD CONSTRAINT "pipeline_automation_log_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."pipeline_automation_log"
    ADD CONSTRAINT "pipeline_automation_log_rule_id_fkey" FOREIGN KEY ("rule_id") REFERENCES "public"."pipeline_automation_rules"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."pipeline_automation_rules"
    ADD CONSTRAINT "pipeline_automation_rules_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."pipeline_automation_rules"
    ADD CONSTRAINT "pipeline_automation_rules_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."pipeline_stage_recommendations"
    ADD CONSTRAINT "pipeline_stage_recommendations_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."pipeline_stage_recommendations"
    ADD CONSTRAINT "pipeline_stage_recommendations_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."pipeline_stage_recommendations"
    ADD CONSTRAINT "pipeline_stage_recommendations_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."pipeline_stage_recommendations"
    ADD CONSTRAINT "pipeline_stage_recommendations_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."pipeline_stage_recommendations"
    ADD CONSTRAINT "pipeline_stage_recommendations_reviewed_by_fkey" FOREIGN KEY ("reviewed_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."pipeline_stage_recommendations"
    ADD CONSTRAINT "pipeline_stage_recommendations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."platform_skills"
    ADD CONSTRAINT "platform_skills_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."profiles"("id");

ALTER TABLE ONLY "public"."platform_skills_history"
    ADD CONSTRAINT "platform_skills_history_changed_by_fkey" FOREIGN KEY ("changed_by") REFERENCES "public"."profiles"("id");

ALTER TABLE ONLY "public"."platform_skills_history"
    ADD CONSTRAINT "platform_skills_history_skill_id_fkey" FOREIGN KEY ("skill_id") REFERENCES "public"."platform_skills"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."process_map_coverage_snapshots"
    ADD CONSTRAINT "process_map_coverage_snapshots_process_map_id_fkey" FOREIGN KEY ("process_map_id") REFERENCES "public"."process_maps"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."process_map_coverage_snapshots"
    ADD CONSTRAINT "process_map_coverage_snapshots_workflow_id_fkey" FOREIGN KEY ("workflow_id") REFERENCES "public"."process_map_workflows"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."process_map_fixtures"
    ADD CONSTRAINT "process_map_fixtures_workflow_id_fkey" FOREIGN KEY ("workflow_id") REFERENCES "public"."process_map_workflows"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."process_map_mocks"
    ADD CONSTRAINT "process_map_mocks_workflow_id_fkey" FOREIGN KEY ("workflow_id") REFERENCES "public"."process_map_workflows"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."process_map_scenario_runs"
    ADD CONSTRAINT "process_map_scenario_runs_scenario_id_fkey" FOREIGN KEY ("scenario_id") REFERENCES "public"."process_map_test_scenarios"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."process_map_scenario_runs"
    ADD CONSTRAINT "process_map_scenario_runs_test_run_id_fkey" FOREIGN KEY ("test_run_id") REFERENCES "public"."process_map_test_runs"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."process_map_step_results"
    ADD CONSTRAINT "process_map_step_results_test_run_id_fkey" FOREIGN KEY ("test_run_id") REFERENCES "public"."process_map_test_runs"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."process_map_test_runs"
    ADD CONSTRAINT "process_map_test_runs_run_by_fkey" FOREIGN KEY ("run_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."process_map_test_runs"
    ADD CONSTRAINT "process_map_test_runs_workflow_id_fkey" FOREIGN KEY ("workflow_id") REFERENCES "public"."process_map_workflows"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."process_map_test_scenarios"
    ADD CONSTRAINT "process_map_test_scenarios_process_map_id_fkey" FOREIGN KEY ("process_map_id") REFERENCES "public"."process_maps"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."process_map_test_scenarios"
    ADD CONSTRAINT "process_map_test_scenarios_workflow_id_fkey" FOREIGN KEY ("workflow_id") REFERENCES "public"."process_map_workflows"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."process_map_workflows"
    ADD CONSTRAINT "process_map_workflows_process_map_id_fkey" FOREIGN KEY ("process_map_id") REFERENCES "public"."process_maps"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."process_maps"
    ADD CONSTRAINT "process_maps_generated_by_fkey" FOREIGN KEY ("generated_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."proposal_jobs"
    ADD CONSTRAINT "proposal_jobs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."proposal_templates"
    ADD CONSTRAINT "proposal_templates_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."proposals"
    ADD CONSTRAINT "proposals_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id");

ALTER TABLE ONLY "public"."proposals"
    ADD CONSTRAINT "proposals_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id");

ALTER TABLE ONLY "public"."proposals"
    ADD CONSTRAINT "proposals_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."rate_limit"
    ADD CONSTRAINT "rate_limit_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."recording_rules"
    ADD CONSTRAINT "recording_rules_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."recording_rules"
    ADD CONSTRAINT "recording_rules_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."recording_usage"
    ADD CONSTRAINT "recording_usage_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."recordings"
    ADD CONSTRAINT "recordings_calendar_event_id_fkey" FOREIGN KEY ("calendar_event_id") REFERENCES "public"."calendar_events"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."recordings"
    ADD CONSTRAINT "recordings_crm_activity_id_fkey" FOREIGN KEY ("crm_activity_id") REFERENCES "public"."activities"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."recordings"
    ADD CONSTRAINT "recordings_crm_deal_id_fkey" FOREIGN KEY ("crm_deal_id") REFERENCES "public"."deals"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."recordings"
    ADD CONSTRAINT "recordings_hitl_resolved_by_fkey" FOREIGN KEY ("hitl_resolved_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."recordings"
    ADD CONSTRAINT "recordings_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."recordings"
    ADD CONSTRAINT "recordings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."reengagement_log"
    ADD CONSTRAINT "reengagement_log_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id");

ALTER TABLE ONLY "public"."reengagement_log"
    ADD CONSTRAINT "reengagement_log_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."relationship_health_history"
    ADD CONSTRAINT "relationship_health_history_relationship_health_id_fkey" FOREIGN KEY ("relationship_health_id") REFERENCES "public"."relationship_health_scores"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."relationship_health_history"
    ADD CONSTRAINT "relationship_health_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."relationship_health_scores"
    ADD CONSTRAINT "relationship_health_scores_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."relationship_health_scores"
    ADD CONSTRAINT "relationship_health_scores_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."relationship_health_scores"
    ADD CONSTRAINT "relationship_health_scores_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."roadmap_comments"
    ADD CONSTRAINT "roadmap_comments_suggestion_id_fkey" FOREIGN KEY ("suggestion_id") REFERENCES "public"."roadmap_suggestions"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."roadmap_comments"
    ADD CONSTRAINT "roadmap_comments_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."roadmap_suggestions"
    ADD CONSTRAINT "roadmap_suggestions_assigned_to_fkey" FOREIGN KEY ("assigned_to") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."roadmap_suggestions"
    ADD CONSTRAINT "roadmap_suggestions_submitted_by_fkey" FOREIGN KEY ("submitted_by") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."roadmap_votes"
    ADD CONSTRAINT "roadmap_votes_suggestion_id_fkey" FOREIGN KEY ("suggestion_id") REFERENCES "public"."roadmap_suggestions"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."roadmap_votes"
    ADD CONSTRAINT "roadmap_votes_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."savvycal_integration_secrets"
    ADD CONSTRAINT "savvycal_integration_secrets_integration_id_fkey" FOREIGN KEY ("integration_id") REFERENCES "public"."savvycal_integrations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."savvycal_integration_secrets"
    ADD CONSTRAINT "savvycal_integration_secrets_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."savvycal_integration_secrets"
    ADD CONSTRAINT "savvycal_integration_secrets_org_matches_parent" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."savvycal_integrations"
    ADD CONSTRAINT "savvycal_integrations_connected_by_user_id_fkey" FOREIGN KEY ("connected_by_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."savvycal_integrations"
    ADD CONSTRAINT "savvycal_integrations_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."savvycal_source_mappings"
    ADD CONSTRAINT "savvycal_source_mappings_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."savvycal_source_mappings"
    ADD CONSTRAINT "savvycal_source_mappings_source_id_fkey" FOREIGN KEY ("source_id") REFERENCES "public"."booking_sources"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."sentiment_alerts"
    ADD CONSTRAINT "sentiment_alerts_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."sentiment_alerts"
    ADD CONSTRAINT "sentiment_alerts_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."sentiment_alerts"
    ADD CONSTRAINT "sentiment_alerts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sentry_bridge_config"
    ADD CONSTRAINT "sentry_bridge_config_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sentry_bridge_metrics"
    ADD CONSTRAINT "sentry_bridge_metrics_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sentry_bridge_queue"
    ADD CONSTRAINT "sentry_bridge_queue_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sentry_bridge_queue"
    ADD CONSTRAINT "sentry_bridge_queue_routing_rule_id_fkey" FOREIGN KEY ("routing_rule_id") REFERENCES "public"."sentry_routing_rules"("id");

ALTER TABLE ONLY "public"."sentry_bridge_queue"
    ADD CONSTRAINT "sentry_bridge_queue_webhook_event_id_fkey" FOREIGN KEY ("webhook_event_id") REFERENCES "public"."sentry_webhook_events"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sentry_dead_letter_queue"
    ADD CONSTRAINT "sentry_dead_letter_queue_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sentry_dead_letter_queue"
    ADD CONSTRAINT "sentry_dead_letter_queue_resolved_by_fkey" FOREIGN KEY ("resolved_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."sentry_dead_letter_queue"
    ADD CONSTRAINT "sentry_dead_letter_queue_webhook_event_id_fkey" FOREIGN KEY ("webhook_event_id") REFERENCES "public"."sentry_webhook_events"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sentry_issue_mappings"
    ADD CONSTRAINT "sentry_issue_mappings_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sentry_routing_rules"
    ADD CONSTRAINT "sentry_routing_rules_config_id_fkey" FOREIGN KEY ("config_id") REFERENCES "public"."sentry_bridge_config"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sentry_routing_rules"
    ADD CONSTRAINT "sentry_routing_rules_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sentry_triage_queue"
    ADD CONSTRAINT "sentry_triage_queue_matched_rule_id_fkey" FOREIGN KEY ("matched_rule_id") REFERENCES "public"."sentry_routing_rules"("id");

ALTER TABLE ONLY "public"."sentry_triage_queue"
    ADD CONSTRAINT "sentry_triage_queue_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sentry_triage_queue"
    ADD CONSTRAINT "sentry_triage_queue_triaged_by_fkey" FOREIGN KEY ("triaged_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."sentry_triage_queue"
    ADD CONSTRAINT "sentry_triage_queue_webhook_event_id_fkey" FOREIGN KEY ("webhook_event_id") REFERENCES "public"."sentry_webhook_events"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sentry_webhook_events"
    ADD CONSTRAINT "sentry_webhook_events_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sentry_webhook_queue"
    ADD CONSTRAINT "sentry_webhook_queue_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sequence_executions"
    ADD CONSTRAINT "sequence_executions_current_hitl_request_id_fkey" FOREIGN KEY ("current_hitl_request_id") REFERENCES "public"."hitl_requests"("id");

ALTER TABLE ONLY "public"."sequence_executions"
    ADD CONSTRAINT "sequence_executions_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sequence_executions"
    ADD CONSTRAINT "sequence_executions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sequence_hitl_requests"
    ADD CONSTRAINT "sequence_hitl_requests_assigned_to_user_id_fkey" FOREIGN KEY ("assigned_to_user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."sequence_hitl_requests"
    ADD CONSTRAINT "sequence_hitl_requests_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sequence_hitl_requests"
    ADD CONSTRAINT "sequence_hitl_requests_requested_by_user_id_fkey" FOREIGN KEY ("requested_by_user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."sequence_hitl_requests"
    ADD CONSTRAINT "sequence_hitl_requests_responded_by_user_id_fkey" FOREIGN KEY ("responded_by_user_id") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."sequence_references_archive"
    ADD CONSTRAINT "sequence_references_archive_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."sequence_token_budgets"
    ADD CONSTRAINT "sequence_token_budgets_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."skill_output_storage"
    ADD CONSTRAINT "skill_output_storage_organization_id_fkey" FOREIGN KEY ("organization_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."slack_channels"
    ADD CONSTRAINT "slack_channels_integration_id_fkey" FOREIGN KEY ("integration_id") REFERENCES "public"."slack_integrations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."slack_deal_rooms"
    ADD CONSTRAINT "slack_deal_rooms_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."slack_deal_rooms"
    ADD CONSTRAINT "slack_deal_rooms_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."slack_integrations"
    ADD CONSTRAINT "slack_integrations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."slack_notification_settings"
    ADD CONSTRAINT "slack_notification_settings_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."slack_notifications_sent"
    ADD CONSTRAINT "slack_notifications_sent_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."slack_org_settings"
    ADD CONSTRAINT "slack_org_settings_connected_by_fkey" FOREIGN KEY ("connected_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."slack_org_settings"
    ADD CONSTRAINT "slack_org_settings_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."slack_user_mappings"
    ADD CONSTRAINT "slack_user_mappings_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."slack_user_mappings"
    ADD CONSTRAINT "slack_user_mappings_sixty_user_id_fkey" FOREIGN KEY ("sixty_user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."smart_task_templates"
    ADD CONSTRAINT "smart_task_templates_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."solutions"
    ADD CONSTRAINT "solutions_challenge_id_fkey" FOREIGN KEY ("challenge_id") REFERENCES "public"."challenges"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."subscription_seat_usage"
    ADD CONSTRAINT "subscription_seat_usage_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."subscription_seat_usage"
    ADD CONSTRAINT "subscription_seat_usage_subscription_id_fkey" FOREIGN KEY ("subscription_id") REFERENCES "public"."organization_subscriptions"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."targets"
    ADD CONSTRAINT "targets_closed_by_fkey" FOREIGN KEY ("closed_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."targets"
    ADD CONSTRAINT "targets_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."targets"
    ADD CONSTRAINT "targets_previous_target_id_fkey" FOREIGN KEY ("previous_target_id") REFERENCES "public"."targets"("id");

ALTER TABLE ONLY "public"."targets"
    ADD CONSTRAINT "targets_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."targets"
    ADD CONSTRAINT "targets_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."task_notifications"
    ADD CONSTRAINT "task_notifications_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."task_notifications"
    ADD CONSTRAINT "task_notifications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."tasks"
    ADD CONSTRAINT "tasks_assigned_to_fkey" FOREIGN KEY ("assigned_to") REFERENCES "public"."profiles"("id");

ALTER TABLE ONLY "public"."tasks"
    ADD CONSTRAINT "tasks_call_action_item_id_fkey" FOREIGN KEY ("call_action_item_id") REFERENCES "public"."call_action_items"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."tasks"
    ADD CONSTRAINT "tasks_call_id_fkey" FOREIGN KEY ("call_id") REFERENCES "public"."calls"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."tasks"
    ADD CONSTRAINT "tasks_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."profiles"("id");

ALTER TABLE ONLY "public"."tasks"
    ADD CONSTRAINT "tasks_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."tasks"
    ADD CONSTRAINT "tasks_meeting_action_item_id_fkey" FOREIGN KEY ("meeting_action_item_id") REFERENCES "public"."meeting_action_items"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."tasks"
    ADD CONSTRAINT "tasks_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."tasks"
    ADD CONSTRAINT "tasks_parent_task_id_fkey" FOREIGN KEY ("parent_task_id") REFERENCES "public"."tasks"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."team_members"
    ADD CONSTRAINT "team_members_team_id_fkey" FOREIGN KEY ("team_id") REFERENCES "public"."teams"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."team_members"
    ADD CONSTRAINT "team_members_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."topic_aggregation_queue"
    ADD CONSTRAINT "topic_aggregation_queue_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."topic_aggregation_queue"
    ADD CONSTRAINT "topic_aggregation_queue_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."usage_events"
    ADD CONSTRAINT "usage_events_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."usage_events"
    ADD CONSTRAINT "usage_events_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."user_activation_events"
    ADD CONSTRAINT "user_activation_events_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."user_activation_events"
    ADD CONSTRAINT "user_activation_events_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_activity_events"
    ADD CONSTRAINT "user_activity_events_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_activity_events"
    ADD CONSTRAINT "user_activity_events_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_ai_feature_settings"
    ADD CONSTRAINT "user_ai_feature_settings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_ai_preferences"
    ADD CONSTRAINT "user_ai_preferences_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_automation_rules"
    ADD CONSTRAINT "user_automation_rules_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_coaching_preferences"
    ADD CONSTRAINT "user_coaching_preferences_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_engagement_metrics"
    ADD CONSTRAINT "user_engagement_metrics_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_engagement_metrics"
    ADD CONSTRAINT "user_engagement_metrics_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_engagement_metrics"
    ADD CONSTRAINT "user_engagement_metrics_user_id_profiles_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_file_search_stores"
    ADD CONSTRAINT "user_file_search_stores_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_notifications"
    ADD CONSTRAINT "user_notifications_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_notifications"
    ADD CONSTRAINT "user_notifications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_onboarding_progress"
    ADD CONSTRAINT "user_onboarding_progress_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_preferences"
    ADD CONSTRAINT "user_preferences_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_settings"
    ADD CONSTRAINT "user_settings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_sync_status"
    ADD CONSTRAINT "user_sync_status_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_tone_settings"
    ADD CONSTRAINT "user_tone_settings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."user_writing_styles"
    ADD CONSTRAINT "user_writing_styles_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."voice_recordings"
    ADD CONSTRAINT "voice_recordings_company_id_fkey" FOREIGN KEY ("company_id") REFERENCES "public"."companies"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."voice_recordings"
    ADD CONSTRAINT "voice_recordings_contact_id_fkey" FOREIGN KEY ("contact_id") REFERENCES "public"."contacts"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."voice_recordings"
    ADD CONSTRAINT "voice_recordings_deal_id_fkey" FOREIGN KEY ("deal_id") REFERENCES "public"."deals"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."voice_recordings"
    ADD CONSTRAINT "voice_recordings_meeting_id_fkey" FOREIGN KEY ("meeting_id") REFERENCES "public"."meetings"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."voice_recordings"
    ADD CONSTRAINT "voice_recordings_org_id_fkey" FOREIGN KEY ("org_id") REFERENCES "public"."organizations"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."voice_recordings"
    ADD CONSTRAINT "voice_recordings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."waitlist_admin_actions"
    ADD CONSTRAINT "waitlist_admin_actions_admin_user_id_fkey" FOREIGN KEY ("admin_user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."waitlist_admin_actions"
    ADD CONSTRAINT "waitlist_admin_actions_waitlist_entry_id_fkey" FOREIGN KEY ("waitlist_entry_id") REFERENCES "public"."meetings_waitlist"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."waitlist_email_invites"
    ADD CONSTRAINT "waitlist_email_invites_waitlist_entry_id_fkey" FOREIGN KEY ("waitlist_entry_id") REFERENCES "public"."meetings_waitlist"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."waitlist_email_templates"
    ADD CONSTRAINT "waitlist_email_templates_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "public"."profiles"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."waitlist_onboarding_progress"
    ADD CONSTRAINT "waitlist_onboarding_progress_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."waitlist_onboarding_progress"
    ADD CONSTRAINT "waitlist_onboarding_progress_waitlist_entry_id_fkey" FOREIGN KEY ("waitlist_entry_id") REFERENCES "public"."meetings_waitlist"("id") ON DELETE SET NULL;

ALTER TABLE ONLY "public"."waitlist_shares"
    ADD CONSTRAINT "waitlist_shares_waitlist_entry_id_fkey" FOREIGN KEY ("waitlist_entry_id") REFERENCES "public"."meetings_waitlist"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."workflow_executions"
    ADD CONSTRAINT "workflow_executions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

ALTER TABLE ONLY "public"."workflow_forms"
    ADD CONSTRAINT "workflow_forms_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id");

ALTER TABLE ONLY "public"."workflow_mcp_logs"
    ADD CONSTRAINT "workflow_mcp_logs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;

CREATE POLICY "Admins can insert waitlist admin actions" ON "public"."waitlist_admin_actions" FOR INSERT TO "authenticated" WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "Admins can view billing events" ON "public"."billing_event_log" FOR SELECT USING ("public"."is_admin_optimized"());

CREATE POLICY "Admins can view waitlist admin actions" ON "public"."waitlist_admin_actions" FOR SELECT TO "authenticated" USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "Allow anon to read internal_users" ON "public"."internal_users" FOR SELECT TO "anon" USING (true);

CREATE POLICY "Allow authenticated to read internal_users" ON "public"."internal_users" FOR SELECT TO "authenticated" USING (true);

CREATE POLICY "Allow authenticated users to read system_config" ON "public"."system_config" FOR SELECT TO "authenticated" USING (true);

CREATE POLICY "Allow service role full access" ON "public"."internal_users" TO "service_role" USING (true) WITH CHECK (true);

CREATE POLICY "Anyone can insert page views" ON "public"."page_views" FOR INSERT TO "authenticated", "anon" WITH CHECK (true);

CREATE POLICY "Anyone can insert partial signups" ON "public"."partial_signups" FOR INSERT TO "authenticated", "anon" WITH CHECK (true);

CREATE POLICY "Anyone can read active platform skills" ON "public"."platform_skills" FOR SELECT USING (("is_active" = true));

CREATE POLICY "Anyone can read platform skills history" ON "public"."platform_skills_history" FOR SELECT USING (true);

CREATE POLICY "Anyone can update partial signups by session" ON "public"."partial_signups" FOR UPDATE TO "authenticated", "anon" USING (true) WITH CHECK (true);

CREATE POLICY "Anyone can view public voice recordings via share token" ON "public"."voice_recordings" FOR SELECT USING ((("is_public" = true) AND ("share_token" IS NOT NULL)));

CREATE POLICY "Public can validate invite codes" ON "public"."waitlist_invite_codes" FOR SELECT USING (true);

CREATE POLICY "Service role can insert billing events" ON "public"."billing_event_log" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "Service role can insert enrichment" ON "public"."organization_enrichment" FOR INSERT WITH CHECK (true);

CREATE POLICY "Service role can insert platform skills history" ON "public"."platform_skills_history" FOR INSERT WITH CHECK (true);

CREATE POLICY "Service role can insert skills history" ON "public"."organization_skills_history" FOR INSERT WITH CHECK (true);

CREATE POLICY "Service role can manage context" ON "public"."organization_context" USING (true) WITH CHECK (true);

CREATE POLICY "Service role can manage pipeline log" ON "public"."pipeline_automation_log" TO "service_role" USING (true) WITH CHECK (true);

CREATE POLICY "Service role can manage pipeline rules" ON "public"."pipeline_automation_rules" TO "service_role" USING (true) WITH CHECK (true);

CREATE POLICY "Service role can manage workflow results" ON "public"."meeting_workflow_results" TO "service_role" USING (true) WITH CHECK (true);

CREATE POLICY "Service role full access to automation rules" ON "public"."user_automation_rules" USING (((( SELECT "current_setting"('role'::"text", true) AS "current_setting") = 'service_role'::"text") OR (( SELECT "current_setting"('request.jwt.claim.role'::"text", true) AS "current_setting") = 'service_role'::"text")));

CREATE POLICY "Service role full access to calendar connections" ON "public"."meetingbaas_calendars" TO "service_role" USING (true) WITH CHECK (true);

CREATE POLICY "Service role full access to integration alerts" ON "public"."integration_alerts" TO "service_role" USING (true) WITH CHECK (true);

CREATE POLICY "Service role full access to integration test results" ON "public"."integration_test_results" TO "service_role" USING (true) WITH CHECK (true);

CREATE POLICY "Service role has full access to calendar channels" ON "public"."google_calendar_channels" TO "service_role" USING (true) WITH CHECK (true);

CREATE POLICY "Service role has full access to calendars" ON "public"."calendar_calendars" TO "service_role" USING (true) WITH CHECK (true);

CREATE POLICY "Users can view history of accessible templates" ON "public"."ai_prompt_template_history" FOR SELECT USING (("template_id" IN ( SELECT "ai_prompt_templates"."id"
   FROM "public"."ai_prompt_templates")));

ALTER TABLE "public"."action_items" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."activities" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."activity_sync_rules" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."ai_cost_events" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "ai_cost_events_delete" ON "public"."ai_cost_events" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "ai_cost_events_update" ON "public"."ai_cost_events" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."ai_feedback" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."ai_insights" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."ai_prompt_template_history" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."ai_prompt_templates" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."ai_usage_logs" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "ai_usage_logs_delete" ON "public"."ai_usage_logs" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "ai_usage_logs_update" ON "public"."ai_usage_logs" FOR UPDATE USING ("public"."is_service_role"());

CREATE POLICY "anon_insert" ON "public"."vsl_video_analytics" FOR INSERT TO "anon" WITH CHECK (true);

ALTER TABLE "public"."api_key_usage" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "api_key_usage_delete" ON "public"."api_key_usage" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "api_key_usage_insert" ON "public"."api_key_usage" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "api_key_usage_update" ON "public"."api_key_usage" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."api_keys" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."api_monitor_improvements" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."api_monitor_rollups_daily" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."api_monitor_snapshots" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."api_requests" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "api_requests_delete" ON "public"."api_requests" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "api_requests_update" ON "public"."api_requests" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."app_settings" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "app_settings_read" ON "public"."app_settings" FOR SELECT TO "authenticated" USING (true);

ALTER TABLE "public"."audit_logs" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "audit_logs_delete" ON "public"."audit_logs" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "audit_logs_insert" ON "public"."audit_logs" FOR INSERT TO "authenticated" WITH CHECK (true);

CREATE POLICY "audit_logs_select" ON "public"."audit_logs" FOR SELECT TO "authenticated" USING ("public"."is_platform_admin"());

CREATE POLICY "audit_logs_update" ON "public"."audit_logs" FOR UPDATE USING ("public"."is_service_role"());

CREATE POLICY "auth_insert" ON "public"."vsl_video_analytics" FOR INSERT TO "authenticated" WITH CHECK (true);

CREATE POLICY "auth_select" ON "public"."vsl_video_analytics" FOR SELECT TO "authenticated" USING (true);

ALTER TABLE "public"."automation_executions" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."billing_event_log" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."billing_history" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "billing_history_delete" ON "public"."billing_history" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "billing_history_insert" ON "public"."billing_history" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "billing_history_select" ON "public"."billing_history" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "billing_history_update" ON "public"."billing_history" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."booking_sources" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."bot_deployments" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."branding_settings" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "branding_settings_delete" ON "public"."branding_settings" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "branding_settings_insert" ON "public"."branding_settings" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "branding_settings_update" ON "public"."branding_settings" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."calendar_attendees" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "calendar_attendees_delete" ON "public"."calendar_attendees" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "calendar_attendees_insert" ON "public"."calendar_attendees" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "calendar_attendees_update" ON "public"."calendar_attendees" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."calendar_calendars" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."calendar_events" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."calendar_reminders" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "calendar_reminders_delete" ON "public"."calendar_reminders" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "calendar_reminders_insert" ON "public"."calendar_reminders" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "calendar_reminders_update" ON "public"."calendar_reminders" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."calendar_sync_logs" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "calendar_sync_logs_delete" ON "public"."calendar_sync_logs" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "calendar_sync_logs_update" ON "public"."calendar_sync_logs" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."call_action_items" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."call_file_search_index" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "call_file_search_index_service_all" ON "public"."call_file_search_index" TO "service_role" USING (true) WITH CHECK (true);

ALTER TABLE "public"."call_index_queue" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "call_index_queue_service_all" ON "public"."call_index_queue" TO "service_role" USING (true) WITH CHECK (true);

ALTER TABLE "public"."call_transcript_queue" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."calls" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."challenge_features" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "challenge_features_delete" ON "public"."challenge_features" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "challenge_features_insert" ON "public"."challenge_features" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "challenge_features_select" ON "public"."challenge_features" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "challenge_features_update" ON "public"."challenge_features" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."challenges" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "challenges_delete" ON "public"."challenges" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "challenges_insert" ON "public"."challenges" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "challenges_select" ON "public"."challenges" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "challenges_update" ON "public"."challenges" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."clerk_sync_log" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "clerk_sync_log_all" ON "public"."clerk_sync_log" USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."clerk_user_mappings" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "clerk_user_mappings_all" ON "public"."clerk_user_mappings" USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."clients" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."coaching_scorecard_templates" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."communication_events" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."companies" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."company_meeting_insights" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "company_meeting_insights_delete" ON "public"."company_meeting_insights" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "company_meeting_insights_insert" ON "public"."company_meeting_insights" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "company_meeting_insights_update" ON "public"."company_meeting_insights" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."contact_meeting_insights" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "contact_meeting_insights_delete" ON "public"."contact_meeting_insights" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "contact_meeting_insights_insert" ON "public"."contact_meeting_insights" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "contact_meeting_insights_update" ON "public"."contact_meeting_insights" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."contact_notes" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."contacts" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."content" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "content_delete" ON "public"."content" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "content_insert" ON "public"."content" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "content_select" ON "public"."content" FOR SELECT USING (true);

ALTER TABLE "public"."content_topic_links" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "content_topic_links_delete" ON "public"."content_topic_links" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "content_topic_links_insert" ON "public"."content_topic_links" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "content_topic_links_select" ON "public"."content_topic_links" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "content_topic_links_update" ON "public"."content_topic_links" FOR UPDATE USING ("public"."is_service_role"());

CREATE POLICY "content_update" ON "public"."content" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."copilot_analytics" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "copilot_analytics_delete" ON "public"."copilot_analytics" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "copilot_analytics_update" ON "public"."copilot_analytics" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."copilot_conversations" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."copilot_messages" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "copilot_messages_delete" ON "public"."copilot_messages" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "copilot_messages_update" ON "public"."copilot_messages" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."cost_rates" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "cost_rates_delete" ON "public"."cost_rates" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "cost_rates_insert" ON "public"."cost_rates" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "cost_rates_select" ON "public"."cost_rates" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "cost_rates_update" ON "public"."cost_rates" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."cron_job_logs" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."cron_job_settings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."csv_mapping_templates" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."deal_activities" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."deal_clarity_scores" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."deal_close_plan_items" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."deal_health_alerts" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "deal_health_alerts_delete" ON "public"."deal_health_alerts" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "deal_health_alerts_insert" ON "public"."deal_health_alerts" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "deal_health_alerts_update" ON "public"."deal_health_alerts" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."deal_health_history" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "deal_health_history_delete" ON "public"."deal_health_history" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "deal_health_history_insert" ON "public"."deal_health_history" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "deal_health_history_update" ON "public"."deal_health_history" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."deal_health_rules" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "deal_health_rules_delete" ON "public"."deal_health_rules" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "deal_health_rules_insert" ON "public"."deal_health_rules" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "deal_health_rules_select" ON "public"."deal_health_rules" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "deal_health_rules_update" ON "public"."deal_health_rules" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."deal_health_scores" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "deal_health_scores_delete" ON "public"."deal_health_scores" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "deal_health_scores_insert" ON "public"."deal_health_scores" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "deal_health_scores_update" ON "public"."deal_health_scores" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."deal_migration_reviews" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "deal_migration_reviews_all" ON "public"."deal_migration_reviews" USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."deal_notes" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."deal_risk_aggregates" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."deal_risk_signals" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."deal_splits" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "deal_splits_delete" ON "public"."deal_splits" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "deal_splits_insert" ON "public"."deal_splits" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "deal_splits_update" ON "public"."deal_splits" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."deal_stage_history" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."deal_stages" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "deal_stages_select_authenticated" ON "public"."deal_stages" FOR SELECT USING (true);

CREATE POLICY "deal_stages_service_role_all" ON "public"."deal_stages" USING (("current_setting"('role'::"text", true) = 'service_role'::"text"));

ALTER TABLE "public"."deal_truth_fields" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."deals" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."email_attachments" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "email_attachments_delete" ON "public"."email_attachments" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "email_attachments_insert" ON "public"."email_attachments" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "email_attachments_update" ON "public"."email_attachments" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."email_categorizations" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."email_journeys" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."email_label_map" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "email_label_map_delete" ON "public"."email_label_map" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "email_label_map_insert" ON "public"."email_label_map" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "email_label_map_update" ON "public"."email_label_map" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."email_labels" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."email_logs" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "email_logs_service_role_write" ON "public"."email_logs" USING (((("current_setting"('request.jwt.claims'::"text", true))::json ->> 'role'::"text") = 'service_role'::"text")) WITH CHECK (((("current_setting"('request.jwt.claims'::"text", true))::json ->> 'role'::"text") = 'service_role'::"text"));

ALTER TABLE "public"."email_sends" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."email_templates" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."email_threads" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."emails" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."encharge_email_templates" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."execution_checkpoints" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."execution_snapshots" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."fathom_integrations" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."fathom_oauth_states" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."fathom_org_credentials" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."fathom_org_integrations" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."fathom_org_sync_state" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."fathom_sync_state" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."fathom_transcript_retry_jobs" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "fathom_transcript_retry_jobs_delete" ON "public"."fathom_transcript_retry_jobs" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "fathom_transcript_retry_jobs_update" ON "public"."fathom_transcript_retry_jobs" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."fathom_user_mappings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."ghost_detection_signals" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "ghost_detection_signals_delete" ON "public"."ghost_detection_signals" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "ghost_detection_signals_insert" ON "public"."ghost_detection_signals" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "ghost_detection_signals_update" ON "public"."ghost_detection_signals" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."global_topic_sources" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "global_topic_sources_delete" ON "public"."global_topic_sources" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "global_topic_sources_insert" ON "public"."global_topic_sources" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "global_topic_sources_select" ON "public"."global_topic_sources" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "global_topic_sources_update" ON "public"."global_topic_sources" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."global_topics" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "global_topics_delete" ON "public"."global_topics" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "global_topics_insert" ON "public"."global_topics" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "global_topics_select" ON "public"."global_topics" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "global_topics_update" ON "public"."global_topics" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."gmail_label_mappings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."google_calendar_channels" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."google_calendars" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "google_calendars_delete" ON "public"."google_calendars" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "google_calendars_insert" ON "public"."google_calendars" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "google_calendars_update" ON "public"."google_calendars" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."google_docs_templates" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."google_drive_folders" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "google_drive_folders_delete" ON "public"."google_drive_folders" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "google_drive_folders_insert" ON "public"."google_drive_folders" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "google_drive_folders_update" ON "public"."google_drive_folders" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."google_email_labels" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "google_email_labels_delete" ON "public"."google_email_labels" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "google_email_labels_insert" ON "public"."google_email_labels" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "google_email_labels_update" ON "public"."google_email_labels" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."google_integrations" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."google_oauth_states" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."google_service_logs" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "google_service_logs_delete" ON "public"."google_service_logs" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "google_service_logs_insert" ON "public"."google_service_logs" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "google_service_logs_update" ON "public"."google_service_logs" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."google_task_lists" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."google_task_mappings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."google_tasks_list_configs" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."google_tasks_sync_conflicts" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."google_tasks_sync_status" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."hitl_pending_approvals" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "hitl_pending_approvals_service_all" ON "public"."hitl_pending_approvals" TO "service_role" USING (true) WITH CHECK (true);

ALTER TABLE "public"."hitl_requests" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."http_request_recordings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."hubspot_oauth_states" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "hubspot_oauth_states_service_all" ON "public"."hubspot_oauth_states" USING ("public"."is_service_role"()) WITH CHECK ("public"."is_service_role"());

ALTER TABLE "public"."hubspot_object_mappings" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "hubspot_object_mappings_service_all" ON "public"."hubspot_object_mappings" USING ("public"."is_service_role"()) WITH CHECK ("public"."is_service_role"());

ALTER TABLE "public"."hubspot_org_credentials" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "hubspot_org_credentials_service_all" ON "public"."hubspot_org_credentials" USING ("public"."is_service_role"()) WITH CHECK ("public"."is_service_role"());

ALTER TABLE "public"."hubspot_org_integrations" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "hubspot_org_integrations_admin_all" ON "public"."hubspot_org_integrations" USING (("public"."is_service_role"() OR "public"."can_admin_org"("org_id"))) WITH CHECK (("public"."is_service_role"() OR "public"."can_admin_org"("org_id")));

CREATE POLICY "hubspot_org_integrations_select" ON "public"."hubspot_org_integrations" FOR SELECT USING (("public"."is_service_role"() OR "public"."can_access_org_data"("org_id")));

ALTER TABLE "public"."hubspot_org_sync_state" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "hubspot_org_sync_state_select" ON "public"."hubspot_org_sync_state" FOR SELECT USING (("public"."is_service_role"() OR "public"."can_access_org_data"("org_id")));

CREATE POLICY "hubspot_org_sync_state_service_write" ON "public"."hubspot_org_sync_state" USING ("public"."is_service_role"()) WITH CHECK ("public"."is_service_role"());

ALTER TABLE "public"."hubspot_settings" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "hubspot_settings_admin_all" ON "public"."hubspot_settings" USING (("public"."is_service_role"() OR "public"."can_admin_org"("org_id"))) WITH CHECK (("public"."is_service_role"() OR "public"."can_admin_org"("org_id")));

CREATE POLICY "hubspot_settings_select" ON "public"."hubspot_settings" FOR SELECT USING (("public"."is_service_role"() OR "public"."can_access_org_data"("org_id")));

ALTER TABLE "public"."hubspot_sync_queue" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "hubspot_sync_queue_service_all" ON "public"."hubspot_sync_queue" USING ("public"."is_service_role"()) WITH CHECK ("public"."is_service_role"());

ALTER TABLE "public"."hubspot_webhook_events" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "hubspot_webhook_events_service_all" ON "public"."hubspot_webhook_events" USING ("public"."is_service_role"()) WITH CHECK ("public"."is_service_role"());

ALTER TABLE "public"."impersonation_logs" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "impersonation_logs_all" ON "public"."impersonation_logs" USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."integration_alerts" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."integration_sync_logs" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "integration_sync_logs_service_all" ON "public"."integration_sync_logs" TO "service_role" USING (true) WITH CHECK (true);

ALTER TABLE "public"."integration_test_results" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."internal_email_domains" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."internal_users" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."intervention_templates" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "intervention_templates_delete" ON "public"."intervention_templates" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "intervention_templates_insert" ON "public"."intervention_templates" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "intervention_templates_select" ON "public"."intervention_templates" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "intervention_templates_update" ON "public"."intervention_templates" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."interventions" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "interventions_delete" ON "public"."interventions" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "interventions_insert" ON "public"."interventions" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "interventions_update" ON "public"."interventions" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."justcall_integration_secrets" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."justcall_integrations" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."justcall_oauth_states" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."launch_checklist_items" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."lead_events" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "lead_events_delete" ON "public"."lead_events" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "lead_events_insert" ON "public"."lead_events" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "lead_events_update" ON "public"."lead_events" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."lead_prep_notes" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."lead_sources" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."leads" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."mcp_connections" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."meeting_action_items" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."meeting_aggregate_metrics" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."meeting_attendees" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "meeting_attendees_delete" ON "public"."meeting_attendees" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "meeting_attendees_insert" ON "public"."meeting_attendees" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "meeting_attendees_update" ON "public"."meeting_attendees" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."meeting_classifications" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."meeting_contacts" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "meeting_contacts_delete" ON "public"."meeting_contacts" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "meeting_contacts_insert" ON "public"."meeting_contacts" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "meeting_contacts_update" ON "public"."meeting_contacts" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."meeting_content_topics" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."meeting_documents" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "meeting_documents_delete" ON "public"."meeting_documents" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "meeting_documents_insert" ON "public"."meeting_documents" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "meeting_documents_update" ON "public"."meeting_documents" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."meeting_file_search_index" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."meeting_generated_content" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."meeting_index_queue" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."meeting_intelligence_queries" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."meeting_metrics" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "meeting_metrics_delete" ON "public"."meeting_metrics" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "meeting_metrics_insert" ON "public"."meeting_metrics" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "meeting_metrics_update" ON "public"."meeting_metrics" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."meeting_scorecards" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."meeting_structured_summaries" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."meeting_topics" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "meeting_topics_delete" ON "public"."meeting_topics" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "meeting_topics_insert" ON "public"."meeting_topics" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "meeting_topics_update" ON "public"."meeting_topics" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."meeting_workflow_results" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."meetingbaas_calendars" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."meetings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."meetings_waitlist" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "meetings_waitlist_insert" ON "public"."meetings_waitlist" FOR INSERT WITH CHECK (true);

CREATE POLICY "meetings_waitlist_select" ON "public"."meetings_waitlist" FOR SELECT USING (true);

ALTER TABLE "public"."next_action_suggestions" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "next_action_suggestions_delete" ON "public"."next_action_suggestions" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "next_action_suggestions_insert" ON "public"."next_action_suggestions" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "next_action_suggestions_update" ON "public"."next_action_suggestions" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."node_executions" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."node_fixtures" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."notetaker_user_settings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."notification_feedback" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."notification_interactions" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."notification_queue" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."notification_rate_limits" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "notification_rate_limits_all" ON "public"."notification_rate_limits" USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."notifications" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "notifications_insert" ON "public"."notifications" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "org_admins_manage_justcall_integration_secrets" ON "public"."justcall_integration_secrets" USING (("public"."can_admin_org"("org_id") OR "public"."is_service_role"())) WITH CHECK (("public"."can_admin_org"("org_id") OR "public"."is_service_role"()));

CREATE POLICY "org_admins_manage_justcall_integrations" ON "public"."justcall_integrations" USING (("public"."can_admin_org"("org_id") OR "public"."is_service_role"())) WITH CHECK (("public"."can_admin_org"("org_id") OR "public"."is_service_role"()));

ALTER TABLE "public"."org_ai_preferences" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."org_call_types" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "org_delete_call_action_items" ON "public"."call_action_items" FOR DELETE USING (("public"."can_write_to_org"("org_id") OR "public"."is_service_role"()));

CREATE POLICY "org_delete_calls" ON "public"."calls" FOR DELETE USING (("public"."can_write_to_org"("org_id") OR "public"."is_service_role"()));

ALTER TABLE "public"."org_email_categorization_settings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."org_file_search_stores" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "org_file_search_stores_delete" ON "public"."org_file_search_stores" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "org_file_search_stores_insert" ON "public"."org_file_search_stores" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "org_file_search_stores_select" ON "public"."org_file_search_stores" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "org_file_search_stores_update" ON "public"."org_file_search_stores" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "org_insert_call_action_items" ON "public"."call_action_items" FOR INSERT WITH CHECK (("public"."can_write_to_org"("org_id") OR "public"."is_service_role"()));

CREATE POLICY "org_insert_calls" ON "public"."calls" FOR INSERT WITH CHECK (("public"."can_write_to_org"("org_id") OR "public"."is_service_role"()));

ALTER TABLE "public"."org_proposal_workflows" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "org_select_call_action_items" ON "public"."call_action_items" FOR SELECT USING (("public"."can_access_org_data"("org_id") OR "public"."is_service_role"()));

CREATE POLICY "org_select_calls" ON "public"."calls" FOR SELECT USING (("public"."can_access_org_data"("org_id") OR "public"."is_service_role"()));

CREATE POLICY "org_select_justcall_integrations" ON "public"."justcall_integrations" FOR SELECT USING (("public"."can_access_org_data"("org_id") OR "public"."is_service_role"()));

CREATE POLICY "org_update_call_action_items" ON "public"."call_action_items" FOR UPDATE USING (("public"."can_access_org_data"("org_id") OR "public"."is_service_role"())) WITH CHECK (("public"."can_write_to_org"("org_id") OR "public"."is_service_role"()));

CREATE POLICY "org_update_calls" ON "public"."calls" FOR UPDATE USING (("public"."can_access_org_data"("org_id") OR "public"."is_service_role"())) WITH CHECK (("public"."can_write_to_org"("org_id") OR "public"."is_service_role"()));

ALTER TABLE "public"."organization_context" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."organization_enrichment" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."organization_feature_flags" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "organization_feature_flags_delete" ON "public"."organization_feature_flags" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "organization_feature_flags_insert" ON "public"."organization_feature_flags" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "organization_feature_flags_select" ON "public"."organization_feature_flags" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "organization_feature_flags_update" ON "public"."organization_feature_flags" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."organization_invitations" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "organization_invitations_delete" ON "public"."organization_invitations" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "organization_invitations_insert" ON "public"."organization_invitations" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."can_admin_org"("org_id")));

CREATE POLICY "organization_invitations_select" ON "public"."organization_invitations" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "organization_invitations_update" ON "public"."organization_invitations" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."organization_memberships" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."organization_skills" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."organization_skills_history" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."organization_subscriptions" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "organization_subscriptions_delete" ON "public"."organization_subscriptions" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "organization_subscriptions_insert" ON "public"."organization_subscriptions" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "organization_subscriptions_update" ON "public"."organization_subscriptions" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."organization_usage" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "organization_usage_delete" ON "public"."organization_usage" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "organization_usage_insert" ON "public"."organization_usage" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "organization_usage_select" ON "public"."organization_usage" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "organization_usage_update" ON "public"."organization_usage" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."organizations" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."page_views" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."partial_signups" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."pipeline_automation_log" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."pipeline_automation_rules" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."pipeline_stage_recommendations" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "pipeline_stage_recommendations_delete" ON "public"."pipeline_stage_recommendations" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "pipeline_stage_recommendations_insert" ON "public"."pipeline_stage_recommendations" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "pipeline_stage_recommendations_update" ON "public"."pipeline_stage_recommendations" FOR UPDATE USING ("public"."is_service_role"());

CREATE POLICY "platform_admin_manage_internal_users" ON "public"."internal_users" TO "authenticated" USING ("public"."is_admin_optimized"()) WITH CHECK ("public"."is_admin_optimized"());

ALTER TABLE "public"."platform_skills" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."platform_skills_history" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."pricing_plans" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "pricing_plans_delete" ON "public"."pricing_plans" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "pricing_plans_insert" ON "public"."pricing_plans" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "pricing_plans_select" ON "public"."pricing_plans" FOR SELECT USING (true);

CREATE POLICY "pricing_plans_update" ON "public"."pricing_plans" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."process_map_coverage_snapshots" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."process_map_fixtures" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."process_map_mocks" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."process_map_scenario_runs" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."process_map_step_results" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."process_map_test_runs" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."process_map_test_scenarios" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."process_map_workflows" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."process_maps" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "profiles_delete" ON "public"."profiles" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

COMMENT ON POLICY "profiles_delete" ON "public"."profiles" IS 'Allows service role and platform admins to delete profiles. Regular users cannot delete profiles.';

COMMENT ON POLICY "profiles_select" ON "public"."profiles" IS 'Allows users to see their own profile, profiles of users in the same organization(s), and all profiles if admin. Uses SECURITY DEFINER helper to avoid RLS recursion.';

ALTER TABLE "public"."proposal_jobs" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."proposal_templates" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."proposals" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."rate_limit" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."recording_rules" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."recording_usage" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."recordings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."relationship_health_history" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "relationship_health_history_delete" ON "public"."relationship_health_history" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "relationship_health_history_insert" ON "public"."relationship_health_history" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "relationship_health_history_update" ON "public"."relationship_health_history" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."relationship_health_scores" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "relationship_health_scores_delete" ON "public"."relationship_health_scores" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "relationship_health_scores_insert" ON "public"."relationship_health_scores" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "relationship_health_scores_update" ON "public"."relationship_health_scores" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."roadmap_comments" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "roadmap_comments_select" ON "public"."roadmap_comments" FOR SELECT USING (true);

ALTER TABLE "public"."roadmap_suggestions" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "roadmap_suggestions_select" ON "public"."roadmap_suggestions" FOR SELECT USING (true);

ALTER TABLE "public"."roadmap_votes" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "roadmap_votes_select" ON "public"."roadmap_votes" FOR SELECT USING (true);

ALTER TABLE "public"."savvycal_integration_secrets" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "savvycal_integration_secrets_admin_all" ON "public"."savvycal_integration_secrets" USING (("public"."is_service_role"() OR "public"."can_admin_org"("org_id"))) WITH CHECK (("public"."is_service_role"() OR "public"."can_admin_org"("org_id")));

ALTER TABLE "public"."savvycal_integrations" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "savvycal_integrations_admin_delete" ON "public"."savvycal_integrations" FOR DELETE USING (("public"."is_service_role"() OR "public"."can_admin_org"("org_id")));

CREATE POLICY "savvycal_integrations_admin_insert" ON "public"."savvycal_integrations" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."can_admin_org"("org_id")));

CREATE POLICY "savvycal_integrations_admin_update" ON "public"."savvycal_integrations" FOR UPDATE USING (("public"."is_service_role"() OR "public"."can_admin_org"("org_id"))) WITH CHECK (("public"."is_service_role"() OR "public"."can_admin_org"("org_id")));

CREATE POLICY "savvycal_integrations_select" ON "public"."savvycal_integrations" FOR SELECT USING (("public"."is_service_role"() OR "public"."can_access_org_data"("org_id")));

ALTER TABLE "public"."savvycal_link_mappings" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "savvycal_link_mappings_delete" ON "public"."savvycal_link_mappings" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "savvycal_link_mappings_insert" ON "public"."savvycal_link_mappings" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "savvycal_link_mappings_select" ON "public"."savvycal_link_mappings" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "savvycal_link_mappings_update" ON "public"."savvycal_link_mappings" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."savvycal_source_mappings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."scenario_fixtures" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."sentiment_alerts" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "sentiment_alerts_insert" ON "public"."sentiment_alerts" FOR INSERT WITH CHECK ("public"."is_service_role"());

ALTER TABLE "public"."sentry_bridge_config" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."sentry_bridge_metrics" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."sentry_bridge_queue" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."sentry_dead_letter_queue" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."sentry_issue_mappings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."sentry_routing_rules" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."sentry_triage_queue" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."sentry_webhook_events" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."sentry_webhook_queue" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."sequence_executions" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."sequence_hitl_requests" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."sequence_references_archive" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."sequence_token_budgets" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "service_role_deal_stage_history" ON "public"."deal_stage_history" TO "service_role" USING (true) WITH CHECK (true);

CREATE POLICY "service_role_manage_call_transcript_queue" ON "public"."call_transcript_queue" USING ("public"."is_service_role"()) WITH CHECK ("public"."is_service_role"());

CREATE POLICY "service_role_manage_justcall_oauth_states" ON "public"."justcall_oauth_states" USING ("public"."is_service_role"()) WITH CHECK ("public"."is_service_role"());

ALTER TABLE "public"."skill_output_storage" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."slack_channels" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."slack_deal_rooms" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "slack_deal_rooms_delete" ON "public"."slack_deal_rooms" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "slack_deal_rooms_insert" ON "public"."slack_deal_rooms" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "slack_deal_rooms_select" ON "public"."slack_deal_rooms" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "slack_deal_rooms_update" ON "public"."slack_deal_rooms" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."slack_integrations" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "slack_integrations_delete" ON "public"."slack_integrations" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "slack_integrations_insert" ON "public"."slack_integrations" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "slack_integrations_select" ON "public"."slack_integrations" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "slack_integrations_update" ON "public"."slack_integrations" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."slack_notification_settings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."slack_notifications_sent" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "slack_notifications_sent_delete" ON "public"."slack_notifications_sent" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "slack_notifications_sent_insert" ON "public"."slack_notifications_sent" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "slack_notifications_sent_select" ON "public"."slack_notifications_sent" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "slack_notifications_sent_update" ON "public"."slack_notifications_sent" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."slack_org_settings" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "slack_org_settings_delete" ON "public"."slack_org_settings" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "slack_org_settings_insert" ON "public"."slack_org_settings" FOR INSERT WITH CHECK ("public"."is_service_role"());

ALTER TABLE "public"."slack_user_mappings" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "slack_user_mappings_delete" ON "public"."slack_user_mappings" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "slack_user_mappings_insert" ON "public"."slack_user_mappings" FOR INSERT WITH CHECK ("public"."is_service_role"());

ALTER TABLE "public"."smart_task_templates" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "smart_task_templates_delete" ON "public"."smart_task_templates" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "smart_task_templates_insert" ON "public"."smart_task_templates" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "smart_task_templates_update" ON "public"."smart_task_templates" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."solutions" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "solutions_delete" ON "public"."solutions" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "solutions_insert" ON "public"."solutions" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "solutions_select" ON "public"."solutions" FOR SELECT USING (true);

CREATE POLICY "solutions_update" ON "public"."solutions" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."stages" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "stages_delete" ON "public"."stages" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "stages_insert" ON "public"."stages" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "stages_select" ON "public"."stages" FOR SELECT USING (true);

CREATE POLICY "stages_update" ON "public"."stages" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."subscription_plans" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "subscription_plans_delete" ON "public"."subscription_plans" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "subscription_plans_insert" ON "public"."subscription_plans" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "subscription_plans_select" ON "public"."subscription_plans" FOR SELECT USING (true);

CREATE POLICY "subscription_plans_update" ON "public"."subscription_plans" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."subscription_seat_usage" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "subscription_seat_usage_delete" ON "public"."subscription_seat_usage" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "subscription_seat_usage_insert" ON "public"."subscription_seat_usage" FOR INSERT WITH CHECK ("public"."is_service_role"());

CREATE POLICY "subscription_seat_usage_select" ON "public"."subscription_seat_usage" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "subscription_seat_usage_update" ON "public"."subscription_seat_usage" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."system_config" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."targets" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "targets_delete" ON "public"."targets" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "targets_insert" ON "public"."targets" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "targets_update" ON "public"."targets" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."task_notifications" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "task_notifications_insert" ON "public"."task_notifications" FOR INSERT WITH CHECK ("public"."is_service_role"());

ALTER TABLE "public"."tasks" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."team_members" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "team_members_delete" ON "public"."team_members" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "team_members_insert" ON "public"."team_members" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "team_members_update" ON "public"."team_members" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."teams" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "teams_delete" ON "public"."teams" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "teams_insert" ON "public"."teams" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "teams_update" ON "public"."teams" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."topic_aggregation_queue" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "topic_aggregation_queue_all" ON "public"."topic_aggregation_queue" USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."usage_events" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "usage_events_delete" ON "public"."usage_events" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "usage_events_update" ON "public"."usage_events" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."user_activation_events" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_activity_events" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_ai_feature_settings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_ai_preferences" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_automation_rules" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_coaching_preferences" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_engagement_metrics" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_file_search_stores" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_notifications" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_onboarding_progress" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_preferences" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_profiles" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_roles" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "user_roles_delete" ON "public"."user_roles" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "user_roles_insert" ON "public"."user_roles" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "user_roles_select" ON "public"."user_roles" FOR SELECT USING (true);

CREATE POLICY "user_roles_update" ON "public"."user_roles" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."user_settings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_sync_status" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_tone_settings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."user_writing_styles" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."variable_storage" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."voice_recordings" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."vsl_video_analytics" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."waitlist_admin_actions" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "waitlist_admin_actions_all" ON "public"."waitlist_admin_actions" USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."waitlist_email_invites" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "waitlist_email_invites_delete" ON "public"."waitlist_email_invites" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "waitlist_email_invites_insert" ON "public"."waitlist_email_invites" FOR INSERT WITH CHECK (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "waitlist_email_invites_select" ON "public"."waitlist_email_invites" FOR SELECT USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "waitlist_email_invites_update" ON "public"."waitlist_email_invites" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."waitlist_email_templates" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "waitlist_email_templates_all" ON "public"."waitlist_email_templates" USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."waitlist_invite_codes" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."waitlist_onboarding_progress" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."waitlist_shares" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "waitlist_shares_delete" ON "public"."waitlist_shares" FOR DELETE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

CREATE POLICY "waitlist_shares_update" ON "public"."waitlist_shares" FOR UPDATE USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."webhook_events" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."webhook_mirror_config" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "webhook_mirror_config_all" ON "public"."webhook_mirror_config" USING (("public"."is_service_role"() OR "public"."is_admin_optimized"()));

ALTER TABLE "public"."workflow_batch_windows" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."workflow_circuit_breakers" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."workflow_contracts" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."workflow_dead_letter_queue" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."workflow_environment_promotions" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."workflow_environments" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."workflow_executions" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."workflow_forms" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."workflow_idempotency_keys" ENABLE ROW LEVEL SECURITY;

ALTER TABLE "public"."workflow_mcp_logs" ENABLE ROW LEVEL SECURITY;

CREATE POLICY "workflow_mcp_logs_delete" ON "public"."workflow_mcp_logs" FOR DELETE USING ("public"."is_service_role"());

CREATE POLICY "workflow_mcp_logs_update" ON "public"."workflow_mcp_logs" FOR UPDATE USING ("public"."is_service_role"());

ALTER TABLE "public"."workflow_rate_limits" ENABLE ROW LEVEL SECURITY;

GRANT USAGE ON SCHEMA "public" TO "postgres";

GRANT USAGE ON SCHEMA "public" TO "anon";

GRANT USAGE ON SCHEMA "public" TO "authenticated";

GRANT USAGE ON SCHEMA "public" TO "service_role";

GRANT ALL ON FUNCTION "public"."accept_next_action_suggestion"("p_suggestion_id" "uuid", "p_task_data" "jsonb") TO "anon";

GRANT ALL ON FUNCTION "public"."accept_next_action_suggestion"("p_suggestion_id" "uuid", "p_task_data" "jsonb") TO "authenticated";

GRANT ALL ON FUNCTION "public"."accept_next_action_suggestion"("p_suggestion_id" "uuid", "p_task_data" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."accept_org_invitation"("p_token" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."accept_org_invitation"("p_token" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."accept_org_invitation"("p_token" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."add_invited_user_to_admin_org"() TO "anon";

GRANT ALL ON FUNCTION "public"."add_invited_user_to_admin_org"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."add_invited_user_to_admin_org"() TO "service_role";

GRANT ALL ON FUNCTION "public"."adjust_notification_fatigue"("p_user_id" "uuid", "p_adjustment" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."adjust_notification_fatigue"("p_user_id" "uuid", "p_adjustment" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."adjust_notification_fatigue"("p_user_id" "uuid", "p_adjustment" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."aggregate_company_meeting_insights"("p_company_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."aggregate_company_meeting_insights"("p_company_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."aggregate_company_meeting_insights"("p_company_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."aggregate_contact_meeting_insights"("p_contact_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."aggregate_contact_meeting_insights"("p_contact_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."aggregate_contact_meeting_insights"("p_contact_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."analyze_action_item_with_ai"("p_action_item_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."analyze_action_item_with_ai"("p_action_item_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."analyze_action_item_with_ai"("p_action_item_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."apply_ai_analysis_to_task"("p_action_item_id" "uuid", "p_task_type" "text", "p_ideal_deadline" "date", "p_confidence_score" numeric, "p_reasoning" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."apply_ai_analysis_to_task"("p_action_item_id" "uuid", "p_task_type" "text", "p_ideal_deadline" "date", "p_confidence_score" numeric, "p_reasoning" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."apply_ai_analysis_to_task"("p_action_item_id" "uuid", "p_task_type" "text", "p_ideal_deadline" "date", "p_confidence_score" numeric, "p_reasoning" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."approve_pipeline_recommendation"("p_recommendation_id" "uuid", "p_reviewed_by" "uuid", "p_notes" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."approve_pipeline_recommendation"("p_recommendation_id" "uuid", "p_reviewed_by" "uuid", "p_notes" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."approve_pipeline_recommendation"("p_recommendation_id" "uuid", "p_reviewed_by" "uuid", "p_notes" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."audit_trigger_function"() TO "anon";

GRANT ALL ON FUNCTION "public"."audit_trigger_function"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."audit_trigger_function"() TO "service_role";

GRANT ALL ON FUNCTION "public"."auto_apply_pipeline_recommendations"() TO "anon";

GRANT ALL ON FUNCTION "public"."auto_apply_pipeline_recommendations"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."auto_apply_pipeline_recommendations"() TO "service_role";

GRANT ALL ON FUNCTION "public"."auto_assign_to_sixty_seconds_org"() TO "anon";

GRANT ALL ON FUNCTION "public"."auto_assign_to_sixty_seconds_org"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."auto_assign_to_sixty_seconds_org"() TO "service_role";

GRANT ALL ON FUNCTION "public"."auto_calculate_cost"() TO "anon";

GRANT ALL ON FUNCTION "public"."auto_calculate_cost"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."auto_calculate_cost"() TO "service_role";

GRANT ALL ON FUNCTION "public"."auto_churn_expired_clients"() TO "anon";

GRANT ALL ON FUNCTION "public"."auto_churn_expired_clients"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."auto_churn_expired_clients"() TO "service_role";

GRANT ALL ON FUNCTION "public"."auto_create_org_for_new_user"() TO "anon";

GRANT ALL ON FUNCTION "public"."auto_create_org_for_new_user"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."auto_create_org_for_new_user"() TO "service_role";

GRANT ALL ON FUNCTION "public"."auto_create_task_from_action_item"() TO "anon";

GRANT ALL ON FUNCTION "public"."auto_create_task_from_action_item"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."auto_create_task_from_action_item"() TO "service_role";

GRANT ALL ON FUNCTION "public"."auto_create_task_from_action_item_v2"() TO "anon";

GRANT ALL ON FUNCTION "public"."auto_create_task_from_action_item_v2"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."auto_create_task_from_action_item_v2"() TO "service_role";

GRANT ALL ON FUNCTION "public"."auto_populate_suggestion_user_id"() TO "anon";

GRANT ALL ON FUNCTION "public"."auto_populate_suggestion_user_id"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."auto_populate_suggestion_user_id"() TO "service_role";

GRANT ALL ON FUNCTION "public"."auto_process_activity"() TO "anon";

GRANT ALL ON FUNCTION "public"."auto_process_activity"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."auto_process_activity"() TO "service_role";

GRANT ALL ON FUNCTION "public"."auto_reset_stuck_fathom_sync"() TO "anon";

GRANT ALL ON FUNCTION "public"."auto_reset_stuck_fathom_sync"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."auto_reset_stuck_fathom_sync"() TO "service_role";

GRANT ALL ON FUNCTION "public"."auto_verify_email_for_access_code_user"() TO "anon";

GRANT ALL ON FUNCTION "public"."auto_verify_email_for_access_code_user"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."auto_verify_email_for_access_code_user"() TO "service_role";

GRANT ALL ON FUNCTION "public"."award_email_invite_points"() TO "anon";

GRANT ALL ON FUNCTION "public"."award_email_invite_points"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."award_email_invite_points"() TO "service_role";

GRANT ALL ON FUNCTION "public"."backfill_next_actions_for_meetings"("p_limit" integer, "p_min_date" timestamp with time zone) TO "anon";

GRANT ALL ON FUNCTION "public"."backfill_next_actions_for_meetings"("p_limit" integer, "p_min_date" timestamp with time zone) TO "authenticated";

GRANT ALL ON FUNCTION "public"."backfill_next_actions_for_meetings"("p_limit" integer, "p_min_date" timestamp with time zone) TO "service_role";

GRANT ALL ON FUNCTION "public"."bulk_grant_waitlist_access"("p_entry_ids" "uuid"[], "p_admin_user_id" "uuid", "p_admin_notes" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."bulk_grant_waitlist_access"("p_entry_ids" "uuid"[], "p_admin_user_id" "uuid", "p_admin_notes" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."bulk_grant_waitlist_access"("p_entry_ids" "uuid"[], "p_admin_user_id" "uuid", "p_admin_notes" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_activity_points"("activity_type" "public"."activity_type", "amount" numeric) TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_activity_points"("activity_type" "public"."activity_type", "amount" numeric) TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_activity_points"("activity_type" "public"."activity_type", "amount" numeric) TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_activity_trend"("user_id" "uuid", "activity_type" "public"."activity_type", "start_date" timestamp with time zone, "end_date" timestamp with time zone) TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_activity_trend"("user_id" "uuid", "activity_type" "public"."activity_type", "start_date" timestamp with time zone, "end_date" timestamp with time zone) TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_activity_trend"("user_id" "uuid", "activity_type" "public"."activity_type", "start_date" timestamp with time zone, "end_date" timestamp with time zone) TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_ai_cost"("p_provider" character varying, "p_model" character varying, "p_prompt_tokens" integer, "p_completion_tokens" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_ai_cost"("p_provider" character varying, "p_model" character varying, "p_prompt_tokens" integer, "p_completion_tokens" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_ai_cost"("p_provider" character varying, "p_model" character varying, "p_prompt_tokens" integer, "p_completion_tokens" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_churn_rate"("p_start_date" "date", "p_end_date" "date", "p_currency" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_churn_rate"("p_start_date" "date", "p_end_date" "date", "p_currency" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_churn_rate"("p_start_date" "date", "p_end_date" "date", "p_currency" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_close_plan_progress"("p_deal_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_close_plan_progress"("p_deal_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_close_plan_progress"("p_deal_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_contact_engagement_score"("p_total_meetings" integer, "p_avg_sentiment" numeric, "p_days_since_last_meeting" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_contact_engagement_score"("p_total_meetings" integer, "p_avg_sentiment" numeric, "p_days_since_last_meeting" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_contact_engagement_score"("p_total_meetings" integer, "p_avg_sentiment" numeric, "p_days_since_last_meeting" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_deal_annual_value"("p_one_off_revenue" numeric, "p_monthly_mrr" numeric) TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_deal_annual_value"("p_one_off_revenue" numeric, "p_monthly_mrr" numeric) TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_deal_annual_value"("p_one_off_revenue" numeric, "p_monthly_mrr" numeric) TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_deal_clarity_score"("p_deal_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_deal_clarity_score"("p_deal_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_deal_clarity_score"("p_deal_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_deal_momentum_score"("p_deal_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_deal_momentum_score"("p_deal_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_deal_momentum_score"("p_deal_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_deal_risk_aggregate"("p_deal_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_deal_risk_aggregate"("p_deal_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_deal_risk_aggregate"("p_deal_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_deal_total_value"("p_one_off_revenue" numeric, "p_monthly_mrr" numeric) TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_deal_total_value"("p_one_off_revenue" numeric, "p_monthly_mrr" numeric) TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_deal_total_value"("p_one_off_revenue" numeric, "p_monthly_mrr" numeric) TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_effective_position"() TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_effective_position"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_effective_position"() TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_meeting_content_costs"("p_meeting_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_meeting_content_costs"("p_meeting_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_meeting_content_costs"("p_meeting_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_normalized_monthly_amount"("p_amount_cents" integer, "p_interval" "text", "p_interval_count" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_normalized_monthly_amount"("p_amount_cents" integer, "p_interval" "text", "p_interval_count" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_normalized_monthly_amount"("p_amount_cents" integer, "p_interval" "text", "p_interval_count" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_realized_ltv"("p_cohort_start" "date", "p_cohort_end" "date", "p_currency" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_realized_ltv"("p_cohort_start" "date", "p_cohort_end" "date", "p_currency" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_realized_ltv"("p_cohort_start" "date", "p_cohort_end" "date", "p_currency" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_seat_overage"("p_subscription_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_seat_overage"("p_subscription_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_seat_overage"("p_subscription_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_sentiment_trend"("p_company_id" "uuid", "p_contact_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_sentiment_trend"("p_company_id" "uuid", "p_contact_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_sentiment_trend"("p_company_id" "uuid", "p_contact_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_split_amount"("p_deal_id" "uuid", "p_percentage" numeric) TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_split_amount"("p_deal_id" "uuid", "p_percentage" numeric) TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_split_amount"("p_deal_id" "uuid", "p_percentage" numeric) TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_token_cost"("p_provider" "text", "p_model" "text", "p_input_tokens" integer, "p_output_tokens" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_token_cost"("p_provider" "text", "p_model" "text", "p_input_tokens" integer, "p_output_tokens" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_token_cost"("p_provider" "text", "p_model" "text", "p_input_tokens" integer, "p_output_tokens" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_topic_relevance_score"("p_frequency_score" numeric, "p_recency_score" numeric) TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_topic_relevance_score"("p_frequency_score" numeric, "p_recency_score" numeric) TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_topic_relevance_score"("p_frequency_score" numeric, "p_recency_score" numeric) TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_total_points"() TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_total_points"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_total_points"() TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_trial_conversion_rate"("p_start_date" "date", "p_end_date" "date") TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_trial_conversion_rate"("p_start_date" "date", "p_end_date" "date") TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_trial_conversion_rate"("p_start_date" "date", "p_end_date" "date") TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_waitlist_onboarding_completion"() TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_waitlist_onboarding_completion"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_waitlist_onboarding_completion"() TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_waitlist_points"() TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_waitlist_points"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_waitlist_points"() TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_win_rate"("user_id" "uuid", "start_date" timestamp with time zone, "end_date" timestamp with time zone) TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_win_rate"("user_id" "uuid", "start_date" timestamp with time zone, "end_date" timestamp with time zone) TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_win_rate"("user_id" "uuid", "start_date" timestamp with time zone, "end_date" timestamp with time zone) TO "service_role";

GRANT ALL ON FUNCTION "public"."calculate_workflow_coverage"("p_checklist_results" "jsonb") TO "anon";

GRANT ALL ON FUNCTION "public"."calculate_workflow_coverage"("p_checklist_results" "jsonb") TO "authenticated";

GRANT ALL ON FUNCTION "public"."calculate_workflow_coverage"("p_checklist_results" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."call_auto_join_scheduler"() TO "anon";

GRANT ALL ON FUNCTION "public"."call_auto_join_scheduler"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."call_auto_join_scheduler"() TO "service_role";

GRANT ALL ON FUNCTION "public"."call_suggest_next_actions_async"("p_activity_id" "uuid", "p_activity_type" "text", "p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."call_suggest_next_actions_async"("p_activity_id" "uuid", "p_activity_type" "text", "p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."call_suggest_next_actions_async"("p_activity_id" "uuid", "p_activity_type" "text", "p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."can_access_org_data"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."can_access_org_data"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."can_access_org_data"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."can_admin_org"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."can_admin_org"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."can_admin_org"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."can_user_access_meeting_action_item"("p_action_item_id" "uuid", "p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."can_user_access_meeting_action_item"("p_action_item_id" "uuid", "p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."can_user_access_meeting_action_item"("p_action_item_id" "uuid", "p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."can_write_to_org"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."can_write_to_org"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."can_write_to_org"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."cancel_stale_notifications"() TO "anon";

GRANT ALL ON FUNCTION "public"."cancel_stale_notifications"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."cancel_stale_notifications"() TO "service_role";

GRANT ALL ON FUNCTION "public"."check_cron_failures_and_notify"() TO "anon";

GRANT ALL ON FUNCTION "public"."check_cron_failures_and_notify"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."check_cron_failures_and_notify"() TO "service_role";

GRANT ALL ON FUNCTION "public"."check_meeting_limits"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."check_meeting_limits"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."check_meeting_limits"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."check_notification_floods"("p_alert_threshold" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."check_notification_floods"("p_alert_threshold" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."check_notification_floods"("p_alert_threshold" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."check_rate_limit"("key_hash_val" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."check_rate_limit"("key_hash_val" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."check_rate_limit"("key_hash_val" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."check_recording_quota"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."check_recording_quota"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."check_recording_quota"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."check_sentry_bridge_rate_limit"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."check_sentry_bridge_rate_limit"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."check_sentry_bridge_rate_limit"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."check_user_exists_by_email"("p_email" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."check_user_exists_by_email"("p_email" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."check_user_exists_by_email"("p_email" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."claim_notification_for_processing"("p_queue_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."claim_notification_for_processing"("p_queue_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."claim_notification_for_processing"("p_queue_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."claim_waitlist_boost"("p_entry_id" "uuid", "p_platform" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."claim_waitlist_boost"("p_entry_id" "uuid", "p_platform" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."claim_waitlist_boost"("p_entry_id" "uuid", "p_platform" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."clean_activity_fields"() TO "anon";

GRANT ALL ON FUNCTION "public"."clean_activity_fields"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."clean_activity_fields"() TO "service_role";

GRANT ALL ON FUNCTION "public"."cleanup_expired_calendar_channels"() TO "anon";

GRANT ALL ON FUNCTION "public"."cleanup_expired_calendar_channels"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."cleanup_expired_calendar_channels"() TO "service_role";

GRANT ALL ON FUNCTION "public"."cleanup_expired_fathom_oauth_states"() TO "anon";

GRANT ALL ON FUNCTION "public"."cleanup_expired_fathom_oauth_states"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."cleanup_expired_fathom_oauth_states"() TO "service_role";

GRANT ALL ON FUNCTION "public"."cleanup_expired_google_oauth_states"() TO "anon";

GRANT ALL ON FUNCTION "public"."cleanup_expired_google_oauth_states"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."cleanup_expired_google_oauth_states"() TO "service_role";

GRANT ALL ON FUNCTION "public"."cleanup_expired_google_tokens"() TO "anon";

GRANT ALL ON FUNCTION "public"."cleanup_expired_google_tokens"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."cleanup_expired_google_tokens"() TO "service_role";

GRANT ALL ON FUNCTION "public"."cleanup_expired_hubspot_oauth_states"() TO "anon";

GRANT ALL ON FUNCTION "public"."cleanup_expired_hubspot_oauth_states"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."cleanup_expired_hubspot_oauth_states"() TO "service_role";

GRANT ALL ON FUNCTION "public"."cleanup_expired_justcall_oauth_states"() TO "anon";

GRANT ALL ON FUNCTION "public"."cleanup_expired_justcall_oauth_states"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."cleanup_expired_justcall_oauth_states"() TO "service_role";

GRANT ALL ON FUNCTION "public"."cleanup_expired_skill_outputs"() TO "anon";

GRANT ALL ON FUNCTION "public"."cleanup_expired_skill_outputs"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."cleanup_expired_skill_outputs"() TO "service_role";

GRANT ALL ON FUNCTION "public"."cleanup_notification_rate_limits"() TO "anon";

GRANT ALL ON FUNCTION "public"."cleanup_notification_rate_limits"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."cleanup_notification_rate_limits"() TO "service_role";

GRANT ALL ON FUNCTION "public"."cleanup_old_api_monitor_snapshots"() TO "anon";

GRANT ALL ON FUNCTION "public"."cleanup_old_api_monitor_snapshots"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."cleanup_old_api_monitor_snapshots"() TO "service_role";

GRANT ALL ON FUNCTION "public"."cleanup_old_cron_logs"() TO "anon";

GRANT ALL ON FUNCTION "public"."cleanup_old_cron_logs"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."cleanup_old_cron_logs"() TO "service_role";

GRANT ALL ON FUNCTION "public"."cleanup_old_notifications"() TO "anon";

GRANT ALL ON FUNCTION "public"."cleanup_old_notifications"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."cleanup_old_notifications"() TO "service_role";

GRANT ALL ON FUNCTION "public"."cleanup_old_rate_limits"() TO "anon";

GRANT ALL ON FUNCTION "public"."cleanup_old_rate_limits"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."cleanup_old_rate_limits"() TO "service_role";

GRANT ALL ON FUNCTION "public"."cleanup_old_relationship_health_history"("days_to_keep_hourly" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."cleanup_old_relationship_health_history"("days_to_keep_hourly" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."cleanup_old_relationship_health_history"("days_to_keep_hourly" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."clear_audit_context"() TO "anon";

GRANT ALL ON FUNCTION "public"."clear_audit_context"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."clear_audit_context"() TO "service_role";

GRANT ALL ON FUNCTION "public"."complete_sentry_bridge_item"("item_id" "uuid", "dev_hub_task_id" "text", "mapping_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."complete_sentry_bridge_item"("item_id" "uuid", "dev_hub_task_id" "text", "mapping_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."complete_sentry_bridge_item"("item_id" "uuid", "dev_hub_task_id" "text", "mapping_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."complete_transcript_retry_job"("p_meeting_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."complete_transcript_retry_job"("p_meeting_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."complete_transcript_retry_job"("p_meeting_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."compute_improvement_deltas"("p_improvement_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."compute_improvement_deltas"("p_improvement_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."compute_improvement_deltas"("p_improvement_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."create_api_key"("key_name" "text", "user_uuid" "uuid", "permissions_json" "jsonb", "rate_limit_val" integer, "expires_days" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."create_api_key"("key_name" "text", "user_uuid" "uuid", "permissions_json" "jsonb", "rate_limit_val" integer, "expires_days" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_api_key"("key_name" "text", "user_uuid" "uuid", "permissions_json" "jsonb", "rate_limit_val" integer, "expires_days" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."create_clerk_user_mapping"("p_clerk_user_id" "text", "p_supabase_user_id" "uuid", "p_email" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."create_clerk_user_mapping"("p_clerk_user_id" "text", "p_supabase_user_id" "uuid", "p_email" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_clerk_user_mapping"("p_clerk_user_id" "text", "p_supabase_user_id" "uuid", "p_email" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."create_client_from_won_deal"() TO "anon";

GRANT ALL ON FUNCTION "public"."create_client_from_won_deal"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_client_from_won_deal"() TO "service_role";

GRANT ALL ON FUNCTION "public"."create_default_email_categorization_settings"() TO "anon";

GRANT ALL ON FUNCTION "public"."create_default_email_categorization_settings"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_default_email_categorization_settings"() TO "service_role";

GRANT ALL ON FUNCTION "public"."create_default_org_proposal_workflows"() TO "anon";

GRANT ALL ON FUNCTION "public"."create_default_org_proposal_workflows"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_default_org_proposal_workflows"() TO "service_role";

GRANT ALL ON FUNCTION "public"."create_default_recording_rules"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."create_default_recording_rules"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_default_recording_rules"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."create_hitl_approval"("p_org_id" "uuid", "p_user_id" "uuid", "p_resource_type" "text", "p_resource_id" "text", "p_resource_name" "text", "p_slack_team_id" "text", "p_slack_channel_id" "text", "p_slack_message_ts" "text", "p_original_content" "jsonb", "p_callback_type" "text", "p_callback_target" "text", "p_callback_metadata" "jsonb", "p_expires_hours" integer, "p_created_by" "uuid", "p_slack_thread_ts" "text", "p_metadata" "jsonb") TO "anon";

GRANT ALL ON FUNCTION "public"."create_hitl_approval"("p_org_id" "uuid", "p_user_id" "uuid", "p_resource_type" "text", "p_resource_id" "text", "p_resource_name" "text", "p_slack_team_id" "text", "p_slack_channel_id" "text", "p_slack_message_ts" "text", "p_original_content" "jsonb", "p_callback_type" "text", "p_callback_target" "text", "p_callback_metadata" "jsonb", "p_expires_hours" integer, "p_created_by" "uuid", "p_slack_thread_ts" "text", "p_metadata" "jsonb") TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_hitl_approval"("p_org_id" "uuid", "p_user_id" "uuid", "p_resource_type" "text", "p_resource_id" "text", "p_resource_name" "text", "p_slack_team_id" "text", "p_slack_channel_id" "text", "p_slack_message_ts" "text", "p_original_content" "jsonb", "p_callback_type" "text", "p_callback_target" "text", "p_callback_metadata" "jsonb", "p_expires_hours" integer, "p_created_by" "uuid", "p_slack_thread_ts" "text", "p_metadata" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."create_onboarding_progress_for_new_user"() TO "anon";

GRANT ALL ON FUNCTION "public"."create_onboarding_progress_for_new_user"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_onboarding_progress_for_new_user"() TO "service_role";

GRANT ALL ON FUNCTION "public"."create_org_admin_notification"("p_org_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_action_url" "text", "p_action_text" "text", "p_metadata" "jsonb") TO "anon";

GRANT ALL ON FUNCTION "public"."create_org_admin_notification"("p_org_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_action_url" "text", "p_action_text" "text", "p_metadata" "jsonb") TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_org_admin_notification"("p_org_id" "uuid", "p_type" "text", "p_title" "text", "p_message" "text", "p_action_url" "text", "p_action_text" "text", "p_metadata" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."create_org_for_new_user"("p_user_id" "uuid", "p_org_name" "text", "p_user_email" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."create_org_for_new_user"("p_user_id" "uuid", "p_org_name" "text", "p_user_email" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_org_for_new_user"("p_user_id" "uuid", "p_org_name" "text", "p_user_email" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."create_profile_for_clerk_user"("p_clerk_user_id" "text", "p_email" "text", "p_full_name" "text", "p_first_name" "text", "p_last_name" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."create_profile_for_clerk_user"("p_clerk_user_id" "text", "p_email" "text", "p_full_name" "text", "p_first_name" "text", "p_last_name" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_profile_for_clerk_user"("p_clerk_user_id" "text", "p_email" "text", "p_full_name" "text", "p_first_name" "text", "p_last_name" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."create_relationship_health_snapshot"() TO "anon";

GRANT ALL ON FUNCTION "public"."create_relationship_health_snapshot"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_relationship_health_snapshot"() TO "service_role";

GRANT ALL ON FUNCTION "public"."create_smart_tasks"() TO "anon";

GRANT ALL ON FUNCTION "public"."create_smart_tasks"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_smart_tasks"() TO "service_role";

GRANT ALL ON FUNCTION "public"."create_task_creation_notification"("p_user_id" "uuid", "p_meeting_id" "uuid", "p_meeting_title" "text", "p_task_count" integer, "p_task_ids" "uuid"[]) TO "anon";

GRANT ALL ON FUNCTION "public"."create_task_creation_notification"("p_user_id" "uuid", "p_meeting_id" "uuid", "p_meeting_title" "text", "p_task_count" integer, "p_task_ids" "uuid"[]) TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_task_creation_notification"("p_user_id" "uuid", "p_meeting_id" "uuid", "p_meeting_title" "text", "p_task_count" integer, "p_task_ids" "uuid"[]) TO "service_role";

GRANT ALL ON FUNCTION "public"."create_task_notification"("p_user_id" "uuid", "p_task_id" "uuid", "p_title" "text", "p_message" "text", "p_type" "text", "p_action_url" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."create_task_notification"("p_user_id" "uuid", "p_task_id" "uuid", "p_title" "text", "p_message" "text", "p_type" "text", "p_action_url" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_task_notification"("p_user_id" "uuid", "p_task_id" "uuid", "p_title" "text", "p_message" "text", "p_type" "text", "p_action_url" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."create_waitlist_email_invite"("p_entry_id" "uuid", "p_email" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."create_waitlist_email_invite"("p_entry_id" "uuid", "p_email" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."create_waitlist_email_invite"("p_entry_id" "uuid", "p_email" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."current_user_id"() TO "anon";

GRANT ALL ON FUNCTION "public"."current_user_id"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."current_user_id"() TO "service_role";

GRANT ALL ON FUNCTION "public"."current_user_orgs"() TO "anon";

GRANT ALL ON FUNCTION "public"."current_user_orgs"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."current_user_orgs"() TO "service_role";

GRANT ALL ON FUNCTION "public"."current_user_orgs"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."current_user_orgs"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."current_user_orgs"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."custom_auth_uid"() TO "anon";

GRANT ALL ON FUNCTION "public"."custom_auth_uid"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."custom_auth_uid"() TO "service_role";

GRANT ALL ON TABLE "public"."sentry_bridge_queue" TO "anon";

GRANT ALL ON TABLE "public"."sentry_bridge_queue" TO "authenticated";

GRANT ALL ON TABLE "public"."sentry_bridge_queue" TO "service_role";

GRANT ALL ON FUNCTION "public"."dequeue_sentry_bridge_item"("batch_size" integer, "lock_duration_seconds" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."dequeue_sentry_bridge_item"("batch_size" integer, "lock_duration_seconds" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."dequeue_sentry_bridge_item"("batch_size" integer, "lock_duration_seconds" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."dismiss_next_action_suggestion"("p_suggestion_id" "uuid", "p_feedback" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."dismiss_next_action_suggestion"("p_suggestion_id" "uuid", "p_feedback" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."dismiss_next_action_suggestion"("p_suggestion_id" "uuid", "p_feedback" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."enqueue_hubspot_contact_outbound"() TO "anon";

GRANT ALL ON FUNCTION "public"."enqueue_hubspot_contact_outbound"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."enqueue_hubspot_contact_outbound"() TO "service_role";

GRANT ALL ON FUNCTION "public"."enqueue_hubspot_deal_outbound"() TO "anon";

GRANT ALL ON FUNCTION "public"."enqueue_hubspot_deal_outbound"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."enqueue_hubspot_deal_outbound"() TO "service_role";

GRANT ALL ON FUNCTION "public"."enqueue_hubspot_meeting_note"() TO "anon";

GRANT ALL ON FUNCTION "public"."enqueue_hubspot_meeting_note"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."enqueue_hubspot_meeting_note"() TO "service_role";

GRANT ALL ON FUNCTION "public"."enqueue_hubspot_proposal_quote"() TO "anon";

GRANT ALL ON FUNCTION "public"."enqueue_hubspot_proposal_quote"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."enqueue_hubspot_proposal_quote"() TO "service_role";

GRANT ALL ON FUNCTION "public"."enqueue_hubspot_task_outbound"() TO "anon";

GRANT ALL ON FUNCTION "public"."enqueue_hubspot_task_outbound"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."enqueue_hubspot_task_outbound"() TO "service_role";

GRANT ALL ON FUNCTION "public"."enqueue_transcript_retry"("p_meeting_id" "uuid", "p_user_id" "uuid", "p_recording_id" "text", "p_initial_attempt_count" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."enqueue_transcript_retry"("p_meeting_id" "uuid", "p_user_id" "uuid", "p_recording_id" "text", "p_initial_attempt_count" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."enqueue_transcript_retry"("p_meeting_id" "uuid", "p_user_id" "uuid", "p_recording_id" "text", "p_initial_attempt_count" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."ensure_task_sync_status"() TO "anon";

GRANT ALL ON FUNCTION "public"."ensure_task_sync_status"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."ensure_task_sync_status"() TO "service_role";

GRANT ALL ON TABLE "public"."user_automation_rules" TO "anon";

GRANT ALL ON TABLE "public"."user_automation_rules" TO "authenticated";

GRANT ALL ON TABLE "public"."user_automation_rules" TO "service_role";

GRANT ALL ON FUNCTION "public"."execute_automation_action"("rule" "public"."user_automation_rules", "trigger_data" "jsonb", "user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."execute_automation_action"("rule" "public"."user_automation_rules", "trigger_data" "jsonb", "user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."execute_automation_action"("rule" "public"."user_automation_rules", "trigger_data" "jsonb", "user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."execute_unified_automation_rules"() TO "anon";

GRANT ALL ON FUNCTION "public"."execute_unified_automation_rules"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."execute_unified_automation_rules"() TO "service_role";

GRANT ALL ON FUNCTION "public"."expire_hitl_approvals"() TO "anon";

GRANT ALL ON FUNCTION "public"."expire_hitl_approvals"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."expire_hitl_approvals"() TO "service_role";

GRANT ALL ON FUNCTION "public"."expire_hitl_requests"() TO "anon";

GRANT ALL ON FUNCTION "public"."expire_hitl_requests"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."expire_hitl_requests"() TO "service_role";

GRANT ALL ON FUNCTION "public"."expire_old_recommendations"() TO "anon";

GRANT ALL ON FUNCTION "public"."expire_old_recommendations"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."expire_old_recommendations"() TO "service_role";

GRANT ALL ON FUNCTION "public"."expire_pending_hitl_requests"() TO "anon";

GRANT ALL ON FUNCTION "public"."expire_pending_hitl_requests"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."expire_pending_hitl_requests"() TO "service_role";

GRANT ALL ON FUNCTION "public"."fail_sentry_bridge_item"("item_id" "uuid", "error_msg" "text", "move_to_dlq" boolean) TO "anon";

GRANT ALL ON FUNCTION "public"."fail_sentry_bridge_item"("item_id" "uuid", "error_msg" "text", "move_to_dlq" boolean) TO "authenticated";

GRANT ALL ON FUNCTION "public"."fail_sentry_bridge_item"("item_id" "uuid", "error_msg" "text", "move_to_dlq" boolean) TO "service_role";

GRANT ALL ON FUNCTION "public"."find_orgs_by_email_domain"("p_domain" "text", "p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."find_orgs_by_email_domain"("p_domain" "text", "p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."find_orgs_by_email_domain"("p_domain" "text", "p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."find_similar_org_name"("normalized_name" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."find_similar_org_name"("normalized_name" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."find_similar_org_name"("normalized_name" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."generate_api_key"() TO "anon";

GRANT ALL ON FUNCTION "public"."generate_api_key"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."generate_api_key"() TO "service_role";

GRANT ALL ON FUNCTION "public"."generate_api_key"("prefix" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."generate_api_key"("prefix" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."generate_api_key"("prefix" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."generate_pipeline_recommendation_from_meeting"("p_meeting_id" "uuid", "p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."generate_pipeline_recommendation_from_meeting"("p_meeting_id" "uuid", "p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."generate_pipeline_recommendation_from_meeting"("p_meeting_id" "uuid", "p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."generate_referral_code"() TO "anon";

GRANT ALL ON FUNCTION "public"."generate_referral_code"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."generate_referral_code"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_activation_funnel"("p_start_date" "date", "p_end_date" "date") TO "anon";

GRANT ALL ON FUNCTION "public"."get_activation_funnel"("p_start_date" "date", "p_end_date" "date") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_activation_funnel"("p_start_date" "date", "p_end_date" "date") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_active_fathom_integration"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_active_fathom_integration"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_active_fathom_integration"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON TABLE "public"."interventions" TO "anon";

GRANT ALL ON TABLE "public"."interventions" TO "authenticated";

GRANT ALL ON TABLE "public"."interventions" TO "service_role";

GRANT ALL ON FUNCTION "public"."get_active_interventions"("user_id_param" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_active_interventions"("user_id_param" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_active_interventions"("user_id_param" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_activity_summary"("user_id" "uuid", "start_date" timestamp with time zone, "end_date" timestamp with time zone) TO "anon";

GRANT ALL ON FUNCTION "public"."get_activity_summary"("user_id" "uuid", "start_date" timestamp with time zone, "end_date" timestamp with time zone) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_activity_summary"("user_id" "uuid", "start_date" timestamp with time zone, "end_date" timestamp with time zone) TO "service_role";

GRANT ALL ON TABLE "public"."pipeline_automation_rules" TO "anon";

GRANT ALL ON TABLE "public"."pipeline_automation_rules" TO "authenticated";

GRANT ALL ON TABLE "public"."pipeline_automation_rules" TO "service_role";

GRANT ALL ON FUNCTION "public"."get_applicable_automation_rules"("p_org_id" "uuid", "p_trigger_type" "text", "p_call_type_id" "uuid", "p_confidence" numeric) TO "anon";

GRANT ALL ON FUNCTION "public"."get_applicable_automation_rules"("p_org_id" "uuid", "p_trigger_type" "text", "p_call_type_id" "uuid", "p_confidence" numeric) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_applicable_automation_rules"("p_org_id" "uuid", "p_trigger_type" "text", "p_call_type_id" "uuid", "p_confidence" numeric) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_at_risk_summary"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_at_risk_summary"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_at_risk_summary"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_at_risk_users"("p_risk_level" "text", "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_at_risk_users"("p_risk_level" "text", "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_at_risk_users"("p_risk_level" "text", "p_limit" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_audit_history"("p_table_name" "text", "p_record_id" "uuid", "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_audit_history"("p_table_name" "text", "p_record_id" "uuid", "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_audit_history"("p_table_name" "text", "p_record_id" "uuid", "p_limit" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_auth_provider"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_auth_provider"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_auth_provider"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_avg_health_change_per_day"("relationship_health_id_param" "uuid", "days" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_avg_health_change_per_day"("relationship_health_id_param" "uuid", "days" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_avg_health_change_per_day"("relationship_health_id_param" "uuid", "days" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_avg_response_time"("contact_id_param" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_avg_response_time"("contact_id_param" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_avg_response_time"("contact_id_param" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_calendar_events_in_range"("p_user_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_calendar_ids" "uuid"[]) TO "anon";

GRANT ALL ON FUNCTION "public"."get_calendar_events_in_range"("p_user_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_calendar_ids" "uuid"[]) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_calendar_events_in_range"("p_user_id" "uuid", "p_start_date" timestamp with time zone, "p_end_date" timestamp with time zone, "p_calendar_ids" "uuid"[]) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_changed_fields"("old_data" "jsonb", "new_data" "jsonb") TO "anon";

GRANT ALL ON FUNCTION "public"."get_changed_fields"("old_data" "jsonb", "new_data" "jsonb") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_changed_fields"("old_data" "jsonb", "new_data" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_clerk_org_id"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_clerk_org_id"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_clerk_org_id"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_clerk_user_id"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_clerk_user_id"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_clerk_user_id"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_coaching_reference_meetings"("p_user_id" "uuid", "p_good_meeting_ids" "uuid"[], "p_bad_meeting_ids" "uuid"[]) TO "anon";

GRANT ALL ON FUNCTION "public"."get_coaching_reference_meetings"("p_user_id" "uuid", "p_good_meeting_ids" "uuid"[], "p_bad_meeting_ids" "uuid"[]) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_coaching_reference_meetings"("p_user_id" "uuid", "p_good_meeting_ids" "uuid"[], "p_bad_meeting_ids" "uuid"[]) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_coaching_template_for_call_type"("p_org_id" "uuid", "p_call_type_id" "uuid", "p_meeting_type" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."get_coaching_template_for_call_type"("p_org_id" "uuid", "p_call_type_id" "uuid", "p_meeting_type" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_coaching_template_for_call_type"("p_org_id" "uuid", "p_call_type_id" "uuid", "p_meeting_type" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_cohort_analysis"("p_weeks" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_cohort_analysis"("p_weeks" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_cohort_analysis"("p_weeks" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_communication_frequency"("contact_id_param" "uuid", "days" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_communication_frequency"("contact_id_param" "uuid", "days" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_communication_frequency"("contact_id_param" "uuid", "days" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_competitor_analysis"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) TO "anon";

GRANT ALL ON FUNCTION "public"."get_competitor_analysis"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_competitor_analysis"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_contact_note_stats"("target_contact_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_contact_note_stats"("target_contact_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_contact_note_stats"("target_contact_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_content_triggers_for_user"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_content_triggers_for_user"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_content_triggers_for_user"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_content_with_topics"("p_content_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_content_with_topics"("p_content_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_content_with_topics"("p_content_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_cron_job_history"("p_job_name" "text", "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_cron_job_history"("p_job_name" "text", "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_cron_job_history"("p_job_name" "text", "p_limit" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_current_audit_context"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_current_audit_context"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_current_audit_context"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_current_cost_rate"("p_provider" "text", "p_model" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."get_current_cost_rate"("p_provider" "text", "p_model" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_current_cost_rate"("p_provider" "text", "p_model" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_days_since_last_contact"("contact_id_param" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_days_since_last_contact"("contact_id_param" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_days_since_last_contact"("contact_id_param" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_days_until_churn"("final_billing_date" "date") TO "anon";

GRANT ALL ON FUNCTION "public"."get_days_until_churn"("final_billing_date" "date") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_days_until_churn"("final_billing_date" "date") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_deal_active_risks"("p_deal_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_deal_active_risks"("p_deal_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_deal_active_risks"("p_deal_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_deal_note_stats"("target_deal_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_deal_note_stats"("target_deal_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_deal_note_stats"("target_deal_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_deal_truth_snapshot"("p_deal_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_deal_truth_snapshot"("p_deal_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_deal_truth_snapshot"("p_deal_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_deals_needing_attention"("p_org_id" "uuid", "p_user_id" "uuid", "p_min_clarity_score" integer, "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_deals_needing_attention"("p_org_id" "uuid", "p_user_id" "uuid", "p_min_clarity_score" integer, "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_deals_needing_attention"("p_org_id" "uuid", "p_user_id" "uuid", "p_min_clarity_score" integer, "p_limit" integer) TO "service_role";

GRANT ALL ON TABLE "public"."waitlist_email_templates" TO "anon";

GRANT ALL ON TABLE "public"."waitlist_email_templates" TO "authenticated";

GRANT ALL ON TABLE "public"."waitlist_email_templates" TO "service_role";

GRANT ALL ON FUNCTION "public"."get_default_waitlist_email_template"("p_template_type" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."get_default_waitlist_email_template"("p_template_type" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_default_waitlist_email_template"("p_template_type" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_email_open_rate"("contact_id_param" "uuid", "days" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_email_open_rate"("contact_id_param" "uuid", "days" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_email_open_rate"("contact_id_param" "uuid", "days" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_field_history"("p_table_name" "text", "p_record_id" "uuid", "p_field_name" "text", "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_field_history"("p_table_name" "text", "p_record_id" "uuid", "p_field_name" "text", "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_field_history"("p_table_name" "text", "p_record_id" "uuid", "p_field_name" "text", "p_limit" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_free_tier_plan"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_free_tier_plan"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_free_tier_plan"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_global_topics_filtered"("p_user_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_company_ids" "uuid"[], "p_contact_ids" "uuid"[], "p_search_query" "text", "p_sort_by" "text", "p_limit" integer, "p_offset" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_global_topics_filtered"("p_user_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_company_ids" "uuid"[], "p_contact_ids" "uuid"[], "p_search_query" "text", "p_sort_by" "text", "p_limit" integer, "p_offset" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_global_topics_filtered"("p_user_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_company_ids" "uuid"[], "p_contact_ids" "uuid"[], "p_search_query" "text", "p_sort_by" "text", "p_limit" integer, "p_offset" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_global_topics_stats"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_global_topics_stats"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_global_topics_stats"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_google_access_token"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_google_access_token"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_google_access_token"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_health_score_trend"("relationship_health_id_param" "uuid", "days" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_health_score_trend"("relationship_health_id_param" "uuid", "days" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_health_score_trend"("relationship_health_id_param" "uuid", "days" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_high_risk_deals"("p_org_id" "uuid", "p_min_risk_level" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."get_high_risk_deals"("p_org_id" "uuid", "p_min_risk_level" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_high_risk_deals"("p_org_id" "uuid", "p_min_risk_level" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_highest_ghost_signal_severity"("relationship_health_id_param" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_highest_ghost_signal_severity"("relationship_health_id_param" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_highest_ghost_signal_severity"("relationship_health_id_param" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_intervention_success_rate"("user_id_param" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_intervention_success_rate"("user_id_param" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_intervention_success_rate"("user_id_param" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_last_communication_date"("contact_id_param" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_last_communication_date"("contact_id_param" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_last_communication_date"("contact_id_param" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_last_response_date"("contact_id_param" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_last_response_date"("contact_id_param" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_last_response_date"("contact_id_param" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_latest_content"("p_meeting_id" "uuid", "p_content_type" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."get_latest_content"("p_meeting_id" "uuid", "p_content_type" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_latest_content"("p_meeting_id" "uuid", "p_content_type" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_meeting_classification_counts"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_owner_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_meeting_classification_counts"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_owner_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_meeting_classification_counts"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_owner_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_meeting_index_status"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_meeting_index_status"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_meeting_index_status"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_meeting_index_status_v2"("p_requesting_user_id" "uuid", "p_target_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_meeting_index_status_v2"("p_requesting_user_id" "uuid", "p_target_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_meeting_index_status_v2"("p_requesting_user_id" "uuid", "p_target_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_meeting_retry_status"("p_meeting_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_meeting_retry_status"("p_meeting_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_meeting_retry_status"("p_meeting_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_meeting_structured_summary"("p_meeting_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_meeting_structured_summary"("p_meeting_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_meeting_structured_summary"("p_meeting_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_meetings_by_classification"("p_org_id" "uuid", "p_filter_type" "text", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_owner_user_id" "uuid", "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_meetings_by_classification"("p_org_id" "uuid", "p_filter_type" "text", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_owner_user_id" "uuid", "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_meetings_by_classification"("p_org_id" "uuid", "p_filter_type" "text", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_owner_user_id" "uuid", "p_limit" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_meetings_for_drill_down"("p_org_id" "uuid", "p_metric_type" "text", "p_period_days" integer, "p_user_id" "uuid", "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_meetings_for_drill_down"("p_org_id" "uuid", "p_metric_type" "text", "p_period_days" integer, "p_user_id" "uuid", "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_meetings_for_drill_down"("p_org_id" "uuid", "p_metric_type" "text", "p_period_days" integer, "p_user_id" "uuid", "p_limit" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_meetings_with_competitors"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) TO "anon";

GRANT ALL ON FUNCTION "public"."get_meetings_with_competitors"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_meetings_with_competitors"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_meetings_with_forward_movement"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) TO "anon";

GRANT ALL ON FUNCTION "public"."get_meetings_with_forward_movement"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_meetings_with_forward_movement"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_mrr_by_date_range"("p_start_date" "date", "p_end_date" "date", "p_currency" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."get_mrr_by_date_range"("p_start_date" "date", "p_end_date" "date", "p_currency" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_mrr_by_date_range"("p_start_date" "date", "p_end_date" "date", "p_currency" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_my_google_integration"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_my_google_integration"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_my_google_integration"() TO "service_role";

GRANT ALL ON TABLE "public"."proposal_jobs" TO "anon";

GRANT ALL ON TABLE "public"."proposal_jobs" TO "authenticated";

GRANT ALL ON TABLE "public"."proposal_jobs" TO "service_role";

GRANT ALL ON FUNCTION "public"."get_next_proposal_job"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_next_proposal_job"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_next_proposal_job"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_notification_candidates_for_testing"("p_org_id" "uuid", "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_notification_candidates_for_testing"("p_org_id" "uuid", "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_notification_candidates_for_testing"("p_org_id" "uuid", "p_limit" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_notification_health_summary"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_notification_health_summary"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_notification_health_summary"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_or_create_sync_status"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_or_create_sync_status"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_or_create_sync_status"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_org_email_label_mode"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_org_email_label_mode"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_org_email_label_mode"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_org_file_search_store"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_org_file_search_store"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_org_file_search_store"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_org_internal_domain"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_org_internal_domain"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_org_internal_domain"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_org_limits"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_org_limits"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_org_limits"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_org_meeting_index_status"("p_org_id" "uuid", "p_target_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_org_meeting_index_status"("p_org_id" "uuid", "p_target_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_org_meeting_index_status"("p_org_id" "uuid", "p_target_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_org_member_counts"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_org_member_counts"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_org_member_counts"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_org_plan_features"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_org_plan_features"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_org_plan_features"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_org_role"("p_user_id" "uuid", "p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_org_role"("p_user_id" "uuid", "p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_org_role"("p_user_id" "uuid", "p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_org_subscription_details"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_org_subscription_details"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_org_subscription_details"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_org_team_members"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_org_team_members"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_org_team_members"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_organization_context"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_organization_context"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_organization_context"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_organization_context_object"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_organization_context_object"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_organization_context_object"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_organization_skills_for_agent"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_organization_skills_for_agent"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_organization_skills_for_agent"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_organization_skills_summary"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_organization_skills_summary"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_organization_skills_summary"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_pending_aggregation_count"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_pending_aggregation_count"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_pending_aggregation_count"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_pending_ai_analysis"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_pending_ai_analysis"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_pending_ai_analysis"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_pending_hitl_requests"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_pending_hitl_requests"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_pending_hitl_requests"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_pending_notifications"("p_limit" integer, "p_channel" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."get_pending_notifications"("p_limit" integer, "p_channel" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_pending_notifications"("p_limit" integer, "p_channel" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_pending_suggestions_count"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_pending_suggestions_count"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_pending_suggestions_count"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_pending_transcript_retry_jobs"("p_batch_size" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_pending_transcript_retry_jobs"("p_batch_size" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_pending_transcript_retry_jobs"("p_batch_size" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_platform_skill"("p_skill_key" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."get_platform_skill"("p_skill_key" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_platform_skill"("p_skill_key" "text") TO "service_role";

GRANT ALL ON TABLE "public"."profiles" TO "anon";

GRANT ALL ON TABLE "public"."profiles" TO "authenticated";

GRANT ALL ON TABLE "public"."profiles" TO "service_role";

GRANT ALL ON FUNCTION "public"."get_profile_for_current_user"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_profile_for_current_user"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_profile_for_current_user"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_prompt_template"("p_category" "text", "p_user_id" "uuid", "p_organization_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_prompt_template"("p_category" "text", "p_user_id" "uuid", "p_organization_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_prompt_template"("p_category" "text", "p_user_id" "uuid", "p_organization_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_public_subscription_plans"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_public_subscription_plans"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_public_subscription_plans"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_reengagement_candidates"("p_org_id" "uuid", "p_segment" "text", "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_reengagement_candidates"("p_org_id" "uuid", "p_segment" "text", "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_reengagement_candidates"("p_org_id" "uuid", "p_segment" "text", "p_limit" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_reengagement_stats"("p_org_id" "uuid", "p_days" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_reengagement_stats"("p_org_id" "uuid", "p_days" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_reengagement_stats"("p_org_id" "uuid", "p_days" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_rep_scorecard_stats"("p_org_id" "uuid", "p_user_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) TO "anon";

GRANT ALL ON FUNCTION "public"."get_rep_scorecard_stats"("p_org_id" "uuid", "p_user_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_rep_scorecard_stats"("p_org_id" "uuid", "p_user_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_response_rate"("contact_id_param" "uuid", "days" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_response_rate"("contact_id_param" "uuid", "days" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_response_rate"("contact_id_param" "uuid", "days" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_scorecard_template_for_type"("p_org_id" "uuid", "p_meeting_type" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."get_scorecard_template_for_type"("p_org_id" "uuid", "p_meeting_type" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_scorecard_template_for_type"("p_org_id" "uuid", "p_meeting_type" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_sentiment_trend"("contact_id_param" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_sentiment_trend"("contact_id_param" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_sentiment_trend"("contact_id_param" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_sequence_executions"("p_sequence_key" "text", "p_organization_id" "uuid", "p_is_simulation" boolean, "p_status" "text", "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_sequence_executions"("p_sequence_key" "text", "p_organization_id" "uuid", "p_is_simulation" boolean, "p_status" "text", "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_sequence_executions"("p_sequence_key" "text", "p_organization_id" "uuid", "p_is_simulation" boolean, "p_status" "text", "p_limit" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_share_stats"("entry_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_share_stats"("entry_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_share_stats"("entry_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_skills_needing_compilation"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_skills_needing_compilation"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_skills_needing_compilation"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_skills_needing_recompile"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_skills_needing_recompile"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_skills_needing_recompile"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_slack_org_settings_public"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_slack_org_settings_public"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_slack_org_settings_public"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_status_change_count"("relationship_health_id_param" "uuid", "days" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_status_change_count"("relationship_health_id_param" "uuid", "days" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_status_change_count"("relationship_health_id_param" "uuid", "days" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_stuck_waitlist_onboarding_users"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_stuck_waitlist_onboarding_users"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_stuck_waitlist_onboarding_users"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_subscription_retention_cohorts"("p_cohort_start" "date", "p_cohort_end" "date", "p_retention_months" integer[]) TO "anon";

GRANT ALL ON FUNCTION "public"."get_subscription_retention_cohorts"("p_cohort_start" "date", "p_cohort_end" "date", "p_retention_months" integer[]) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_subscription_retention_cohorts"("p_cohort_start" "date", "p_cohort_end" "date", "p_retention_months" integer[]) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_supabase_id_for_clerk_user"("p_clerk_user_id" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."get_supabase_id_for_clerk_user"("p_clerk_user_id" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_supabase_id_for_clerk_user"("p_clerk_user_id" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_system_config"("p_key" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."get_system_config"("p_key" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_system_config"("p_key" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_task_depth"("task_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_task_depth"("task_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_task_depth"("task_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_task_target_lists"("p_user_id" "uuid", "p_priority" "text", "p_category" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."get_task_target_lists"("p_user_id" "uuid", "p_priority" "text", "p_category" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_task_target_lists"("p_user_id" "uuid", "p_priority" "text", "p_category" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_team_aggregates_with_comparison"("p_org_id" "uuid", "p_period_days" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_team_aggregates_with_comparison"("p_org_id" "uuid", "p_period_days" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_team_aggregates_with_comparison"("p_org_id" "uuid", "p_period_days" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_team_comparison_matrix"("p_org_id" "uuid", "p_period_days" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_team_comparison_matrix"("p_org_id" "uuid", "p_period_days" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_team_comparison_matrix"("p_org_id" "uuid", "p_period_days" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_team_members_with_connected_accounts"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_team_members_with_connected_accounts"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_team_members_with_connected_accounts"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_team_members_with_meetings"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_team_members_with_meetings"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_team_members_with_meetings"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_team_quality_signals"("p_org_id" "uuid", "p_period_days" integer, "p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_team_quality_signals"("p_org_id" "uuid", "p_period_days" integer, "p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_team_quality_signals"("p_org_id" "uuid", "p_period_days" integer, "p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_team_scorecard_leaderboard"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_team_scorecard_leaderboard"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_team_scorecard_leaderboard"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_limit" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_team_time_series_metrics"("p_org_id" "uuid", "p_period_days" integer, "p_granularity" "text", "p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_team_time_series_metrics"("p_org_id" "uuid", "p_period_days" integer, "p_granularity" "text", "p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_team_time_series_metrics"("p_org_id" "uuid", "p_period_days" integer, "p_granularity" "text", "p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_top_objections"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_top_objections"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_top_objections"("p_org_id" "uuid", "p_date_from" timestamp with time zone, "p_date_to" timestamp with time zone, "p_limit" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_topic_sources_with_details"("p_global_topic_id" "uuid", "p_limit" integer, "p_offset" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_topic_sources_with_details"("p_global_topic_id" "uuid", "p_limit" integer, "p_offset" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_topic_sources_with_details"("p_global_topic_id" "uuid", "p_limit" integer, "p_offset" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_trial_status"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_trial_status"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_trial_status"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_unanswered_outbound_count"("contact_id_param" "uuid", "days" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_unanswered_outbound_count"("contact_id_param" "uuid", "days" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_unanswered_outbound_count"("contact_id_param" "uuid", "days" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_unprocessed_billing_events"("p_provider" "text", "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_unprocessed_billing_events"("p_provider" "text", "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_unprocessed_billing_events"("p_provider" "text", "p_limit" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_unread_notification_count"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_unread_notification_count"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_unread_notification_count"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_unread_sentiment_alert_count"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_unread_sentiment_alert_count"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_unread_sentiment_alert_count"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_unresolved_ghost_signals_count"("relationship_health_id_param" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_unresolved_ghost_signals_count"("relationship_health_id_param" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_unresolved_ghost_signals_count"("relationship_health_id_param" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_active_org"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_active_org"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_active_org"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_api_keys"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_api_keys"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_api_keys"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_feature_model_config"("p_user_id" "uuid", "p_feature_key" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_feature_model_config"("p_user_id" "uuid", "p_feature_key" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_feature_model_config"("p_user_id" "uuid", "p_feature_key" "text") TO "service_role";

GRANT ALL ON TABLE "public"."google_integrations" TO "anon";

GRANT ALL ON TABLE "public"."google_integrations" TO "authenticated";

GRANT ALL ON TABLE "public"."google_integrations" TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_google_integration"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_google_integration"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_google_integration"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_id_from_activity"("p_activity_id" "uuid", "p_activity_type" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_id_from_activity"("p_activity_id" "uuid", "p_activity_type" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_id_from_activity"("p_activity_id" "uuid", "p_activity_type" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_id_from_email"("email_input" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_id_from_email"("email_input" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_id_from_email"("email_input" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_notification_counts"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_notification_counts"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_notification_counts"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_org_id"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_org_id"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_org_id"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_org_id"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_org_id"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_org_id"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_org_ids"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_org_ids"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_org_ids"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_org_role"("p_user_id" "uuid", "p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_org_role"("p_user_id" "uuid", "p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_org_role"("p_user_id" "uuid", "p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_orgs_with_roles"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_orgs_with_roles"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_orgs_with_roles"() TO "service_role";

GRANT ALL ON TABLE "public"."hitl_pending_approvals" TO "anon";

GRANT ALL ON TABLE "public"."hitl_pending_approvals" TO "authenticated";

GRANT ALL ON TABLE "public"."hitl_pending_approvals" TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_pending_approvals"("p_user_id" "uuid", "p_org_id" "uuid", "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_pending_approvals"("p_user_id" "uuid", "p_org_id" "uuid", "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_pending_approvals"("p_user_id" "uuid", "p_org_id" "uuid", "p_limit" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_primary_org"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_primary_org"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_primary_org"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_timezone_from_calendar"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_timezone_from_calendar"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_timezone_from_calendar"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."get_user_uuid_from_clerk"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_user_uuid_from_clerk"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_user_uuid_from_clerk"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_users_due_for_feedback"("p_org_id" "uuid", "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."get_users_due_for_feedback"("p_org_id" "uuid", "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_users_due_for_feedback"("p_org_id" "uuid", "p_limit" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."get_users_with_targets"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_users_with_targets"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_users_with_targets"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_waitlist_analytics"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_waitlist_analytics"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_waitlist_analytics"() TO "service_role";

GRANT ALL ON FUNCTION "public"."get_waitlist_onboarding_analytics"() TO "anon";

GRANT ALL ON FUNCTION "public"."get_waitlist_onboarding_analytics"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."get_waitlist_onboarding_analytics"() TO "service_role";

GRANT ALL ON FUNCTION "public"."handle_deal_insert"() TO "anon";

GRANT ALL ON FUNCTION "public"."handle_deal_insert"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."handle_deal_insert"() TO "service_role";

GRANT ALL ON FUNCTION "public"."handle_deal_stage_change"() TO "anon";

GRANT ALL ON FUNCTION "public"."handle_deal_stage_change"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."handle_deal_stage_change"() TO "service_role";

GRANT ALL ON FUNCTION "public"."handle_hitl_response"("p_request_id" "uuid", "p_response_value" "text", "p_response_context" "jsonb") TO "anon";

GRANT ALL ON FUNCTION "public"."handle_hitl_response"("p_request_id" "uuid", "p_response_value" "text", "p_response_context" "jsonb") TO "authenticated";

GRANT ALL ON FUNCTION "public"."handle_hitl_response"("p_request_id" "uuid", "p_response_value" "text", "p_response_context" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "anon";

GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "service_role";

GRANT ALL ON FUNCTION "public"."has_notification_flood"() TO "anon";

GRANT ALL ON FUNCTION "public"."has_notification_flood"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."has_notification_flood"() TO "service_role";

GRANT ALL ON FUNCTION "public"."hash_api_key"("key_text" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."hash_api_key"("key_text" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."hash_api_key"("key_text" "text") TO "service_role";

GRANT ALL ON TABLE "public"."hubspot_sync_queue" TO "anon";

GRANT ALL ON TABLE "public"."hubspot_sync_queue" TO "authenticated";

GRANT ALL ON TABLE "public"."hubspot_sync_queue" TO "service_role";

REVOKE ALL ON FUNCTION "public"."hubspot_dequeue_jobs"("p_limit" integer, "p_org_id" "uuid") FROM PUBLIC;

GRANT ALL ON FUNCTION "public"."hubspot_dequeue_jobs"("p_limit" integer, "p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."hubspot_dequeue_jobs"("p_limit" integer, "p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."hubspot_dequeue_jobs"("p_limit" integer, "p_org_id" "uuid") TO "service_role";

REVOKE ALL ON FUNCTION "public"."hubspot_release_worker_lock"() FROM PUBLIC;

GRANT ALL ON FUNCTION "public"."hubspot_release_worker_lock"() TO "anon";

GRANT ALL ON FUNCTION "public"."hubspot_release_worker_lock"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."hubspot_release_worker_lock"() TO "service_role";

REVOKE ALL ON FUNCTION "public"."hubspot_try_acquire_worker_lock"() FROM PUBLIC;

GRANT ALL ON FUNCTION "public"."hubspot_try_acquire_worker_lock"() TO "anon";

GRANT ALL ON FUNCTION "public"."hubspot_try_acquire_worker_lock"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."hubspot_try_acquire_worker_lock"() TO "service_role";

GRANT ALL ON FUNCTION "public"."increment_invite_code_usage"() TO "anon";

GRANT ALL ON FUNCTION "public"."increment_invite_code_usage"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."increment_invite_code_usage"() TO "service_role";

GRANT ALL ON FUNCTION "public"."increment_invite_code_usage"("code_value" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."increment_invite_code_usage"("code_value" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."increment_invite_code_usage"("code_value" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."increment_notification_count"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."increment_notification_count"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."increment_notification_count"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."increment_proposal_views"("p_share_token" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."increment_proposal_views"("p_share_token" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."increment_proposal_views"("p_share_token" "uuid") TO "service_role";

GRANT ALL ON TABLE "public"."recording_usage" TO "anon";

GRANT ALL ON TABLE "public"."recording_usage" TO "authenticated";

GRANT ALL ON TABLE "public"."recording_usage" TO "service_role";

GRANT ALL ON FUNCTION "public"."increment_recording_usage"("p_org_id" "uuid", "p_period" "date", "p_duration_seconds" integer, "p_storage_bytes" bigint) TO "anon";

GRANT ALL ON FUNCTION "public"."increment_recording_usage"("p_org_id" "uuid", "p_period" "date", "p_duration_seconds" integer, "p_storage_bytes" bigint) TO "authenticated";

GRANT ALL ON FUNCTION "public"."increment_recording_usage"("p_org_id" "uuid", "p_period" "date", "p_duration_seconds" integer, "p_storage_bytes" bigint) TO "service_role";

GRANT ALL ON FUNCTION "public"."increment_referral_count"() TO "anon";

GRANT ALL ON FUNCTION "public"."increment_referral_count"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."increment_referral_count"() TO "service_role";

GRANT ALL ON FUNCTION "public"."increment_sentry_bridge_metrics"("p_org_id" "uuid", "p_date" "date", "p_tickets_created" integer, "p_tickets_updated" integer, "p_errors" integer, "p_processing_time_ms" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."increment_sentry_bridge_metrics"("p_org_id" "uuid", "p_date" "date", "p_tickets_created" integer, "p_tickets_updated" integer, "p_errors" integer, "p_processing_time_ms" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."increment_sentry_bridge_metrics"("p_org_id" "uuid", "p_date" "date", "p_tickets_created" integer, "p_tickets_updated" integer, "p_errors" integer, "p_processing_time_ms" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."increment_source_count"("topic_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."increment_source_count"("topic_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."increment_source_count"("topic_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."increment_voice_recording_views"("p_share_token" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."increment_voice_recording_views"("p_share_token" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."increment_voice_recording_views"("p_share_token" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."initialize_deal_close_plan"("p_deal_id" "uuid", "p_org_id" "uuid", "p_owner_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."initialize_deal_close_plan"("p_deal_id" "uuid", "p_org_id" "uuid", "p_owner_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."initialize_deal_close_plan"("p_deal_id" "uuid", "p_org_id" "uuid", "p_owner_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."initialize_user_engagement_metrics"("p_user_id" "uuid", "p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."initialize_user_engagement_metrics"("p_user_id" "uuid", "p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."initialize_user_engagement_metrics"("p_user_id" "uuid", "p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."is_admin"() TO "anon";

GRANT ALL ON FUNCTION "public"."is_admin"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."is_admin"() TO "service_role";

GRANT ALL ON FUNCTION "public"."is_admin_optimized"() TO "anon";

GRANT ALL ON FUNCTION "public"."is_admin_optimized"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."is_admin_optimized"() TO "service_role";

GRANT ALL ON FUNCTION "public"."is_clerk_admin"() TO "anon";

GRANT ALL ON FUNCTION "public"."is_clerk_admin"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."is_clerk_admin"() TO "service_role";

GRANT ALL ON FUNCTION "public"."is_clerk_authenticated"() TO "anon";

GRANT ALL ON FUNCTION "public"."is_clerk_authenticated"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."is_clerk_authenticated"() TO "service_role";

GRANT ALL ON FUNCTION "public"."is_internal_assignee"("email_input" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."is_internal_assignee"("email_input" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."is_internal_assignee"("email_input" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."is_org_member"("p_user_id" "uuid", "p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."is_org_member"("p_user_id" "uuid", "p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."is_org_member"("p_user_id" "uuid", "p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."is_org_owner"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."is_org_owner"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."is_org_owner"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."is_platform_admin"() TO "anon";

GRANT ALL ON FUNCTION "public"."is_platform_admin"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."is_platform_admin"() TO "service_role";

GRANT ALL ON FUNCTION "public"."is_platform_admin_for_testing"() TO "anon";

GRANT ALL ON FUNCTION "public"."is_platform_admin_for_testing"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."is_platform_admin_for_testing"() TO "service_role";

GRANT ALL ON FUNCTION "public"."is_service_role"() TO "anon";

GRANT ALL ON FUNCTION "public"."is_service_role"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."is_service_role"() TO "service_role";

GRANT ALL ON FUNCTION "public"."is_super_admin"() TO "anon";

GRANT ALL ON FUNCTION "public"."is_super_admin"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."is_super_admin"() TO "service_role";

GRANT ALL ON FUNCTION "public"."is_super_admin"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."is_super_admin"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."is_super_admin"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."is_task_from_meeting"("p_task_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."is_task_from_meeting"("p_task_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."is_task_from_meeting"("p_task_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."is_user_admin"("user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."is_user_admin"("user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."is_user_admin"("user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."link_profile_to_clerk_user"("p_profile_id" "uuid", "p_clerk_user_id" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."link_profile_to_clerk_user"("p_profile_id" "uuid", "p_clerk_user_id" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."link_profile_to_clerk_user"("p_profile_id" "uuid", "p_clerk_user_id" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."link_user_to_waitlist"() TO "anon";

GRANT ALL ON FUNCTION "public"."link_user_to_waitlist"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."link_user_to_waitlist"() TO "service_role";

GRANT ALL ON FUNCTION "public"."log_api_request"("p_api_key_id" "uuid", "p_user_id" "uuid", "p_method" "text", "p_endpoint" "text", "p_headers" "jsonb", "p_body" "jsonb", "p_status_code" integer, "p_response_body" "jsonb") TO "anon";

GRANT ALL ON FUNCTION "public"."log_api_request"("p_api_key_id" "uuid", "p_user_id" "uuid", "p_method" "text", "p_endpoint" "text", "p_headers" "jsonb", "p_body" "jsonb", "p_status_code" integer, "p_response_body" "jsonb") TO "authenticated";

GRANT ALL ON FUNCTION "public"."log_api_request"("p_api_key_id" "uuid", "p_user_id" "uuid", "p_method" "text", "p_endpoint" "text", "p_headers" "jsonb", "p_body" "jsonb", "p_status_code" integer, "p_response_body" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."log_integration_sync"("p_org_id" "uuid", "p_user_id" "uuid", "p_integration_name" "text", "p_operation" "text", "p_direction" "text", "p_entity_type" "text", "p_entity_id" "text", "p_entity_name" "text", "p_status" "text", "p_error_message" "text", "p_metadata" "jsonb", "p_batch_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."log_integration_sync"("p_org_id" "uuid", "p_user_id" "uuid", "p_integration_name" "text", "p_operation" "text", "p_direction" "text", "p_entity_type" "text", "p_entity_id" "text", "p_entity_name" "text", "p_status" "text", "p_error_message" "text", "p_metadata" "jsonb", "p_batch_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."log_integration_sync"("p_org_id" "uuid", "p_user_id" "uuid", "p_integration_name" "text", "p_operation" "text", "p_direction" "text", "p_entity_type" "text", "p_entity_id" "text", "p_entity_name" "text", "p_status" "text", "p_error_message" "text", "p_metadata" "jsonb", "p_batch_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."log_user_activity_event"("p_user_id" "uuid", "p_org_id" "uuid", "p_event_type" "text", "p_event_source" "text", "p_event_category" "text", "p_entity_type" "text", "p_entity_id" "uuid", "p_action_detail" "text", "p_session_id" "uuid", "p_metadata" "jsonb") TO "anon";

GRANT ALL ON FUNCTION "public"."log_user_activity_event"("p_user_id" "uuid", "p_org_id" "uuid", "p_event_type" "text", "p_event_source" "text", "p_event_category" "text", "p_entity_type" "text", "p_entity_id" "uuid", "p_action_detail" "text", "p_session_id" "uuid", "p_metadata" "jsonb") TO "authenticated";

GRANT ALL ON FUNCTION "public"."log_user_activity_event"("p_user_id" "uuid", "p_org_id" "uuid", "p_event_type" "text", "p_event_source" "text", "p_event_category" "text", "p_entity_type" "text", "p_entity_id" "uuid", "p_action_detail" "text", "p_session_id" "uuid", "p_metadata" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."log_waitlist_admin_action"() TO "anon";

GRANT ALL ON FUNCTION "public"."log_waitlist_admin_action"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."log_waitlist_admin_action"() TO "service_role";

GRANT ALL ON FUNCTION "public"."map_deal_activity_to_main_activity"("deal_activity_type" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."map_deal_activity_to_main_activity"("deal_activity_type" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."map_deal_activity_to_main_activity"("deal_activity_type" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."mark_all_notifications_read"() TO "anon";

GRANT ALL ON FUNCTION "public"."mark_all_notifications_read"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."mark_all_notifications_read"() TO "service_role";

GRANT ALL ON FUNCTION "public"."mark_billing_event_processed"("p_id" "uuid", "p_error" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."mark_billing_event_processed"("p_id" "uuid", "p_error" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."mark_billing_event_processed"("p_id" "uuid", "p_error" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."mark_notification_failed"("p_queue_id" "uuid", "p_error_message" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."mark_notification_failed"("p_queue_id" "uuid", "p_error_message" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."mark_notification_failed"("p_queue_id" "uuid", "p_error_message" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."mark_notification_read"("p_notification_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."mark_notification_read"("p_notification_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."mark_notification_read"("p_notification_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."mark_notification_sent"("p_queue_id" "uuid", "p_interaction_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."mark_notification_sent"("p_queue_id" "uuid", "p_interaction_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."mark_notification_sent"("p_queue_id" "uuid", "p_interaction_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."mark_onboarding_complete"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."mark_onboarding_complete"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."mark_onboarding_complete"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."mark_sentiment_alert_read"("p_alert_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."mark_sentiment_alert_read"("p_alert_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."mark_sentiment_alert_read"("p_alert_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."mark_skill_compiled"("p_org_skill_id" "uuid", "p_compiled_frontmatter" "jsonb", "p_compiled_content" "text", "p_platform_skill_id" "uuid", "p_platform_version" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."mark_skill_compiled"("p_org_skill_id" "uuid", "p_compiled_frontmatter" "jsonb", "p_compiled_content" "text", "p_platform_skill_id" "uuid", "p_platform_version" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."mark_skill_compiled"("p_org_skill_id" "uuid", "p_compiled_frontmatter" "jsonb", "p_compiled_content" "text", "p_platform_skill_id" "uuid", "p_platform_version" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."mark_waitlist_onboarding_step"("p_user_id" "uuid", "p_step" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."mark_waitlist_onboarding_step"("p_user_id" "uuid", "p_step" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."mark_waitlist_onboarding_step"("p_user_id" "uuid", "p_step" "text") TO "service_role";

GRANT ALL ON TABLE "public"."meetings" TO "anon";

GRANT ALL ON TABLE "public"."meetings" TO "authenticated";

GRANT ALL ON TABLE "public"."meetings" TO "service_role";

GRANT ALL ON FUNCTION "public"."meeting_needs_transcript_retry"("meeting_row" "public"."meetings") TO "anon";

GRANT ALL ON FUNCTION "public"."meeting_needs_transcript_retry"("meeting_row" "public"."meetings") TO "authenticated";

GRANT ALL ON FUNCTION "public"."meeting_needs_transcript_retry"("meeting_row" "public"."meetings") TO "service_role";

GRANT ALL ON FUNCTION "public"."merge_global_topics"("p_source_topic_id" "uuid", "p_target_topic_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."merge_global_topics"("p_source_topic_id" "uuid", "p_target_topic_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."merge_global_topics"("p_source_topic_id" "uuid", "p_target_topic_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."migrate_deal_entities"("deal_record" "record") TO "anon";

GRANT ALL ON FUNCTION "public"."migrate_deal_entities"("deal_record" "record") TO "authenticated";

GRANT ALL ON FUNCTION "public"."migrate_deal_entities"("deal_record" "record") TO "service_role";

GRANT ALL ON FUNCTION "public"."migrate_existing_list_configs"() TO "anon";

GRANT ALL ON FUNCTION "public"."migrate_existing_list_configs"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."migrate_existing_list_configs"() TO "service_role";

GRANT ALL ON FUNCTION "public"."normalize_org_name"("raw_name" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."normalize_org_name"("raw_name" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."normalize_org_name"("raw_name" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."notify_api_monitor_improvements"() TO "anon";

GRANT ALL ON FUNCTION "public"."notify_api_monitor_improvements"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."notify_api_monitor_improvements"() TO "service_role";

GRANT ALL ON FUNCTION "public"."notify_overdue_tasks"() TO "anon";

GRANT ALL ON FUNCTION "public"."notify_overdue_tasks"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."notify_overdue_tasks"() TO "service_role";

GRANT ALL ON FUNCTION "public"."notify_roadmap_suggestion"() TO "anon";

GRANT ALL ON FUNCTION "public"."notify_roadmap_suggestion"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."notify_roadmap_suggestion"() TO "service_role";

GRANT ALL ON FUNCTION "public"."notify_skill_update"() TO "anon";

GRANT ALL ON FUNCTION "public"."notify_skill_update"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."notify_skill_update"() TO "service_role";

GRANT ALL ON FUNCTION "public"."notify_task_from_meeting"() TO "anon";

GRANT ALL ON FUNCTION "public"."notify_task_from_meeting"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."notify_task_from_meeting"() TO "service_role";

GRANT ALL ON FUNCTION "public"."notify_task_reassignment"() TO "anon";

GRANT ALL ON FUNCTION "public"."notify_task_reassignment"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."notify_task_reassignment"() TO "service_role";

GRANT ALL ON FUNCTION "public"."notify_upcoming_task_deadlines"() TO "anon";

GRANT ALL ON FUNCTION "public"."notify_upcoming_task_deadlines"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."notify_upcoming_task_deadlines"() TO "service_role";

GRANT ALL ON FUNCTION "public"."notify_waitlist_signup"() TO "anon";

GRANT ALL ON FUNCTION "public"."notify_waitlist_signup"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."notify_waitlist_signup"() TO "service_role";

GRANT ALL ON FUNCTION "public"."notify_waitlist_update"() TO "anon";

GRANT ALL ON FUNCTION "public"."notify_waitlist_update"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."notify_waitlist_update"() TO "service_role";

GRANT ALL ON FUNCTION "public"."on_user_activity_update_segment"() TO "anon";

GRANT ALL ON FUNCTION "public"."on_user_activity_update_segment"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."on_user_activity_update_segment"() TO "service_role";

GRANT ALL ON FUNCTION "public"."org_has_feature"("p_org_id" "uuid", "p_feature_key" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."org_has_feature"("p_org_id" "uuid", "p_feature_key" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."org_has_feature"("p_org_id" "uuid", "p_feature_key" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."prevent_task_circular_reference"() TO "anon";

GRANT ALL ON FUNCTION "public"."prevent_task_circular_reference"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."prevent_task_circular_reference"() TO "service_role";

GRANT ALL ON FUNCTION "public"."process_hitl_action"("p_approval_id" "uuid", "p_action" "text", "p_actioned_by" "uuid", "p_response" "jsonb", "p_edited_content" "jsonb") TO "anon";

GRANT ALL ON FUNCTION "public"."process_hitl_action"("p_approval_id" "uuid", "p_action" "text", "p_actioned_by" "uuid", "p_response" "jsonb", "p_edited_content" "jsonb") TO "authenticated";

GRANT ALL ON FUNCTION "public"."process_hitl_action"("p_approval_id" "uuid", "p_action" "text", "p_actioned_by" "uuid", "p_response" "jsonb", "p_edited_content" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."queue_call_for_indexing"() TO "anon";

GRANT ALL ON FUNCTION "public"."queue_call_for_indexing"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."queue_call_for_indexing"() TO "service_role";

GRANT ALL ON FUNCTION "public"."queue_meeting_for_indexing"() TO "anon";

GRANT ALL ON FUNCTION "public"."queue_meeting_for_indexing"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."queue_meeting_for_indexing"() TO "service_role";

GRANT ALL ON FUNCTION "public"."queue_notification"("p_user_id" "uuid", "p_org_id" "uuid", "p_notification_type" "text", "p_channel" "text", "p_payload" "jsonb", "p_priority" "text", "p_scheduled_for" timestamp with time zone, "p_send_deadline" timestamp with time zone, "p_dedupe_key" "text", "p_dedupe_window_minutes" integer, "p_related_entity_type" "text", "p_related_entity_id" "uuid", "p_metadata" "jsonb") TO "anon";

GRANT ALL ON FUNCTION "public"."queue_notification"("p_user_id" "uuid", "p_org_id" "uuid", "p_notification_type" "text", "p_channel" "text", "p_payload" "jsonb", "p_priority" "text", "p_scheduled_for" timestamp with time zone, "p_send_deadline" timestamp with time zone, "p_dedupe_key" "text", "p_dedupe_window_minutes" integer, "p_related_entity_type" "text", "p_related_entity_id" "uuid", "p_metadata" "jsonb") TO "authenticated";

GRANT ALL ON FUNCTION "public"."queue_notification"("p_user_id" "uuid", "p_org_id" "uuid", "p_notification_type" "text", "p_channel" "text", "p_payload" "jsonb", "p_priority" "text", "p_scheduled_for" timestamp with time zone, "p_send_deadline" timestamp with time zone, "p_dedupe_key" "text", "p_dedupe_window_minutes" integer, "p_related_entity_type" "text", "p_related_entity_id" "uuid", "p_metadata" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."queue_topics_for_aggregation"() TO "anon";

GRANT ALL ON FUNCTION "public"."queue_topics_for_aggregation"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."queue_topics_for_aggregation"() TO "service_role";

GRANT ALL ON FUNCTION "public"."reanalyze_action_items_with_ai"("p_meeting_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."reanalyze_action_items_with_ai"("p_meeting_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."reanalyze_action_items_with_ai"("p_meeting_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."reconcile_billing_subscriptions"() TO "anon";

GRANT ALL ON FUNCTION "public"."reconcile_billing_subscriptions"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."reconcile_billing_subscriptions"() TO "service_role";

GRANT ALL ON FUNCTION "public"."record_activation_event"("p_user_id" "uuid", "p_event_type" "text", "p_event_data" "jsonb") TO "anon";

GRANT ALL ON FUNCTION "public"."record_activation_event"("p_user_id" "uuid", "p_event_type" "text", "p_event_data" "jsonb") TO "authenticated";

GRANT ALL ON FUNCTION "public"."record_activation_event"("p_user_id" "uuid", "p_event_type" "text", "p_event_data" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."record_email_send"("p_user_id" "uuid", "p_journey_id" "uuid", "p_email_type" "text", "p_to_email" "text", "p_encharge_message_id" "text", "p_metadata" "jsonb") TO "anon";

GRANT ALL ON FUNCTION "public"."record_email_send"("p_user_id" "uuid", "p_journey_id" "uuid", "p_email_type" "text", "p_to_email" "text", "p_encharge_message_id" "text", "p_metadata" "jsonb") TO "authenticated";

GRANT ALL ON FUNCTION "public"."record_email_send"("p_user_id" "uuid", "p_journey_id" "uuid", "p_email_type" "text", "p_to_email" "text", "p_encharge_message_id" "text", "p_metadata" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."record_notification_interaction"("p_user_id" "uuid", "p_org_id" "uuid", "p_notification_type" "text", "p_delivered_via" "text", "p_slack_notification_sent_id" "uuid", "p_notification_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."record_notification_interaction"("p_user_id" "uuid", "p_org_id" "uuid", "p_notification_type" "text", "p_delivered_via" "text", "p_slack_notification_sent_id" "uuid", "p_notification_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."record_notification_interaction"("p_user_id" "uuid", "p_org_id" "uuid", "p_notification_type" "text", "p_delivered_via" "text", "p_slack_notification_sent_id" "uuid", "p_notification_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."record_notification_preference_feedback"("p_user_id" "uuid", "p_feedback_value" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."record_notification_preference_feedback"("p_user_id" "uuid", "p_feedback_value" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."record_notification_preference_feedback"("p_user_id" "uuid", "p_feedback_value" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."record_reengagement_attempt"("p_user_id" "uuid", "p_org_id" "uuid", "p_reengagement_type" "text", "p_channel" "text", "p_trigger_type" "text", "p_trigger_entity_type" "text", "p_trigger_entity_id" "uuid", "p_trigger_context" "jsonb") TO "anon";

GRANT ALL ON FUNCTION "public"."record_reengagement_attempt"("p_user_id" "uuid", "p_org_id" "uuid", "p_reengagement_type" "text", "p_channel" "text", "p_trigger_type" "text", "p_trigger_entity_type" "text", "p_trigger_entity_id" "uuid", "p_trigger_context" "jsonb") TO "authenticated";

GRANT ALL ON FUNCTION "public"."record_reengagement_attempt"("p_user_id" "uuid", "p_org_id" "uuid", "p_reengagement_type" "text", "p_channel" "text", "p_trigger_type" "text", "p_trigger_entity_type" "text", "p_trigger_entity_id" "uuid", "p_trigger_context" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."record_reengagement_response"("p_log_id" "uuid", "p_action" "text", "p_action_detail" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."record_reengagement_response"("p_log_id" "uuid", "p_action" "text", "p_action_detail" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."record_reengagement_response"("p_log_id" "uuid", "p_action" "text", "p_action_detail" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."record_usage_event"("p_org_id" "uuid", "p_user_id" "uuid", "p_event_type" "text", "p_event_subtype" "text", "p_quantity" integer, "p_metadata" "jsonb") TO "anon";

GRANT ALL ON FUNCTION "public"."record_usage_event"("p_org_id" "uuid", "p_user_id" "uuid", "p_event_type" "text", "p_event_subtype" "text", "p_quantity" integer, "p_metadata" "jsonb") TO "authenticated";

GRANT ALL ON FUNCTION "public"."record_usage_event"("p_org_id" "uuid", "p_user_id" "uuid", "p_event_type" "text", "p_event_subtype" "text", "p_quantity" integer, "p_metadata" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."refresh_deal_health_scores"("p_user_id" "uuid", "p_max_age_hours" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."refresh_deal_health_scores"("p_user_id" "uuid", "p_max_age_hours" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."refresh_deal_health_scores"("p_user_id" "uuid", "p_max_age_hours" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."refresh_meeting_aggregate_metrics"("p_org_id" "uuid", "p_period_type" "text", "p_period_start" "date") TO "anon";

GRANT ALL ON FUNCTION "public"."refresh_meeting_aggregate_metrics"("p_org_id" "uuid", "p_period_type" "text", "p_period_start" "date") TO "authenticated";

GRANT ALL ON FUNCTION "public"."refresh_meeting_aggregate_metrics"("p_org_id" "uuid", "p_period_type" "text", "p_period_start" "date") TO "service_role";

GRANT ALL ON FUNCTION "public"."refresh_relationship_health_scores"("p_user_id" "uuid", "p_max_age_hours" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."refresh_relationship_health_scores"("p_user_id" "uuid", "p_max_age_hours" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."refresh_relationship_health_scores"("p_user_id" "uuid", "p_max_age_hours" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."regenerate_next_actions_for_activity"("p_activity_id" "uuid", "p_activity_type" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."regenerate_next_actions_for_activity"("p_activity_id" "uuid", "p_activity_type" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."regenerate_next_actions_for_activity"("p_activity_id" "uuid", "p_activity_type" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."reject_pipeline_recommendation"("p_recommendation_id" "uuid", "p_reviewed_by" "uuid", "p_notes" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."reject_pipeline_recommendation"("p_recommendation_id" "uuid", "p_reviewed_by" "uuid", "p_notes" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."reject_pipeline_recommendation"("p_recommendation_id" "uuid", "p_reviewed_by" "uuid", "p_notes" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."rename_user_organization"("p_new_name" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."rename_user_organization"("p_new_name" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."rename_user_organization"("p_new_name" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."resend_waitlist_magic_link"("p_entry_id" "uuid", "p_admin_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."resend_waitlist_magic_link"("p_entry_id" "uuid", "p_admin_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."resend_waitlist_magic_link"("p_entry_id" "uuid", "p_admin_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."reset_prompt_to_default"("p_category" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."reset_prompt_to_default"("p_category" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."reset_prompt_to_default"("p_category" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."resolve_deal_migration_review"("p_review_id" "uuid", "p_company_id" "uuid", "p_contact_id" "uuid", "p_resolved_by" "uuid", "p_notes" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."resolve_deal_migration_review"("p_review_id" "uuid", "p_company_id" "uuid", "p_contact_id" "uuid", "p_resolved_by" "uuid", "p_notes" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."resolve_deal_migration_review"("p_review_id" "uuid", "p_company_id" "uuid", "p_contact_id" "uuid", "p_resolved_by" "uuid", "p_notes" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."resolve_fathom_user_to_sixty"("p_org_id" "uuid", "p_fathom_email" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."resolve_fathom_user_to_sixty"("p_org_id" "uuid", "p_fathom_email" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."resolve_fathom_user_to_sixty"("p_org_id" "uuid", "p_fathom_email" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."respond_to_hitl_request"("p_request_id" "uuid", "p_response_value" "text", "p_response_context" "jsonb", "p_response_channel" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."respond_to_hitl_request"("p_request_id" "uuid", "p_response_value" "text", "p_response_context" "jsonb", "p_response_channel" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."respond_to_hitl_request"("p_request_id" "uuid", "p_response_value" "text", "p_response_context" "jsonb", "p_response_channel" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."retry_roadmap_sync"("suggestion_id_param" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."retry_roadmap_sync"("suggestion_id_param" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."retry_roadmap_sync"("suggestion_id_param" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."safe_execute_unified_automation_rules"() TO "anon";

GRANT ALL ON FUNCTION "public"."safe_execute_unified_automation_rules"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."safe_execute_unified_automation_rules"() TO "service_role";

GRANT ALL ON FUNCTION "public"."save_compiled_organization_skill"("p_org_id" "uuid", "p_skill_key" "text", "p_platform_skill_id" "uuid", "p_platform_version" integer, "p_compiled_frontmatter" "jsonb", "p_compiled_content" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."save_compiled_organization_skill"("p_org_id" "uuid", "p_skill_key" "text", "p_platform_skill_id" "uuid", "p_platform_version" integer, "p_compiled_frontmatter" "jsonb", "p_compiled_content" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."save_compiled_organization_skill"("p_org_id" "uuid", "p_skill_key" "text", "p_platform_skill_id" "uuid", "p_platform_version" integer, "p_compiled_frontmatter" "jsonb", "p_compiled_content" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."save_organization_skill"("p_org_id" "uuid", "p_skill_id" "text", "p_skill_name" "text", "p_config" "jsonb", "p_user_id" "uuid", "p_ai_generated" boolean, "p_change_reason" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."save_organization_skill"("p_org_id" "uuid", "p_skill_id" "text", "p_skill_name" "text", "p_config" "jsonb", "p_user_id" "uuid", "p_ai_generated" boolean, "p_change_reason" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."save_organization_skill"("p_org_id" "uuid", "p_skill_id" "text", "p_skill_name" "text", "p_config" "jsonb", "p_user_id" "uuid", "p_ai_generated" boolean, "p_change_reason" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."save_platform_skill_history"() TO "anon";

GRANT ALL ON FUNCTION "public"."save_platform_skill_history"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."save_platform_skill_history"() TO "service_role";

GRANT ALL ON FUNCTION "public"."save_prompt_template"("p_category" "text", "p_name" "text", "p_system_prompt" "text", "p_user_prompt" "text", "p_model" "text", "p_temperature" numeric, "p_max_tokens" integer, "p_description" "text", "p_organization_id" "uuid", "p_is_public" boolean) TO "anon";

GRANT ALL ON FUNCTION "public"."save_prompt_template"("p_category" "text", "p_name" "text", "p_system_prompt" "text", "p_user_prompt" "text", "p_model" "text", "p_temperature" numeric, "p_max_tokens" integer, "p_description" "text", "p_organization_id" "uuid", "p_is_public" boolean) TO "authenticated";

GRANT ALL ON FUNCTION "public"."save_prompt_template"("p_category" "text", "p_name" "text", "p_system_prompt" "text", "p_user_prompt" "text", "p_model" "text", "p_temperature" numeric, "p_max_tokens" integer, "p_description" "text", "p_organization_id" "uuid", "p_is_public" boolean) TO "service_role";

GRANT ALL ON FUNCTION "public"."search_meetings_by_owner"("p_owner_user_id" "uuid", "p_sentiment" "text", "p_date_from" "date", "p_date_to" "date", "p_company_id" "uuid", "p_has_action_items" boolean, "p_limit" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."search_meetings_by_owner"("p_owner_user_id" "uuid", "p_sentiment" "text", "p_date_from" "date", "p_date_to" "date", "p_company_id" "uuid", "p_has_action_items" boolean, "p_limit" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."search_meetings_by_owner"("p_owner_user_id" "uuid", "p_sentiment" "text", "p_date_from" "date", "p_date_to" "date", "p_company_id" "uuid", "p_has_action_items" boolean, "p_limit" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."seed_default_call_types"("p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."seed_default_call_types"("p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."seed_default_call_types"("p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."set_audit_context"("p_original_user_id" "uuid", "p_impersonated_user_id" "uuid", "p_is_impersonating" boolean) TO "anon";

GRANT ALL ON FUNCTION "public"."set_audit_context"("p_original_user_id" "uuid", "p_impersonated_user_id" "uuid", "p_is_impersonating" boolean) TO "authenticated";

GRANT ALL ON FUNCTION "public"."set_audit_context"("p_original_user_id" "uuid", "p_impersonated_user_id" "uuid", "p_is_impersonating" boolean) TO "service_role";

GRANT ALL ON FUNCTION "public"."set_calendar_event_org_id"() TO "anon";

GRANT ALL ON FUNCTION "public"."set_calendar_event_org_id"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."set_calendar_event_org_id"() TO "service_role";

GRANT ALL ON FUNCTION "public"."set_referral_code"() TO "anon";

GRANT ALL ON FUNCTION "public"."set_referral_code"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."set_referral_code"() TO "service_role";

GRANT ALL ON FUNCTION "public"."set_signup_position"() TO "anon";

GRANT ALL ON FUNCTION "public"."set_signup_position"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."set_signup_position"() TO "service_role";

GRANT ALL ON FUNCTION "public"."set_system_config"("p_key" "text", "p_value" "text", "p_description" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."set_system_config"("p_key" "text", "p_value" "text", "p_description" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."set_system_config"("p_key" "text", "p_value" "text", "p_description" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."should_create_notification"("p_user_id" "uuid", "p_notification_type" "text", "p_max_per_hour" integer, "p_max_per_day" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."should_create_notification"("p_user_id" "uuid", "p_notification_type" "text", "p_max_per_hour" integer, "p_max_per_day" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."should_create_notification"("p_user_id" "uuid", "p_notification_type" "text", "p_max_per_hour" integer, "p_max_per_day" integer) TO "service_role";

GRANT ALL ON FUNCTION "public"."should_request_feedback"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."should_request_feedback"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."should_request_feedback"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."sync_action_item_completion_to_task"() TO "anon";

GRANT ALL ON FUNCTION "public"."sync_action_item_completion_to_task"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."sync_action_item_completion_to_task"() TO "service_role";

GRANT ALL ON FUNCTION "public"."sync_action_item_to_task"("action_item_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."sync_action_item_to_task"("action_item_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."sync_action_item_to_task"("action_item_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."sync_deal_activity_to_main_activities"() TO "anon";

GRANT ALL ON FUNCTION "public"."sync_deal_activity_to_main_activities"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."sync_deal_activity_to_main_activities"() TO "service_role";

GRANT ALL ON FUNCTION "public"."sync_playwright_test_user"() TO "anon";

GRANT ALL ON FUNCTION "public"."sync_playwright_test_user"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."sync_playwright_test_user"() TO "service_role";

GRANT ALL ON FUNCTION "public"."sync_task_assignee_to_action_item"() TO "anon";

GRANT ALL ON FUNCTION "public"."sync_task_assignee_to_action_item"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."sync_task_assignee_to_action_item"() TO "service_role";

GRANT ALL ON FUNCTION "public"."sync_task_completion_to_action_item"() TO "anon";

GRANT ALL ON FUNCTION "public"."sync_task_completion_to_action_item"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."sync_task_completion_to_action_item"() TO "service_role";

GRANT ALL ON FUNCTION "public"."sync_task_to_action_item"("task_id_input" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."sync_task_to_action_item"("task_id_input" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."sync_task_to_action_item"("task_id_input" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."sync_task_type_columns"() TO "anon";

GRANT ALL ON FUNCTION "public"."sync_task_type_columns"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."sync_task_type_columns"() TO "service_role";

GRANT ALL ON FUNCTION "public"."toggle_topic_archive"("p_topic_id" "uuid", "p_archive" boolean) TO "anon";

GRANT ALL ON FUNCTION "public"."toggle_topic_archive"("p_topic_id" "uuid", "p_archive" boolean) TO "authenticated";

GRANT ALL ON FUNCTION "public"."toggle_topic_archive"("p_topic_id" "uuid", "p_archive" boolean) TO "service_role";

GRANT ALL ON FUNCTION "public"."track_waitlist_link_share"("p_entry_id" "uuid", "p_platform" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."track_waitlist_link_share"("p_entry_id" "uuid", "p_platform" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."track_waitlist_link_share"("p_entry_id" "uuid", "p_platform" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."trigger_all_task_notifications"() TO "anon";

GRANT ALL ON FUNCTION "public"."trigger_all_task_notifications"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."trigger_all_task_notifications"() TO "service_role";

GRANT ALL ON FUNCTION "public"."trigger_auto_record_for_new_event"() TO "anon";

GRANT ALL ON FUNCTION "public"."trigger_auto_record_for_new_event"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."trigger_auto_record_for_new_event"() TO "service_role";

GRANT ALL ON FUNCTION "public"."trigger_fathom_hourly_sync"() TO "anon";

GRANT ALL ON FUNCTION "public"."trigger_fathom_hourly_sync"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."trigger_fathom_hourly_sync"() TO "service_role";

GRANT ALL ON FUNCTION "public"."trigger_recalculate_clarity_on_plan_change"() TO "anon";

GRANT ALL ON FUNCTION "public"."trigger_recalculate_clarity_on_plan_change"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."trigger_recalculate_clarity_on_plan_change"() TO "service_role";

GRANT ALL ON FUNCTION "public"."trigger_recalculate_clarity_on_truth_change"() TO "anon";

GRANT ALL ON FUNCTION "public"."trigger_recalculate_clarity_on_truth_change"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."trigger_recalculate_clarity_on_truth_change"() TO "service_role";

GRANT ALL ON FUNCTION "public"."trigger_recalculate_deal_risk"() TO "anon";

GRANT ALL ON FUNCTION "public"."trigger_recalculate_deal_risk"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."trigger_recalculate_deal_risk"() TO "service_role";

GRANT ALL ON FUNCTION "public"."trigger_roadmap_sync_webhook"() TO "anon";

GRANT ALL ON FUNCTION "public"."trigger_roadmap_sync_webhook"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."trigger_roadmap_sync_webhook"() TO "service_role";

GRANT ALL ON FUNCTION "public"."trigger_suggest_next_actions_for_activity"() TO "anon";

GRANT ALL ON FUNCTION "public"."trigger_suggest_next_actions_for_activity"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."trigger_suggest_next_actions_for_activity"() TO "service_role";

GRANT ALL ON FUNCTION "public"."trigger_suggest_next_actions_for_meeting"() TO "anon";

GRANT ALL ON FUNCTION "public"."trigger_suggest_next_actions_for_meeting"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."trigger_suggest_next_actions_for_meeting"() TO "service_role";

GRANT ALL ON FUNCTION "public"."trigger_sync_action_item_to_task"() TO "anon";

GRANT ALL ON FUNCTION "public"."trigger_sync_action_item_to_task"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."trigger_sync_action_item_to_task"() TO "service_role";

GRANT ALL ON FUNCTION "public"."trigger_sync_task_to_action_item"() TO "anon";

GRANT ALL ON FUNCTION "public"."trigger_sync_task_to_action_item"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."trigger_sync_task_to_action_item"() TO "service_role";

GRANT ALL ON FUNCTION "public"."trigger_update_meeting_insights"() TO "anon";

GRANT ALL ON FUNCTION "public"."trigger_update_meeting_insights"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."trigger_update_meeting_insights"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_ai_preferences_timestamp"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_ai_preferences_timestamp"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_ai_preferences_timestamp"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_app_settings_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_app_settings_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_app_settings_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_branding_settings_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_branding_settings_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_branding_settings_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_clerk_mapping_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_clerk_mapping_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_clerk_mapping_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_clients_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_clients_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_clients_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_coaching_scorecard_templates_timestamp"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_coaching_scorecard_templates_timestamp"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_coaching_scorecard_templates_timestamp"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_contact_meeting_stats"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_contact_meeting_stats"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_contact_meeting_stats"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_contact_meeting_stats_on_delete"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_contact_meeting_stats_on_delete"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_contact_meeting_stats_on_delete"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_copilot_conversation_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_copilot_conversation_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_copilot_conversation_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_deal_clarity_scores_timestamp"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_deal_clarity_scores_timestamp"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_deal_clarity_scores_timestamp"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_deal_close_plan_timestamp"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_deal_close_plan_timestamp"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_deal_close_plan_timestamp"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_deal_revenue_calculations"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_deal_revenue_calculations"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_deal_revenue_calculations"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_deal_risk_tables_timestamp"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_deal_risk_tables_timestamp"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_deal_risk_tables_timestamp"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_deal_split_amounts_on_deal_change"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_deal_split_amounts_on_deal_change"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_deal_split_amounts_on_deal_change"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_deal_truth_timestamp"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_deal_truth_timestamp"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_deal_truth_timestamp"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_fathom_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_fathom_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_fathom_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_fathom_user_mappings_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_fathom_user_mappings_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_fathom_user_mappings_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_google_tasks_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_google_tasks_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_google_tasks_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_hitl_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_hitl_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_hitl_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_intervention_templates_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_intervention_templates_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_intervention_templates_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_interventions_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_interventions_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_interventions_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_last_login"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_last_login"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_last_login"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_launch_checklist_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_launch_checklist_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_launch_checklist_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_meeting_structured_summaries_timestamp"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_meeting_structured_summaries_timestamp"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_meeting_structured_summaries_timestamp"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_meetingbaas_calendars_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_meetingbaas_calendars_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_meetingbaas_calendars_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_next_actions_count"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_next_actions_count"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_next_actions_count"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_notification_interaction"("p_interaction_id" "uuid", "p_action" "text", "p_action_taken" "text", "p_feedback_rating" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."update_notification_interaction"("p_interaction_id" "uuid", "p_action" "text", "p_action_taken" "text", "p_feedback_rating" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_notification_interaction"("p_interaction_id" "uuid", "p_action" "text", "p_action_taken" "text", "p_feedback_rating" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."update_onboarding_progress_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_onboarding_progress_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_onboarding_progress_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_org_call_types_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_org_call_types_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_org_call_types_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_partial_signups_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_partial_signups_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_partial_signups_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_pipeline_rules_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_pipeline_rules_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_pipeline_rules_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_pm_workflows_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_pm_workflows_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_pm_workflows_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_process_maps_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_process_maps_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_process_maps_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_relationship_health_scores_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_relationship_health_scores_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_relationship_health_scores_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_sentiment_alerts_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_sentiment_alerts_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_sentiment_alerts_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_sentry_bridge_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_sentry_bridge_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_sentry_bridge_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_slack_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_slack_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_slack_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_split_amount"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_split_amount"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_split_amount"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_subscription_facts"("p_subscription_id" "uuid", "p_recurring_amount_cents" integer, "p_interval" "text", "p_interval_count" integer, "p_discount_info" "jsonb", "p_customer_country" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."update_subscription_facts"("p_subscription_id" "uuid", "p_recurring_amount_cents" integer, "p_interval" "text", "p_interval_count" integer, "p_discount_info" "jsonb", "p_customer_country" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_subscription_facts"("p_subscription_id" "uuid", "p_recurring_amount_cents" integer, "p_interval" "text", "p_interval_count" integer, "p_discount_info" "jsonb", "p_customer_country" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."update_suggestion_on_task_creation"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_suggestion_on_task_creation"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_suggestion_on_task_creation"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_suggestion_votes_count"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_suggestion_votes_count"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_suggestion_votes_count"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_system_config_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_system_config_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_system_config_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_task_sync_status"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_task_sync_status"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_task_sync_status"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_template_performance"("template_id_param" "uuid", "opened" boolean, "clicked" boolean, "replied" boolean, "recovered" boolean, "response_time_hours" numeric) TO "anon";

GRANT ALL ON FUNCTION "public"."update_template_performance"("template_id_param" "uuid", "opened" boolean, "clicked" boolean, "replied" boolean, "recovered" boolean, "response_time_hours" numeric) TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_template_performance"("template_id_param" "uuid", "opened" boolean, "clicked" boolean, "replied" boolean, "recovered" boolean, "response_time_hours" numeric) TO "service_role";

GRANT ALL ON FUNCTION "public"."update_template_performance_on_intervention_change"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_template_performance_on_intervention_change"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_template_performance_on_intervention_change"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_thread_metadata"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_thread_metadata"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_thread_metadata"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_transcript_retry_job_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_transcript_retry_job_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_transcript_retry_job_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_user_ai_feature_settings_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_user_ai_feature_settings_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_user_ai_feature_settings_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_user_coaching_preferences_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_user_coaching_preferences_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_user_coaching_preferences_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_user_engagement_metrics_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_user_engagement_metrics_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_user_engagement_metrics_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_user_sync_status_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_user_sync_status_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_user_sync_status_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_user_timezone"("p_user_id" "uuid", "p_timezone" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."update_user_timezone"("p_user_id" "uuid", "p_timezone" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_user_timezone"("p_user_id" "uuid", "p_timezone" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."update_waitlist_email_template_timestamp"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_waitlist_email_template_timestamp"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_waitlist_email_template_timestamp"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_workflow_results_updated_at"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_workflow_results_updated_at"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_workflow_results_updated_at"() TO "service_role";

GRANT ALL ON FUNCTION "public"."update_workflow_statistics"() TO "anon";

GRANT ALL ON FUNCTION "public"."update_workflow_statistics"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."update_workflow_statistics"() TO "service_role";

GRANT ALL ON FUNCTION "public"."upsert_deal_clarity_score"("p_deal_id" "uuid", "p_org_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."upsert_deal_clarity_score"("p_deal_id" "uuid", "p_org_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."upsert_deal_clarity_score"("p_deal_id" "uuid", "p_org_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."upsert_organization_context"("p_org_id" "uuid", "p_context_key" "text", "p_value" "jsonb", "p_value_type" "text", "p_source" "text", "p_confidence" numeric) TO "anon";

GRANT ALL ON FUNCTION "public"."upsert_organization_context"("p_org_id" "uuid", "p_context_key" "text", "p_value" "jsonb", "p_value_type" "text", "p_source" "text", "p_confidence" numeric) TO "authenticated";

GRANT ALL ON FUNCTION "public"."upsert_organization_context"("p_org_id" "uuid", "p_context_key" "text", "p_value" "jsonb", "p_value_type" "text", "p_source" "text", "p_confidence" numeric) TO "service_role";

GRANT ALL ON FUNCTION "public"."user_org_ids"("p_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."user_org_ids"("p_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."user_org_ids"("p_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."user_owns_execution"("p_execution_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."user_owns_execution"("p_execution_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."user_owns_execution"("p_execution_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."user_owns_workflow"("p_workflow_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."user_owns_workflow"("p_workflow_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."user_owns_workflow"("p_workflow_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."user_shares_org_with"("target_user_id" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."user_shares_org_with"("target_user_id" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."user_shares_org_with"("target_user_id" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."users_share_organization"("user_a" "uuid", "user_b" "uuid") TO "anon";

GRANT ALL ON FUNCTION "public"."users_share_organization"("user_a" "uuid", "user_b" "uuid") TO "authenticated";

GRANT ALL ON FUNCTION "public"."users_share_organization"("user_a" "uuid", "user_b" "uuid") TO "service_role";

GRANT ALL ON FUNCTION "public"."validate_api_key"("params" "jsonb") TO "anon";

GRANT ALL ON FUNCTION "public"."validate_api_key"("params" "jsonb") TO "authenticated";

GRANT ALL ON FUNCTION "public"."validate_api_key"("params" "jsonb") TO "service_role";

GRANT ALL ON FUNCTION "public"."validate_api_key"("key_text" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."validate_api_key"("key_text" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."validate_api_key"("key_text" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."validate_api_key_simple"("key_text" "text") TO "anon";

GRANT ALL ON FUNCTION "public"."validate_api_key_simple"("key_text" "text") TO "authenticated";

GRANT ALL ON FUNCTION "public"."validate_api_key_simple"("key_text" "text") TO "service_role";

GRANT ALL ON FUNCTION "public"."validate_deal_split_percentages"() TO "anon";

GRANT ALL ON FUNCTION "public"."validate_deal_split_percentages"() TO "authenticated";

GRANT ALL ON FUNCTION "public"."validate_deal_split_percentages"() TO "service_role";

GRANT ALL ON FUNCTION "public"."validate_org_access"("p_org_id" "uuid", "p_require_write" boolean) TO "anon";

GRANT ALL ON FUNCTION "public"."validate_org_access"("p_org_id" "uuid", "p_require_write" boolean) TO "authenticated";

GRANT ALL ON FUNCTION "public"."validate_org_access"("p_org_id" "uuid", "p_require_write" boolean) TO "service_role";

GRANT ALL ON FUNCTION "public"."was_email_sent"("p_user_id" "uuid", "p_email_type" "text", "p_hours_window" integer) TO "anon";

GRANT ALL ON FUNCTION "public"."was_email_sent"("p_user_id" "uuid", "p_email_type" "text", "p_hours_window" integer) TO "authenticated";

GRANT ALL ON FUNCTION "public"."was_email_sent"("p_user_id" "uuid", "p_email_type" "text", "p_hours_window" integer) TO "service_role";

GRANT ALL ON TABLE "public"."action_items" TO "anon";

GRANT ALL ON TABLE "public"."action_items" TO "authenticated";

GRANT ALL ON TABLE "public"."action_items" TO "service_role";

GRANT ALL ON TABLE "public"."user_activation_events" TO "anon";

GRANT ALL ON TABLE "public"."user_activation_events" TO "authenticated";

GRANT ALL ON TABLE "public"."user_activation_events" TO "service_role";

GRANT ALL ON TABLE "public"."user_onboarding_progress" TO "anon";

GRANT ALL ON TABLE "public"."user_onboarding_progress" TO "authenticated";

GRANT ALL ON TABLE "public"."user_onboarding_progress" TO "service_role";

GRANT ALL ON TABLE "public"."activation_funnel_metrics" TO "authenticated";

GRANT ALL ON TABLE "public"."activation_funnel_metrics" TO "service_role";

GRANT ALL ON TABLE "public"."activities" TO "anon";

GRANT ALL ON TABLE "public"."activities" TO "authenticated";

GRANT ALL ON TABLE "public"."activities" TO "service_role";

GRANT ALL ON TABLE "public"."activities_with_profile" TO "anon";

GRANT ALL ON TABLE "public"."activities_with_profile" TO "authenticated";

GRANT ALL ON TABLE "public"."activities_with_profile" TO "service_role";

GRANT ALL ON TABLE "public"."activity_sync_rules" TO "anon";

GRANT ALL ON TABLE "public"."activity_sync_rules" TO "authenticated";

GRANT ALL ON TABLE "public"."activity_sync_rules" TO "service_role";

GRANT ALL ON TABLE "public"."ai_cost_events" TO "anon";

GRANT ALL ON TABLE "public"."ai_cost_events" TO "authenticated";

GRANT ALL ON TABLE "public"."ai_cost_events" TO "service_role";

GRANT ALL ON TABLE "public"."ai_feedback" TO "anon";

GRANT ALL ON TABLE "public"."ai_feedback" TO "authenticated";

GRANT ALL ON TABLE "public"."ai_feedback" TO "service_role";

GRANT ALL ON TABLE "public"."ai_insights" TO "anon";

GRANT ALL ON TABLE "public"."ai_insights" TO "authenticated";

GRANT ALL ON TABLE "public"."ai_insights" TO "service_role";

GRANT ALL ON TABLE "public"."ai_prompt_template_history" TO "anon";

GRANT ALL ON TABLE "public"."ai_prompt_template_history" TO "authenticated";

GRANT ALL ON TABLE "public"."ai_prompt_template_history" TO "service_role";

GRANT ALL ON TABLE "public"."ai_prompt_templates" TO "anon";

GRANT ALL ON TABLE "public"."ai_prompt_templates" TO "authenticated";

GRANT ALL ON TABLE "public"."ai_prompt_templates" TO "service_role";

GRANT ALL ON TABLE "public"."ai_usage_logs" TO "anon";

GRANT ALL ON TABLE "public"."ai_usage_logs" TO "authenticated";

GRANT ALL ON TABLE "public"."ai_usage_logs" TO "service_role";

GRANT ALL ON TABLE "public"."api_key_usage" TO "anon";

GRANT ALL ON TABLE "public"."api_key_usage" TO "authenticated";

GRANT ALL ON TABLE "public"."api_key_usage" TO "service_role";

GRANT ALL ON TABLE "public"."api_keys" TO "anon";

GRANT ALL ON TABLE "public"."api_keys" TO "authenticated";

GRANT ALL ON TABLE "public"."api_keys" TO "service_role";

GRANT ALL ON TABLE "public"."api_monitor_improvements" TO "anon";

GRANT ALL ON TABLE "public"."api_monitor_improvements" TO "authenticated";

GRANT ALL ON TABLE "public"."api_monitor_improvements" TO "service_role";

GRANT ALL ON TABLE "public"."api_monitor_rollups_daily" TO "anon";

GRANT ALL ON TABLE "public"."api_monitor_rollups_daily" TO "authenticated";

GRANT ALL ON TABLE "public"."api_monitor_rollups_daily" TO "service_role";

GRANT ALL ON TABLE "public"."api_monitor_snapshots" TO "anon";

GRANT ALL ON TABLE "public"."api_monitor_snapshots" TO "authenticated";

GRANT ALL ON TABLE "public"."api_monitor_snapshots" TO "service_role";

GRANT ALL ON TABLE "public"."api_requests" TO "anon";

GRANT ALL ON TABLE "public"."api_requests" TO "authenticated";

GRANT ALL ON TABLE "public"."api_requests" TO "service_role";

GRANT ALL ON TABLE "public"."app_settings" TO "anon";

GRANT ALL ON TABLE "public"."app_settings" TO "authenticated";

GRANT ALL ON TABLE "public"."app_settings" TO "service_role";

GRANT ALL ON TABLE "public"."organization_memberships" TO "anon";

GRANT ALL ON TABLE "public"."organization_memberships" TO "authenticated";

GRANT ALL ON TABLE "public"."organization_memberships" TO "service_role";

GRANT ALL ON TABLE "public"."organizations" TO "anon";

GRANT ALL ON TABLE "public"."organizations" TO "authenticated";

GRANT ALL ON TABLE "public"."organizations" TO "service_role";

GRANT ALL ON TABLE "public"."at_risk_users" TO "authenticated";

GRANT ALL ON TABLE "public"."at_risk_users" TO "service_role";

GRANT ALL ON TABLE "public"."audit_logs" TO "anon";

GRANT ALL ON TABLE "public"."audit_logs" TO "authenticated";

GRANT ALL ON TABLE "public"."audit_logs" TO "service_role";

GRANT ALL ON TABLE "public"."automation_executions" TO "anon";

GRANT ALL ON TABLE "public"."automation_executions" TO "authenticated";

GRANT ALL ON TABLE "public"."automation_executions" TO "service_role";

GRANT ALL ON TABLE "public"."billing_event_log" TO "anon";

GRANT ALL ON TABLE "public"."billing_event_log" TO "authenticated";

GRANT ALL ON TABLE "public"."billing_event_log" TO "service_role";

GRANT ALL ON TABLE "public"."billing_history" TO "anon";

GRANT ALL ON TABLE "public"."billing_history" TO "authenticated";

GRANT ALL ON TABLE "public"."billing_history" TO "service_role";

GRANT ALL ON TABLE "public"."booking_sources" TO "anon";

GRANT ALL ON TABLE "public"."booking_sources" TO "authenticated";

GRANT ALL ON TABLE "public"."booking_sources" TO "service_role";

GRANT ALL ON TABLE "public"."bot_deployments" TO "anon";

GRANT ALL ON TABLE "public"."bot_deployments" TO "authenticated";

GRANT ALL ON TABLE "public"."bot_deployments" TO "service_role";

GRANT ALL ON TABLE "public"."branding_settings" TO "anon";

GRANT ALL ON TABLE "public"."branding_settings" TO "authenticated";

GRANT ALL ON TABLE "public"."branding_settings" TO "service_role";

GRANT ALL ON TABLE "public"."calendar_attendees" TO "anon";

GRANT ALL ON TABLE "public"."calendar_attendees" TO "authenticated";

GRANT ALL ON TABLE "public"."calendar_attendees" TO "service_role";

GRANT ALL ON TABLE "public"."calendar_calendars" TO "anon";

GRANT ALL ON TABLE "public"."calendar_calendars" TO "authenticated";

GRANT ALL ON TABLE "public"."calendar_calendars" TO "service_role";

GRANT ALL ON TABLE "public"."calendar_events" TO "anon";

GRANT ALL ON TABLE "public"."calendar_events" TO "authenticated";

GRANT ALL ON TABLE "public"."calendar_events" TO "service_role";

GRANT ALL ON TABLE "public"."companies" TO "anon";

GRANT ALL ON TABLE "public"."companies" TO "authenticated";

GRANT ALL ON TABLE "public"."companies" TO "service_role";

GRANT ALL ON TABLE "public"."contacts" TO "anon";

GRANT ALL ON TABLE "public"."contacts" TO "authenticated";

GRANT ALL ON TABLE "public"."contacts" TO "service_role";

GRANT ALL ON TABLE "public"."calendar_events_with_contacts" TO "anon";

GRANT ALL ON TABLE "public"."calendar_events_with_contacts" TO "authenticated";

GRANT ALL ON TABLE "public"."calendar_events_with_contacts" TO "service_role";

GRANT ALL ON TABLE "public"."calendar_reminders" TO "anon";

GRANT ALL ON TABLE "public"."calendar_reminders" TO "authenticated";

GRANT ALL ON TABLE "public"."calendar_reminders" TO "service_role";

GRANT ALL ON TABLE "public"."calendar_sync_logs" TO "anon";

GRANT ALL ON TABLE "public"."calendar_sync_logs" TO "authenticated";

GRANT ALL ON TABLE "public"."calendar_sync_logs" TO "service_role";

GRANT ALL ON TABLE "public"."call_action_items" TO "anon";

GRANT ALL ON TABLE "public"."call_action_items" TO "authenticated";

GRANT ALL ON TABLE "public"."call_action_items" TO "service_role";

GRANT ALL ON TABLE "public"."call_file_search_index" TO "anon";

GRANT ALL ON TABLE "public"."call_file_search_index" TO "authenticated";

GRANT ALL ON TABLE "public"."call_file_search_index" TO "service_role";

GRANT ALL ON TABLE "public"."call_index_queue" TO "anon";

GRANT ALL ON TABLE "public"."call_index_queue" TO "authenticated";

GRANT ALL ON TABLE "public"."call_index_queue" TO "service_role";

GRANT ALL ON TABLE "public"."call_transcript_queue" TO "anon";

GRANT ALL ON TABLE "public"."call_transcript_queue" TO "authenticated";

GRANT ALL ON TABLE "public"."call_transcript_queue" TO "service_role";

GRANT ALL ON TABLE "public"."calls" TO "anon";

GRANT ALL ON TABLE "public"."calls" TO "authenticated";

GRANT ALL ON TABLE "public"."calls" TO "service_role";

GRANT ALL ON TABLE "public"."challenge_features" TO "anon";

GRANT ALL ON TABLE "public"."challenge_features" TO "authenticated";

GRANT ALL ON TABLE "public"."challenge_features" TO "service_role";

GRANT ALL ON TABLE "public"."challenges" TO "anon";

GRANT ALL ON TABLE "public"."challenges" TO "authenticated";

GRANT ALL ON TABLE "public"."challenges" TO "service_role";

GRANT ALL ON TABLE "public"."clerk_sync_log" TO "anon";

GRANT ALL ON TABLE "public"."clerk_sync_log" TO "authenticated";

GRANT ALL ON TABLE "public"."clerk_sync_log" TO "service_role";

GRANT ALL ON TABLE "public"."clerk_user_mappings" TO "anon";

GRANT ALL ON TABLE "public"."clerk_user_mappings" TO "authenticated";

GRANT ALL ON TABLE "public"."clerk_user_mappings" TO "service_role";

GRANT ALL ON TABLE "public"."clients" TO "anon";

GRANT ALL ON TABLE "public"."clients" TO "authenticated";

GRANT ALL ON TABLE "public"."clients" TO "service_role";

GRANT ALL ON TABLE "public"."client_churn_analytics" TO "anon";

GRANT ALL ON TABLE "public"."client_churn_analytics" TO "authenticated";

GRANT ALL ON TABLE "public"."client_churn_analytics" TO "service_role";

GRANT ALL ON TABLE "public"."coaching_scorecard_templates" TO "anon";

GRANT ALL ON TABLE "public"."coaching_scorecard_templates" TO "authenticated";

GRANT ALL ON TABLE "public"."coaching_scorecard_templates" TO "service_role";

GRANT ALL ON TABLE "public"."communication_events" TO "anon";

GRANT ALL ON TABLE "public"."communication_events" TO "authenticated";

GRANT ALL ON TABLE "public"."communication_events" TO "service_role";

GRANT ALL ON TABLE "public"."company_meeting_insights" TO "anon";

GRANT ALL ON TABLE "public"."company_meeting_insights" TO "authenticated";

GRANT ALL ON TABLE "public"."company_meeting_insights" TO "service_role";

GRANT ALL ON TABLE "public"."contact_meeting_insights" TO "anon";

GRANT ALL ON TABLE "public"."contact_meeting_insights" TO "authenticated";

GRANT ALL ON TABLE "public"."contact_meeting_insights" TO "service_role";

GRANT ALL ON TABLE "public"."contact_notes" TO "anon";

GRANT ALL ON TABLE "public"."contact_notes" TO "authenticated";

GRANT ALL ON TABLE "public"."contact_notes" TO "service_role";

GRANT ALL ON TABLE "public"."content" TO "anon";

GRANT ALL ON TABLE "public"."content" TO "authenticated";

GRANT ALL ON TABLE "public"."content" TO "service_role";

GRANT ALL ON TABLE "public"."content_topic_links" TO "anon";

GRANT ALL ON TABLE "public"."content_topic_links" TO "authenticated";

GRANT ALL ON TABLE "public"."content_topic_links" TO "service_role";

GRANT ALL ON TABLE "public"."copilot_analytics" TO "anon";

GRANT ALL ON TABLE "public"."copilot_analytics" TO "authenticated";

GRANT ALL ON TABLE "public"."copilot_analytics" TO "service_role";

GRANT ALL ON TABLE "public"."copilot_conversations" TO "anon";

GRANT ALL ON TABLE "public"."copilot_conversations" TO "authenticated";

GRANT ALL ON TABLE "public"."copilot_conversations" TO "service_role";

GRANT ALL ON TABLE "public"."copilot_messages" TO "anon";

GRANT ALL ON TABLE "public"."copilot_messages" TO "authenticated";

GRANT ALL ON TABLE "public"."copilot_messages" TO "service_role";

GRANT ALL ON TABLE "public"."cost_rates" TO "anon";

GRANT ALL ON TABLE "public"."cost_rates" TO "authenticated";

GRANT ALL ON TABLE "public"."cost_rates" TO "service_role";

GRANT ALL ON TABLE "public"."cron_job_logs" TO "anon";

GRANT ALL ON TABLE "public"."cron_job_logs" TO "authenticated";

GRANT ALL ON TABLE "public"."cron_job_logs" TO "service_role";

GRANT ALL ON TABLE "public"."cron_job_settings" TO "anon";

GRANT ALL ON TABLE "public"."cron_job_settings" TO "authenticated";

GRANT ALL ON TABLE "public"."cron_job_settings" TO "service_role";

GRANT ALL ON TABLE "public"."cron_jobs_status" TO "anon";

GRANT ALL ON TABLE "public"."cron_jobs_status" TO "authenticated";

GRANT ALL ON TABLE "public"."cron_jobs_status" TO "service_role";

GRANT ALL ON TABLE "public"."cron_notification_subscribers" TO "anon";

GRANT ALL ON TABLE "public"."cron_notification_subscribers" TO "authenticated";

GRANT ALL ON TABLE "public"."cron_notification_subscribers" TO "service_role";

GRANT ALL ON TABLE "public"."cron_notifications_log" TO "anon";

GRANT ALL ON TABLE "public"."cron_notifications_log" TO "authenticated";

GRANT ALL ON TABLE "public"."cron_notifications_log" TO "service_role";

GRANT ALL ON TABLE "public"."csv_mapping_templates" TO "anon";

GRANT ALL ON TABLE "public"."csv_mapping_templates" TO "authenticated";

GRANT ALL ON TABLE "public"."csv_mapping_templates" TO "service_role";

GRANT ALL ON TABLE "public"."deal_activities" TO "anon";

GRANT ALL ON TABLE "public"."deal_activities" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_activities" TO "service_role";

GRANT ALL ON TABLE "public"."deal_activities_with_profile" TO "anon";

GRANT ALL ON TABLE "public"."deal_activities_with_profile" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_activities_with_profile" TO "service_role";

GRANT ALL ON TABLE "public"."deal_clarity_scores" TO "anon";

GRANT ALL ON TABLE "public"."deal_clarity_scores" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_clarity_scores" TO "service_role";

GRANT ALL ON TABLE "public"."deal_close_plan_items" TO "anon";

GRANT ALL ON TABLE "public"."deal_close_plan_items" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_close_plan_items" TO "service_role";

GRANT ALL ON TABLE "public"."deal_health_alerts" TO "anon";

GRANT ALL ON TABLE "public"."deal_health_alerts" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_health_alerts" TO "service_role";

GRANT ALL ON TABLE "public"."deal_health_history" TO "anon";

GRANT ALL ON TABLE "public"."deal_health_history" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_health_history" TO "service_role";

GRANT ALL ON TABLE "public"."deal_health_rules" TO "anon";

GRANT ALL ON TABLE "public"."deal_health_rules" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_health_rules" TO "service_role";

GRANT ALL ON TABLE "public"."deal_health_scores" TO "anon";

GRANT ALL ON TABLE "public"."deal_health_scores" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_health_scores" TO "service_role";

GRANT ALL ON TABLE "public"."deal_migration_reviews" TO "anon";

GRANT ALL ON TABLE "public"."deal_migration_reviews" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_migration_reviews" TO "service_role";

GRANT ALL ON TABLE "public"."deals" TO "anon";

GRANT ALL ON TABLE "public"."deals" TO "authenticated";

GRANT ALL ON TABLE "public"."deals" TO "service_role";

GRANT ALL ON TABLE "public"."deal_migration_review_details" TO "anon";

GRANT ALL ON TABLE "public"."deal_migration_review_details" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_migration_review_details" TO "service_role";

GRANT ALL ON TABLE "public"."deal_notes" TO "anon";

GRANT ALL ON TABLE "public"."deal_notes" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_notes" TO "service_role";

GRANT ALL ON TABLE "public"."deal_risk_aggregates" TO "anon";

GRANT ALL ON TABLE "public"."deal_risk_aggregates" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_risk_aggregates" TO "service_role";

GRANT ALL ON TABLE "public"."deal_risk_signals" TO "anon";

GRANT ALL ON TABLE "public"."deal_risk_signals" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_risk_signals" TO "service_role";

GRANT ALL ON TABLE "public"."deal_sentiment_trends" TO "anon";

GRANT ALL ON TABLE "public"."deal_sentiment_trends" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_sentiment_trends" TO "service_role";

GRANT ALL ON TABLE "public"."deal_splits" TO "anon";

GRANT ALL ON TABLE "public"."deal_splits" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_splits" TO "service_role";

GRANT ALL ON TABLE "public"."deal_splits_with_users" TO "anon";

GRANT ALL ON TABLE "public"."deal_splits_with_users" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_splits_with_users" TO "service_role";

GRANT ALL ON TABLE "public"."deal_stage_history" TO "anon";

GRANT ALL ON TABLE "public"."deal_stage_history" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_stage_history" TO "service_role";

GRANT ALL ON TABLE "public"."deal_stages" TO "anon";

GRANT ALL ON TABLE "public"."deal_stages" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_stages" TO "service_role";

GRANT ALL ON TABLE "public"."deal_truth_fields" TO "anon";

GRANT ALL ON TABLE "public"."deal_truth_fields" TO "authenticated";

GRANT ALL ON TABLE "public"."deal_truth_fields" TO "service_role";

GRANT ALL ON TABLE "public"."email_attachments" TO "anon";

GRANT ALL ON TABLE "public"."email_attachments" TO "authenticated";

GRANT ALL ON TABLE "public"."email_attachments" TO "service_role";

GRANT ALL ON TABLE "public"."email_categorizations" TO "anon";

GRANT ALL ON TABLE "public"."email_categorizations" TO "authenticated";

GRANT ALL ON TABLE "public"."email_categorizations" TO "service_role";

GRANT ALL ON TABLE "public"."email_journeys" TO "anon";

GRANT ALL ON TABLE "public"."email_journeys" TO "authenticated";

GRANT ALL ON TABLE "public"."email_journeys" TO "service_role";

GRANT ALL ON TABLE "public"."email_label_map" TO "anon";

GRANT ALL ON TABLE "public"."email_label_map" TO "authenticated";

GRANT ALL ON TABLE "public"."email_label_map" TO "service_role";

GRANT ALL ON TABLE "public"."email_labels" TO "anon";

GRANT ALL ON TABLE "public"."email_labels" TO "authenticated";

GRANT ALL ON TABLE "public"."email_labels" TO "service_role";

GRANT ALL ON TABLE "public"."email_logs" TO "anon";

GRANT ALL ON TABLE "public"."email_logs" TO "authenticated";

GRANT ALL ON TABLE "public"."email_logs" TO "service_role";

GRANT ALL ON TABLE "public"."email_sends" TO "anon";

GRANT ALL ON TABLE "public"."email_sends" TO "authenticated";

GRANT ALL ON TABLE "public"."email_sends" TO "service_role";

GRANT ALL ON TABLE "public"."email_templates" TO "anon";

GRANT ALL ON TABLE "public"."email_templates" TO "authenticated";

GRANT ALL ON TABLE "public"."email_templates" TO "service_role";

GRANT ALL ON TABLE "public"."email_threads" TO "anon";

GRANT ALL ON TABLE "public"."email_threads" TO "authenticated";

GRANT ALL ON TABLE "public"."email_threads" TO "service_role";

GRANT ALL ON TABLE "public"."emails" TO "anon";

GRANT ALL ON TABLE "public"."emails" TO "authenticated";

GRANT ALL ON TABLE "public"."emails" TO "service_role";

GRANT ALL ON TABLE "public"."encharge_email_templates" TO "anon";

GRANT ALL ON TABLE "public"."encharge_email_templates" TO "authenticated";

GRANT ALL ON TABLE "public"."encharge_email_templates" TO "service_role";

GRANT ALL ON TABLE "public"."execution_checkpoints" TO "anon";

GRANT ALL ON TABLE "public"."execution_checkpoints" TO "authenticated";

GRANT ALL ON TABLE "public"."execution_checkpoints" TO "service_role";

GRANT ALL ON TABLE "public"."execution_snapshots" TO "anon";

GRANT ALL ON TABLE "public"."execution_snapshots" TO "authenticated";

GRANT ALL ON TABLE "public"."execution_snapshots" TO "service_role";

GRANT ALL ON TABLE "public"."fathom_integrations" TO "anon";

GRANT ALL ON TABLE "public"."fathom_integrations" TO "authenticated";

GRANT ALL ON TABLE "public"."fathom_integrations" TO "service_role";

GRANT ALL ON TABLE "public"."fathom_oauth_states" TO "anon";

GRANT ALL ON TABLE "public"."fathom_oauth_states" TO "authenticated";

GRANT ALL ON TABLE "public"."fathom_oauth_states" TO "service_role";

GRANT ALL ON TABLE "public"."fathom_org_credentials" TO "anon";

GRANT ALL ON TABLE "public"."fathom_org_credentials" TO "authenticated";

GRANT ALL ON TABLE "public"."fathom_org_credentials" TO "service_role";

GRANT ALL ON TABLE "public"."fathom_org_integrations" TO "anon";

GRANT ALL ON TABLE "public"."fathom_org_integrations" TO "authenticated";

GRANT ALL ON TABLE "public"."fathom_org_integrations" TO "service_role";

GRANT ALL ON TABLE "public"."fathom_org_sync_state" TO "anon";

GRANT ALL ON TABLE "public"."fathom_org_sync_state" TO "authenticated";

GRANT ALL ON TABLE "public"."fathom_org_sync_state" TO "service_role";

GRANT ALL ON TABLE "public"."fathom_sync_state" TO "anon";

GRANT ALL ON TABLE "public"."fathom_sync_state" TO "authenticated";

GRANT ALL ON TABLE "public"."fathom_sync_state" TO "service_role";

GRANT ALL ON TABLE "public"."fathom_transcript_retry_jobs" TO "anon";

GRANT ALL ON TABLE "public"."fathom_transcript_retry_jobs" TO "authenticated";

GRANT ALL ON TABLE "public"."fathom_transcript_retry_jobs" TO "service_role";

GRANT ALL ON TABLE "public"."fathom_user_mappings" TO "anon";

GRANT ALL ON TABLE "public"."fathom_user_mappings" TO "authenticated";

GRANT ALL ON TABLE "public"."fathom_user_mappings" TO "service_role";

GRANT ALL ON TABLE "public"."ghost_detection_signals" TO "anon";

GRANT ALL ON TABLE "public"."ghost_detection_signals" TO "authenticated";

GRANT ALL ON TABLE "public"."ghost_detection_signals" TO "service_role";

GRANT ALL ON TABLE "public"."global_topic_sources" TO "anon";

GRANT ALL ON TABLE "public"."global_topic_sources" TO "authenticated";

GRANT ALL ON TABLE "public"."global_topic_sources" TO "service_role";

GRANT ALL ON TABLE "public"."global_topics" TO "anon";

GRANT ALL ON TABLE "public"."global_topics" TO "authenticated";

GRANT ALL ON TABLE "public"."global_topics" TO "service_role";

GRANT ALL ON TABLE "public"."gmail_label_mappings" TO "anon";

GRANT ALL ON TABLE "public"."gmail_label_mappings" TO "authenticated";

GRANT ALL ON TABLE "public"."gmail_label_mappings" TO "service_role";

GRANT ALL ON TABLE "public"."google_calendar_channels" TO "anon";

GRANT ALL ON TABLE "public"."google_calendar_channels" TO "authenticated";

GRANT ALL ON TABLE "public"."google_calendar_channels" TO "service_role";

GRANT ALL ON TABLE "public"."google_calendars" TO "anon";

GRANT ALL ON TABLE "public"."google_calendars" TO "authenticated";

GRANT ALL ON TABLE "public"."google_calendars" TO "service_role";

GRANT ALL ON TABLE "public"."google_docs_templates" TO "anon";

GRANT ALL ON TABLE "public"."google_docs_templates" TO "authenticated";

GRANT ALL ON TABLE "public"."google_docs_templates" TO "service_role";

GRANT ALL ON TABLE "public"."google_drive_folders" TO "anon";

GRANT ALL ON TABLE "public"."google_drive_folders" TO "authenticated";

GRANT ALL ON TABLE "public"."google_drive_folders" TO "service_role";

GRANT ALL ON TABLE "public"."google_email_labels" TO "anon";

GRANT ALL ON TABLE "public"."google_email_labels" TO "authenticated";

GRANT ALL ON TABLE "public"."google_email_labels" TO "service_role";

GRANT ALL ON TABLE "public"."google_oauth_states" TO "anon";

GRANT ALL ON TABLE "public"."google_oauth_states" TO "authenticated";

GRANT ALL ON TABLE "public"."google_oauth_states" TO "service_role";

GRANT ALL ON TABLE "public"."google_service_logs" TO "anon";

GRANT ALL ON TABLE "public"."google_service_logs" TO "authenticated";

GRANT ALL ON TABLE "public"."google_service_logs" TO "service_role";

GRANT ALL ON TABLE "public"."google_task_lists" TO "anon";

GRANT ALL ON TABLE "public"."google_task_lists" TO "authenticated";

GRANT ALL ON TABLE "public"."google_task_lists" TO "service_role";

GRANT ALL ON TABLE "public"."google_task_mappings" TO "anon";

GRANT ALL ON TABLE "public"."google_task_mappings" TO "authenticated";

GRANT ALL ON TABLE "public"."google_task_mappings" TO "service_role";

GRANT ALL ON TABLE "public"."google_tasks_list_configs" TO "anon";

GRANT ALL ON TABLE "public"."google_tasks_list_configs" TO "authenticated";

GRANT ALL ON TABLE "public"."google_tasks_list_configs" TO "service_role";

GRANT ALL ON TABLE "public"."google_tasks_sync_conflicts" TO "anon";

GRANT ALL ON TABLE "public"."google_tasks_sync_conflicts" TO "authenticated";

GRANT ALL ON TABLE "public"."google_tasks_sync_conflicts" TO "service_role";

GRANT ALL ON TABLE "public"."google_tasks_sync_status" TO "anon";

GRANT ALL ON TABLE "public"."google_tasks_sync_status" TO "authenticated";

GRANT ALL ON TABLE "public"."google_tasks_sync_status" TO "service_role";

GRANT ALL ON TABLE "public"."hitl_requests" TO "anon";

GRANT ALL ON TABLE "public"."hitl_requests" TO "authenticated";

GRANT ALL ON TABLE "public"."hitl_requests" TO "service_role";

GRANT ALL ON TABLE "public"."http_request_recordings" TO "anon";

GRANT ALL ON TABLE "public"."http_request_recordings" TO "authenticated";

GRANT ALL ON TABLE "public"."http_request_recordings" TO "service_role";

GRANT ALL ON TABLE "public"."hubspot_oauth_states" TO "anon";

GRANT ALL ON TABLE "public"."hubspot_oauth_states" TO "authenticated";

GRANT ALL ON TABLE "public"."hubspot_oauth_states" TO "service_role";

GRANT ALL ON TABLE "public"."hubspot_object_mappings" TO "anon";

GRANT ALL ON TABLE "public"."hubspot_object_mappings" TO "authenticated";

GRANT ALL ON TABLE "public"."hubspot_object_mappings" TO "service_role";

GRANT ALL ON TABLE "public"."hubspot_org_credentials" TO "anon";

GRANT ALL ON TABLE "public"."hubspot_org_credentials" TO "authenticated";

GRANT ALL ON TABLE "public"."hubspot_org_credentials" TO "service_role";

GRANT ALL ON TABLE "public"."hubspot_org_integrations" TO "anon";

GRANT ALL ON TABLE "public"."hubspot_org_integrations" TO "authenticated";

GRANT ALL ON TABLE "public"."hubspot_org_integrations" TO "service_role";

GRANT ALL ON TABLE "public"."hubspot_org_sync_state" TO "anon";

GRANT ALL ON TABLE "public"."hubspot_org_sync_state" TO "authenticated";

GRANT ALL ON TABLE "public"."hubspot_org_sync_state" TO "service_role";

GRANT ALL ON TABLE "public"."hubspot_settings" TO "anon";

GRANT ALL ON TABLE "public"."hubspot_settings" TO "authenticated";

GRANT ALL ON TABLE "public"."hubspot_settings" TO "service_role";

GRANT ALL ON TABLE "public"."hubspot_webhook_events" TO "anon";

GRANT ALL ON TABLE "public"."hubspot_webhook_events" TO "authenticated";

GRANT ALL ON TABLE "public"."hubspot_webhook_events" TO "service_role";

GRANT ALL ON TABLE "public"."impersonation_logs" TO "anon";

GRANT ALL ON TABLE "public"."impersonation_logs" TO "authenticated";

GRANT ALL ON TABLE "public"."impersonation_logs" TO "service_role";

GRANT ALL ON TABLE "public"."integration_alerts" TO "anon";

GRANT ALL ON TABLE "public"."integration_alerts" TO "authenticated";

GRANT ALL ON TABLE "public"."integration_alerts" TO "service_role";

GRANT ALL ON TABLE "public"."integration_test_results" TO "anon";

GRANT ALL ON TABLE "public"."integration_test_results" TO "authenticated";

GRANT ALL ON TABLE "public"."integration_test_results" TO "service_role";

GRANT ALL ON TABLE "public"."integration_health_summary" TO "anon";

GRANT ALL ON TABLE "public"."integration_health_summary" TO "authenticated";

GRANT ALL ON TABLE "public"."integration_health_summary" TO "service_role";

GRANT ALL ON TABLE "public"."integration_sync_logs" TO "anon";

GRANT ALL ON TABLE "public"."integration_sync_logs" TO "authenticated";

GRANT ALL ON TABLE "public"."integration_sync_logs" TO "service_role";

GRANT ALL ON TABLE "public"."internal_email_domains" TO "anon";

GRANT ALL ON TABLE "public"."internal_email_domains" TO "authenticated";

GRANT ALL ON TABLE "public"."internal_email_domains" TO "service_role";

GRANT ALL ON TABLE "public"."internal_users" TO "anon";

GRANT ALL ON TABLE "public"."internal_users" TO "authenticated";

GRANT ALL ON TABLE "public"."internal_users" TO "service_role";

GRANT ALL ON TABLE "public"."intervention_templates" TO "anon";

GRANT ALL ON TABLE "public"."intervention_templates" TO "authenticated";

GRANT ALL ON TABLE "public"."intervention_templates" TO "service_role";

GRANT ALL ON TABLE "public"."justcall_integration_secrets" TO "anon";

GRANT ALL ON TABLE "public"."justcall_integration_secrets" TO "authenticated";

GRANT ALL ON TABLE "public"."justcall_integration_secrets" TO "service_role";

GRANT ALL ON TABLE "public"."justcall_integrations" TO "anon";

GRANT ALL ON TABLE "public"."justcall_integrations" TO "authenticated";

GRANT ALL ON TABLE "public"."justcall_integrations" TO "service_role";

GRANT ALL ON TABLE "public"."justcall_oauth_states" TO "anon";

GRANT ALL ON TABLE "public"."justcall_oauth_states" TO "authenticated";

GRANT ALL ON TABLE "public"."justcall_oauth_states" TO "service_role";

GRANT ALL ON TABLE "public"."meetings_waitlist" TO "anon";

GRANT ALL ON TABLE "public"."meetings_waitlist" TO "authenticated";

GRANT ALL ON TABLE "public"."meetings_waitlist" TO "service_role";

GRANT ALL ON TABLE "public"."page_views" TO "anon";

GRANT ALL ON TABLE "public"."page_views" TO "authenticated";

GRANT ALL ON TABLE "public"."page_views" TO "service_role";

GRANT ALL ON TABLE "public"."partial_signups" TO "anon";

GRANT ALL ON TABLE "public"."partial_signups" TO "authenticated";

GRANT ALL ON TABLE "public"."partial_signups" TO "service_role";

GRANT ALL ON TABLE "public"."landing_page_analytics" TO "anon";

GRANT ALL ON TABLE "public"."landing_page_analytics" TO "authenticated";

GRANT ALL ON TABLE "public"."landing_page_analytics" TO "service_role";

GRANT ALL ON TABLE "public"."latest_integration_test_results" TO "anon";

GRANT ALL ON TABLE "public"."latest_integration_test_results" TO "authenticated";

GRANT ALL ON TABLE "public"."latest_integration_test_results" TO "service_role";

GRANT ALL ON TABLE "public"."launch_checklist_items" TO "anon";

GRANT ALL ON TABLE "public"."launch_checklist_items" TO "authenticated";

GRANT ALL ON TABLE "public"."launch_checklist_items" TO "service_role";

GRANT ALL ON TABLE "public"."lead_events" TO "anon";

GRANT ALL ON TABLE "public"."lead_events" TO "authenticated";

GRANT ALL ON TABLE "public"."lead_events" TO "service_role";

GRANT ALL ON TABLE "public"."lead_prep_notes" TO "anon";

GRANT ALL ON TABLE "public"."lead_prep_notes" TO "authenticated";

GRANT ALL ON TABLE "public"."lead_prep_notes" TO "service_role";

GRANT ALL ON TABLE "public"."lead_sources" TO "anon";

GRANT ALL ON TABLE "public"."lead_sources" TO "authenticated";

GRANT ALL ON TABLE "public"."lead_sources" TO "service_role";

GRANT ALL ON TABLE "public"."leads" TO "anon";

GRANT ALL ON TABLE "public"."leads" TO "authenticated";

GRANT ALL ON TABLE "public"."leads" TO "service_role";

GRANT ALL ON TABLE "public"."lead_source_summary" TO "anon";

GRANT ALL ON TABLE "public"."lead_source_summary" TO "authenticated";

GRANT ALL ON TABLE "public"."lead_source_summary" TO "service_role";

GRANT ALL ON TABLE "public"."mcp_connections" TO "anon";

GRANT ALL ON TABLE "public"."mcp_connections" TO "authenticated";

GRANT ALL ON TABLE "public"."mcp_connections" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_action_items" TO "anon";

GRANT ALL ON TABLE "public"."meeting_action_items" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_action_items" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_aggregate_metrics" TO "anon";

GRANT ALL ON TABLE "public"."meeting_aggregate_metrics" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_aggregate_metrics" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_attendees" TO "anon";

GRANT ALL ON TABLE "public"."meeting_attendees" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_attendees" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_classifications" TO "anon";

GRANT ALL ON TABLE "public"."meeting_classifications" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_classifications" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_contacts" TO "anon";

GRANT ALL ON TABLE "public"."meeting_contacts" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_contacts" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_content_topics" TO "anon";

GRANT ALL ON TABLE "public"."meeting_content_topics" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_content_topics" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_documents" TO "anon";

GRANT ALL ON TABLE "public"."meeting_documents" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_documents" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_file_search_index" TO "anon";

GRANT ALL ON TABLE "public"."meeting_file_search_index" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_file_search_index" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_generated_content" TO "anon";

GRANT ALL ON TABLE "public"."meeting_generated_content" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_generated_content" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_index_queue" TO "anon";

GRANT ALL ON TABLE "public"."meeting_index_queue" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_index_queue" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_intelligence_queries" TO "anon";

GRANT ALL ON TABLE "public"."meeting_intelligence_queries" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_intelligence_queries" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_metrics" TO "anon";

GRANT ALL ON TABLE "public"."meeting_metrics" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_metrics" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_scorecards" TO "anon";

GRANT ALL ON TABLE "public"."meeting_scorecards" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_scorecards" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_structured_summaries" TO "anon";

GRANT ALL ON TABLE "public"."meeting_structured_summaries" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_structured_summaries" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_topics" TO "anon";

GRANT ALL ON TABLE "public"."meeting_topics" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_topics" TO "service_role";

GRANT ALL ON TABLE "public"."meeting_workflow_results" TO "anon";

GRANT ALL ON TABLE "public"."meeting_workflow_results" TO "authenticated";

GRANT ALL ON TABLE "public"."meeting_workflow_results" TO "service_role";

GRANT ALL ON TABLE "public"."meetingbaas_calendars" TO "anon";

GRANT ALL ON TABLE "public"."meetingbaas_calendars" TO "authenticated";

GRANT ALL ON TABLE "public"."meetingbaas_calendars" TO "service_role";

GRANT ALL ON TABLE "public"."meta_ads_analytics" TO "anon";

GRANT ALL ON TABLE "public"."meta_ads_analytics" TO "authenticated";

GRANT ALL ON TABLE "public"."meta_ads_analytics" TO "service_role";

GRANT ALL ON TABLE "public"."meta_ads_daily_summary" TO "anon";

GRANT ALL ON TABLE "public"."meta_ads_daily_summary" TO "authenticated";

GRANT ALL ON TABLE "public"."meta_ads_daily_summary" TO "service_role";

GRANT ALL ON TABLE "public"."monthly_ai_usage" TO "anon";

GRANT ALL ON TABLE "public"."monthly_ai_usage" TO "authenticated";

GRANT ALL ON TABLE "public"."monthly_ai_usage" TO "service_role";

GRANT ALL ON TABLE "public"."organization_subscriptions" TO "anon";

GRANT ALL ON TABLE "public"."organization_subscriptions" TO "authenticated";

GRANT ALL ON TABLE "public"."organization_subscriptions" TO "service_role";

GRANT ALL ON TABLE "public"."subscription_plans" TO "anon";

GRANT ALL ON TABLE "public"."subscription_plans" TO "authenticated";

GRANT ALL ON TABLE "public"."subscription_plans" TO "service_role";

GRANT ALL ON TABLE "public"."subscription_facts_view" TO "anon";

GRANT ALL ON TABLE "public"."subscription_facts_view" TO "authenticated";

GRANT ALL ON TABLE "public"."subscription_facts_view" TO "service_role";

GRANT ALL ON TABLE "public"."mrr_current_view" TO "anon";

GRANT ALL ON TABLE "public"."mrr_current_view" TO "authenticated";

GRANT ALL ON TABLE "public"."mrr_current_view" TO "service_role";

GRANT ALL ON TABLE "public"."mrr_movement_view" TO "anon";

GRANT ALL ON TABLE "public"."mrr_movement_view" TO "authenticated";

GRANT ALL ON TABLE "public"."mrr_movement_view" TO "service_role";

GRANT ALL ON TABLE "public"."next_action_suggestions" TO "anon";

GRANT ALL ON TABLE "public"."next_action_suggestions" TO "authenticated";

GRANT ALL ON TABLE "public"."next_action_suggestions" TO "service_role";

GRANT ALL ON TABLE "public"."node_executions" TO "anon";

GRANT ALL ON TABLE "public"."node_executions" TO "authenticated";

GRANT ALL ON TABLE "public"."node_executions" TO "service_role";

GRANT ALL ON TABLE "public"."node_fixtures" TO "anon";

GRANT ALL ON TABLE "public"."node_fixtures" TO "authenticated";

GRANT ALL ON TABLE "public"."node_fixtures" TO "service_role";

GRANT ALL ON TABLE "public"."notetaker_user_settings" TO "anon";

GRANT ALL ON TABLE "public"."notetaker_user_settings" TO "authenticated";

GRANT ALL ON TABLE "public"."notetaker_user_settings" TO "service_role";

GRANT ALL ON TABLE "public"."notifications" TO "anon";

GRANT ALL ON TABLE "public"."notifications" TO "authenticated";

GRANT ALL ON TABLE "public"."notifications" TO "service_role";

GRANT ALL ON TABLE "public"."notification_counts_by_user" TO "authenticated";

GRANT ALL ON TABLE "public"."notification_counts_by_user" TO "service_role";

GRANT ALL ON TABLE "public"."notification_feedback" TO "anon";

GRANT ALL ON TABLE "public"."notification_feedback" TO "authenticated";

GRANT ALL ON TABLE "public"."notification_feedback" TO "service_role";

GRANT ALL ON TABLE "public"."notification_flood_alerts" TO "authenticated";

GRANT ALL ON TABLE "public"."notification_flood_alerts" TO "service_role";

GRANT ALL ON TABLE "public"."notification_interactions" TO "anon";

GRANT ALL ON TABLE "public"."notification_interactions" TO "authenticated";

GRANT ALL ON TABLE "public"."notification_interactions" TO "service_role";

GRANT ALL ON TABLE "public"."notification_queue" TO "anon";

GRANT ALL ON TABLE "public"."notification_queue" TO "authenticated";

GRANT ALL ON TABLE "public"."notification_queue" TO "service_role";

GRANT ALL ON TABLE "public"."notification_rate_limits" TO "anon";

GRANT ALL ON TABLE "public"."notification_rate_limits" TO "authenticated";

GRANT ALL ON TABLE "public"."notification_rate_limits" TO "service_role";

GRANT ALL ON TABLE "public"."notification_rate_limit_status" TO "authenticated";

GRANT ALL ON TABLE "public"."notification_rate_limit_status" TO "service_role";

GRANT ALL ON TABLE "public"."notification_type_breakdown" TO "authenticated";

GRANT ALL ON TABLE "public"."notification_type_breakdown" TO "service_role";

GRANT ALL ON TABLE "public"."org_ai_preferences" TO "anon";

GRANT ALL ON TABLE "public"."org_ai_preferences" TO "authenticated";

GRANT ALL ON TABLE "public"."org_ai_preferences" TO "service_role";

GRANT ALL ON TABLE "public"."org_call_types" TO "anon";

GRANT ALL ON TABLE "public"."org_call_types" TO "authenticated";

GRANT ALL ON TABLE "public"."org_call_types" TO "service_role";

GRANT ALL ON TABLE "public"."org_email_categorization_settings" TO "anon";

GRANT ALL ON TABLE "public"."org_email_categorization_settings" TO "authenticated";

GRANT ALL ON TABLE "public"."org_email_categorization_settings" TO "service_role";

GRANT ALL ON TABLE "public"."org_file_search_stores" TO "anon";

GRANT ALL ON TABLE "public"."org_file_search_stores" TO "authenticated";

GRANT ALL ON TABLE "public"."org_file_search_stores" TO "service_role";

GRANT ALL ON TABLE "public"."org_proposal_workflows" TO "anon";

GRANT ALL ON TABLE "public"."org_proposal_workflows" TO "authenticated";

GRANT ALL ON TABLE "public"."org_proposal_workflows" TO "service_role";

GRANT ALL ON TABLE "public"."organization_context" TO "anon";

GRANT ALL ON TABLE "public"."organization_context" TO "authenticated";

GRANT ALL ON TABLE "public"."organization_context" TO "service_role";

GRANT ALL ON TABLE "public"."organization_enrichment" TO "anon";

GRANT ALL ON TABLE "public"."organization_enrichment" TO "authenticated";

GRANT ALL ON TABLE "public"."organization_enrichment" TO "service_role";

GRANT ALL ON TABLE "public"."organization_feature_flags" TO "anon";

GRANT ALL ON TABLE "public"."organization_feature_flags" TO "authenticated";

GRANT ALL ON TABLE "public"."organization_feature_flags" TO "service_role";

GRANT ALL ON TABLE "public"."organization_invitations" TO "anon";

GRANT ALL ON TABLE "public"."organization_invitations" TO "authenticated";

GRANT ALL ON TABLE "public"."organization_invitations" TO "service_role";

GRANT ALL ON TABLE "public"."organization_skills" TO "anon";

GRANT ALL ON TABLE "public"."organization_skills" TO "authenticated";

GRANT ALL ON TABLE "public"."organization_skills" TO "service_role";

GRANT ALL ON TABLE "public"."organization_skills_history" TO "anon";

GRANT ALL ON TABLE "public"."organization_skills_history" TO "authenticated";

GRANT ALL ON TABLE "public"."organization_skills_history" TO "service_role";

GRANT ALL ON TABLE "public"."organization_usage" TO "anon";

GRANT ALL ON TABLE "public"."organization_usage" TO "authenticated";

GRANT ALL ON TABLE "public"."organization_usage" TO "service_role";

GRANT ALL ON TABLE "public"."pipeline_automation_log" TO "anon";

GRANT ALL ON TABLE "public"."pipeline_automation_log" TO "authenticated";

GRANT ALL ON TABLE "public"."pipeline_automation_log" TO "service_role";

GRANT ALL ON TABLE "public"."pipeline_stage_recommendations" TO "anon";

GRANT ALL ON TABLE "public"."pipeline_stage_recommendations" TO "authenticated";

GRANT ALL ON TABLE "public"."pipeline_stage_recommendations" TO "service_role";

GRANT ALL ON TABLE "public"."platform_skills" TO "anon";

GRANT ALL ON TABLE "public"."platform_skills" TO "authenticated";

GRANT ALL ON TABLE "public"."platform_skills" TO "service_role";

GRANT ALL ON TABLE "public"."platform_skills_history" TO "anon";

GRANT ALL ON TABLE "public"."platform_skills_history" TO "authenticated";

GRANT ALL ON TABLE "public"."platform_skills_history" TO "service_role";

GRANT ALL ON TABLE "public"."pricing_plans" TO "anon";

GRANT ALL ON TABLE "public"."pricing_plans" TO "authenticated";

GRANT ALL ON TABLE "public"."pricing_plans" TO "service_role";

GRANT ALL ON TABLE "public"."process_map_coverage_snapshots" TO "anon";

GRANT ALL ON TABLE "public"."process_map_coverage_snapshots" TO "authenticated";

GRANT ALL ON TABLE "public"."process_map_coverage_snapshots" TO "service_role";

GRANT ALL ON TABLE "public"."process_map_fixtures" TO "anon";

GRANT ALL ON TABLE "public"."process_map_fixtures" TO "authenticated";

GRANT ALL ON TABLE "public"."process_map_fixtures" TO "service_role";

GRANT ALL ON TABLE "public"."process_map_mocks" TO "anon";

GRANT ALL ON TABLE "public"."process_map_mocks" TO "authenticated";

GRANT ALL ON TABLE "public"."process_map_mocks" TO "service_role";

GRANT ALL ON TABLE "public"."process_map_scenario_runs" TO "anon";

GRANT ALL ON TABLE "public"."process_map_scenario_runs" TO "authenticated";

GRANT ALL ON TABLE "public"."process_map_scenario_runs" TO "service_role";

GRANT ALL ON TABLE "public"."process_map_step_results" TO "anon";

GRANT ALL ON TABLE "public"."process_map_step_results" TO "authenticated";

GRANT ALL ON TABLE "public"."process_map_step_results" TO "service_role";

GRANT ALL ON TABLE "public"."process_map_test_runs" TO "anon";

GRANT ALL ON TABLE "public"."process_map_test_runs" TO "authenticated";

GRANT ALL ON TABLE "public"."process_map_test_runs" TO "service_role";

GRANT ALL ON TABLE "public"."process_map_test_scenarios" TO "anon";

GRANT ALL ON TABLE "public"."process_map_test_scenarios" TO "authenticated";

GRANT ALL ON TABLE "public"."process_map_test_scenarios" TO "service_role";

GRANT ALL ON TABLE "public"."process_map_workflows" TO "anon";

GRANT ALL ON TABLE "public"."process_map_workflows" TO "authenticated";

GRANT ALL ON TABLE "public"."process_map_workflows" TO "service_role";

GRANT ALL ON TABLE "public"."process_maps" TO "anon";

GRANT ALL ON TABLE "public"."process_maps" TO "authenticated";

GRANT ALL ON TABLE "public"."process_maps" TO "service_role";

GRANT ALL ON TABLE "public"."proposal_templates" TO "anon";

GRANT ALL ON TABLE "public"."proposal_templates" TO "authenticated";

GRANT ALL ON TABLE "public"."proposal_templates" TO "service_role";

GRANT ALL ON TABLE "public"."proposals" TO "anon";

GRANT ALL ON TABLE "public"."proposals" TO "authenticated";

GRANT ALL ON TABLE "public"."proposals" TO "service_role";

GRANT ALL ON TABLE "public"."rate_limit" TO "anon";

GRANT ALL ON TABLE "public"."rate_limit" TO "authenticated";

GRANT ALL ON TABLE "public"."rate_limit" TO "service_role";

GRANT ALL ON TABLE "public"."recent_notification_activity" TO "authenticated";

GRANT ALL ON TABLE "public"."recent_notification_activity" TO "service_role";

GRANT ALL ON TABLE "public"."recording_rules" TO "anon";

GRANT ALL ON TABLE "public"."recording_rules" TO "authenticated";

GRANT ALL ON TABLE "public"."recording_rules" TO "service_role";

GRANT ALL ON TABLE "public"."recordings" TO "anon";

GRANT ALL ON TABLE "public"."recordings" TO "authenticated";

GRANT ALL ON TABLE "public"."recordings" TO "service_role";

GRANT ALL ON TABLE "public"."reengagement_log" TO "anon";

GRANT ALL ON TABLE "public"."reengagement_log" TO "authenticated";

GRANT ALL ON TABLE "public"."reengagement_log" TO "service_role";

GRANT ALL ON TABLE "public"."relationship_health_history" TO "anon";

GRANT ALL ON TABLE "public"."relationship_health_history" TO "authenticated";

GRANT ALL ON TABLE "public"."relationship_health_history" TO "service_role";

GRANT ALL ON TABLE "public"."relationship_health_scores" TO "anon";

GRANT ALL ON TABLE "public"."relationship_health_scores" TO "authenticated";

GRANT ALL ON TABLE "public"."relationship_health_scores" TO "service_role";

GRANT ALL ON TABLE "public"."roadmap_comments" TO "anon";

GRANT ALL ON TABLE "public"."roadmap_comments" TO "authenticated";

GRANT ALL ON TABLE "public"."roadmap_comments" TO "service_role";

GRANT ALL ON TABLE "public"."roadmap_suggestions" TO "anon";

GRANT ALL ON TABLE "public"."roadmap_suggestions" TO "authenticated";

GRANT ALL ON TABLE "public"."roadmap_suggestions" TO "service_role";

GRANT ALL ON SEQUENCE "public"."roadmap_suggestions_ticket_id_seq" TO "anon";

GRANT ALL ON SEQUENCE "public"."roadmap_suggestions_ticket_id_seq" TO "authenticated";

GRANT ALL ON SEQUENCE "public"."roadmap_suggestions_ticket_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."roadmap_votes" TO "anon";

GRANT ALL ON TABLE "public"."roadmap_votes" TO "authenticated";

GRANT ALL ON TABLE "public"."roadmap_votes" TO "service_role";

GRANT ALL ON TABLE "public"."savvycal_integration_secrets" TO "anon";

GRANT ALL ON TABLE "public"."savvycal_integration_secrets" TO "authenticated";

GRANT ALL ON TABLE "public"."savvycal_integration_secrets" TO "service_role";

GRANT ALL ON TABLE "public"."savvycal_integrations" TO "anon";

GRANT ALL ON TABLE "public"."savvycal_integrations" TO "authenticated";

GRANT ALL ON TABLE "public"."savvycal_integrations" TO "service_role";

GRANT ALL ON TABLE "public"."savvycal_link_mappings" TO "anon";

GRANT ALL ON TABLE "public"."savvycal_link_mappings" TO "authenticated";

GRANT ALL ON TABLE "public"."savvycal_link_mappings" TO "service_role";

GRANT ALL ON TABLE "public"."savvycal_source_mappings" TO "anon";

GRANT ALL ON TABLE "public"."savvycal_source_mappings" TO "authenticated";

GRANT ALL ON TABLE "public"."savvycal_source_mappings" TO "service_role";

GRANT ALL ON TABLE "public"."scenario_fixtures" TO "anon";

GRANT ALL ON TABLE "public"."scenario_fixtures" TO "authenticated";

GRANT ALL ON TABLE "public"."scenario_fixtures" TO "service_role";

GRANT ALL ON TABLE "public"."sentiment_alerts" TO "anon";

GRANT ALL ON TABLE "public"."sentiment_alerts" TO "authenticated";

GRANT ALL ON TABLE "public"."sentiment_alerts" TO "service_role";

GRANT ALL ON TABLE "public"."sentry_bridge_config" TO "anon";

GRANT ALL ON TABLE "public"."sentry_bridge_config" TO "authenticated";

GRANT ALL ON TABLE "public"."sentry_bridge_config" TO "service_role";

GRANT ALL ON TABLE "public"."sentry_bridge_metrics" TO "anon";

GRANT ALL ON TABLE "public"."sentry_bridge_metrics" TO "authenticated";

GRANT ALL ON TABLE "public"."sentry_bridge_metrics" TO "service_role";

GRANT ALL ON TABLE "public"."sentry_dead_letter_queue" TO "anon";

GRANT ALL ON TABLE "public"."sentry_dead_letter_queue" TO "authenticated";

GRANT ALL ON TABLE "public"."sentry_dead_letter_queue" TO "service_role";

GRANT ALL ON TABLE "public"."sentry_issue_mappings" TO "anon";

GRANT ALL ON TABLE "public"."sentry_issue_mappings" TO "authenticated";

GRANT ALL ON TABLE "public"."sentry_issue_mappings" TO "service_role";

GRANT ALL ON TABLE "public"."sentry_routing_rules" TO "anon";

GRANT ALL ON TABLE "public"."sentry_routing_rules" TO "authenticated";

GRANT ALL ON TABLE "public"."sentry_routing_rules" TO "service_role";

GRANT ALL ON TABLE "public"."sentry_triage_queue" TO "anon";

GRANT ALL ON TABLE "public"."sentry_triage_queue" TO "authenticated";

GRANT ALL ON TABLE "public"."sentry_triage_queue" TO "service_role";

GRANT ALL ON TABLE "public"."sentry_webhook_events" TO "anon";

GRANT ALL ON TABLE "public"."sentry_webhook_events" TO "authenticated";

GRANT ALL ON TABLE "public"."sentry_webhook_events" TO "service_role";

GRANT ALL ON TABLE "public"."sentry_webhook_queue" TO "anon";

GRANT ALL ON TABLE "public"."sentry_webhook_queue" TO "authenticated";

GRANT ALL ON TABLE "public"."sentry_webhook_queue" TO "service_role";

GRANT ALL ON TABLE "public"."sequence_executions" TO "anon";

GRANT ALL ON TABLE "public"."sequence_executions" TO "authenticated";

GRANT ALL ON TABLE "public"."sequence_executions" TO "service_role";

GRANT ALL ON TABLE "public"."sequence_hitl_requests" TO "anon";

GRANT ALL ON TABLE "public"."sequence_hitl_requests" TO "authenticated";

GRANT ALL ON TABLE "public"."sequence_hitl_requests" TO "service_role";

GRANT ALL ON TABLE "public"."sequence_references_archive" TO "anon";

GRANT ALL ON TABLE "public"."sequence_references_archive" TO "authenticated";

GRANT ALL ON TABLE "public"."sequence_references_archive" TO "service_role";

GRANT ALL ON TABLE "public"."sequence_token_budgets" TO "anon";

GRANT ALL ON TABLE "public"."sequence_token_budgets" TO "authenticated";

GRANT ALL ON TABLE "public"."sequence_token_budgets" TO "service_role";

GRANT ALL ON TABLE "public"."skill_output_storage" TO "anon";

GRANT ALL ON TABLE "public"."skill_output_storage" TO "authenticated";

GRANT ALL ON TABLE "public"."skill_output_storage" TO "service_role";

GRANT ALL ON TABLE "public"."slack_channels" TO "anon";

GRANT ALL ON TABLE "public"."slack_channels" TO "authenticated";

GRANT ALL ON TABLE "public"."slack_channels" TO "service_role";

GRANT ALL ON TABLE "public"."slack_deal_rooms" TO "anon";

GRANT ALL ON TABLE "public"."slack_deal_rooms" TO "authenticated";

GRANT ALL ON TABLE "public"."slack_deal_rooms" TO "service_role";

GRANT ALL ON TABLE "public"."slack_integrations" TO "anon";

GRANT ALL ON TABLE "public"."slack_integrations" TO "authenticated";

GRANT ALL ON TABLE "public"."slack_integrations" TO "service_role";

GRANT ALL ON TABLE "public"."slack_notification_settings" TO "anon";

GRANT ALL ON TABLE "public"."slack_notification_settings" TO "authenticated";

GRANT ALL ON TABLE "public"."slack_notification_settings" TO "service_role";

GRANT ALL ON TABLE "public"."slack_notifications_sent" TO "anon";

GRANT ALL ON TABLE "public"."slack_notifications_sent" TO "authenticated";

GRANT ALL ON TABLE "public"."slack_notifications_sent" TO "service_role";

GRANT ALL ON TABLE "public"."slack_org_settings" TO "anon";

GRANT ALL ON TABLE "public"."slack_org_settings" TO "authenticated";

GRANT ALL ON TABLE "public"."slack_org_settings" TO "service_role";

GRANT ALL ON TABLE "public"."slack_user_mappings" TO "anon";

GRANT ALL ON TABLE "public"."slack_user_mappings" TO "authenticated";

GRANT ALL ON TABLE "public"."slack_user_mappings" TO "service_role";

GRANT ALL ON TABLE "public"."smart_task_templates" TO "anon";

GRANT ALL ON TABLE "public"."smart_task_templates" TO "authenticated";

GRANT ALL ON TABLE "public"."smart_task_templates" TO "service_role";

GRANT ALL ON TABLE "public"."solutions" TO "anon";

GRANT ALL ON TABLE "public"."solutions" TO "authenticated";

GRANT ALL ON TABLE "public"."solutions" TO "service_role";

GRANT ALL ON TABLE "public"."stages" TO "anon";

GRANT ALL ON TABLE "public"."stages" TO "authenticated";

GRANT ALL ON TABLE "public"."stages" TO "service_role";

GRANT ALL ON TABLE "public"."subscription_seat_usage" TO "anon";

GRANT ALL ON TABLE "public"."subscription_seat_usage" TO "authenticated";

GRANT ALL ON TABLE "public"."subscription_seat_usage" TO "service_role";

GRANT ALL ON TABLE "public"."system_config" TO "anon";

GRANT ALL ON TABLE "public"."system_config" TO "authenticated";

GRANT ALL ON TABLE "public"."system_config" TO "service_role";

GRANT ALL ON TABLE "public"."targets" TO "anon";

GRANT ALL ON TABLE "public"."targets" TO "authenticated";

GRANT ALL ON TABLE "public"."targets" TO "service_role";

GRANT ALL ON TABLE "public"."task_notifications" TO "anon";

GRANT ALL ON TABLE "public"."task_notifications" TO "authenticated";

GRANT ALL ON TABLE "public"."task_notifications" TO "service_role";

GRANT ALL ON TABLE "public"."tasks" TO "anon";

GRANT ALL ON TABLE "public"."tasks" TO "authenticated";

GRANT ALL ON TABLE "public"."tasks" TO "service_role";

GRANT ALL ON TABLE "public"."team_meeting_analytics" TO "anon";

GRANT ALL ON TABLE "public"."team_meeting_analytics" TO "authenticated";

GRANT ALL ON TABLE "public"."team_meeting_analytics" TO "service_role";

GRANT ALL ON TABLE "public"."team_members" TO "anon";

GRANT ALL ON TABLE "public"."team_members" TO "authenticated";

GRANT ALL ON TABLE "public"."team_members" TO "service_role";

GRANT ALL ON TABLE "public"."teams" TO "anon";

GRANT ALL ON TABLE "public"."teams" TO "authenticated";

GRANT ALL ON TABLE "public"."teams" TO "service_role";

GRANT ALL ON TABLE "public"."topic_aggregation_queue" TO "anon";

GRANT ALL ON TABLE "public"."topic_aggregation_queue" TO "authenticated";

GRANT ALL ON TABLE "public"."topic_aggregation_queue" TO "service_role";

GRANT ALL ON TABLE "public"."usage_events" TO "anon";

GRANT ALL ON TABLE "public"."usage_events" TO "authenticated";

GRANT ALL ON TABLE "public"."usage_events" TO "service_role";

GRANT ALL ON TABLE "public"."user_activity_events" TO "anon";

GRANT ALL ON TABLE "public"."user_activity_events" TO "authenticated";

GRANT ALL ON TABLE "public"."user_activity_events" TO "service_role";

GRANT ALL ON TABLE "public"."user_ai_feature_settings" TO "anon";

GRANT ALL ON TABLE "public"."user_ai_feature_settings" TO "authenticated";

GRANT ALL ON TABLE "public"."user_ai_feature_settings" TO "service_role";

GRANT ALL ON TABLE "public"."user_ai_preferences" TO "anon";

GRANT ALL ON TABLE "public"."user_ai_preferences" TO "authenticated";

GRANT ALL ON TABLE "public"."user_ai_preferences" TO "service_role";

GRANT ALL ON TABLE "public"."user_coaching_preferences" TO "anon";

GRANT ALL ON TABLE "public"."user_coaching_preferences" TO "authenticated";

GRANT ALL ON TABLE "public"."user_coaching_preferences" TO "service_role";

GRANT ALL ON TABLE "public"."user_engagement_metrics" TO "anon";

GRANT ALL ON TABLE "public"."user_engagement_metrics" TO "authenticated";

GRANT ALL ON TABLE "public"."user_engagement_metrics" TO "service_role";

GRANT ALL ON TABLE "public"."user_file_search_stores" TO "anon";

GRANT ALL ON TABLE "public"."user_file_search_stores" TO "authenticated";

GRANT ALL ON TABLE "public"."user_file_search_stores" TO "service_role";

GRANT ALL ON TABLE "public"."user_notifications" TO "anon";

GRANT ALL ON TABLE "public"."user_notifications" TO "authenticated";

GRANT ALL ON TABLE "public"."user_notifications" TO "service_role";

GRANT ALL ON TABLE "public"."user_preferences" TO "anon";

GRANT ALL ON TABLE "public"."user_preferences" TO "authenticated";

GRANT ALL ON TABLE "public"."user_preferences" TO "service_role";

GRANT ALL ON TABLE "public"."user_profiles" TO "anon";

GRANT ALL ON TABLE "public"."user_profiles" TO "authenticated";

GRANT ALL ON TABLE "public"."user_profiles" TO "service_role";

GRANT ALL ON TABLE "public"."user_roles" TO "anon";

GRANT ALL ON TABLE "public"."user_roles" TO "authenticated";

GRANT ALL ON TABLE "public"."user_roles" TO "service_role";

GRANT ALL ON TABLE "public"."user_settings" TO "anon";

GRANT ALL ON TABLE "public"."user_settings" TO "authenticated";

GRANT ALL ON TABLE "public"."user_settings" TO "service_role";

GRANT ALL ON TABLE "public"."user_sync_status" TO "anon";

GRANT ALL ON TABLE "public"."user_sync_status" TO "authenticated";

GRANT ALL ON TABLE "public"."user_sync_status" TO "service_role";

GRANT ALL ON TABLE "public"."user_task_list_configs" TO "anon";

GRANT ALL ON TABLE "public"."user_task_list_configs" TO "authenticated";

GRANT ALL ON TABLE "public"."user_task_list_configs" TO "service_role";

GRANT ALL ON TABLE "public"."user_tone_settings" TO "anon";

GRANT ALL ON TABLE "public"."user_tone_settings" TO "authenticated";

GRANT ALL ON TABLE "public"."user_tone_settings" TO "service_role";

GRANT ALL ON TABLE "public"."user_weekly_cohorts" TO "authenticated";

GRANT ALL ON TABLE "public"."user_weekly_cohorts" TO "service_role";

GRANT ALL ON TABLE "public"."user_writing_styles" TO "anon";

GRANT ALL ON TABLE "public"."user_writing_styles" TO "authenticated";

GRANT ALL ON TABLE "public"."user_writing_styles" TO "service_role";

GRANT ALL ON TABLE "public"."v_failed_transcript_retries" TO "anon";

GRANT ALL ON TABLE "public"."v_failed_transcript_retries" TO "authenticated";

GRANT ALL ON TABLE "public"."v_failed_transcript_retries" TO "service_role";

GRANT ALL ON TABLE "public"."v_pending_transcript_retries" TO "anon";

GRANT ALL ON TABLE "public"."v_pending_transcript_retries" TO "authenticated";

GRANT ALL ON TABLE "public"."v_pending_transcript_retries" TO "service_role";

GRANT ALL ON TABLE "public"."v_transcript_retry_stats" TO "anon";

GRANT ALL ON TABLE "public"."v_transcript_retry_stats" TO "authenticated";

GRANT ALL ON TABLE "public"."v_transcript_retry_stats" TO "service_role";

GRANT ALL ON TABLE "public"."variable_storage" TO "anon";

GRANT ALL ON TABLE "public"."variable_storage" TO "authenticated";

GRANT ALL ON TABLE "public"."variable_storage" TO "service_role";

GRANT ALL ON TABLE "public"."voice_recordings" TO "anon";

GRANT ALL ON TABLE "public"."voice_recordings" TO "authenticated";

GRANT ALL ON TABLE "public"."voice_recordings" TO "service_role";

GRANT ALL ON TABLE "public"."vsl_video_analytics" TO "anon";

GRANT ALL ON TABLE "public"."vsl_video_analytics" TO "authenticated";

GRANT ALL ON TABLE "public"."vsl_video_analytics" TO "service_role";

GRANT ALL ON TABLE "public"."vsl_analytics_summary" TO "anon";

GRANT ALL ON TABLE "public"."vsl_analytics_summary" TO "authenticated";

GRANT ALL ON TABLE "public"."vsl_analytics_summary" TO "service_role";

GRANT ALL ON TABLE "public"."waitlist_admin_actions" TO "anon";

GRANT ALL ON TABLE "public"."waitlist_admin_actions" TO "authenticated";

GRANT ALL ON TABLE "public"."waitlist_admin_actions" TO "service_role";

GRANT ALL ON TABLE "public"."waitlist_email_invites" TO "anon";

GRANT ALL ON TABLE "public"."waitlist_email_invites" TO "authenticated";

GRANT ALL ON TABLE "public"."waitlist_email_invites" TO "service_role";

GRANT ALL ON TABLE "public"."waitlist_invite_codes" TO "anon";

GRANT ALL ON TABLE "public"."waitlist_invite_codes" TO "authenticated";

GRANT ALL ON TABLE "public"."waitlist_invite_codes" TO "service_role";

GRANT ALL ON TABLE "public"."waitlist_onboarding_progress" TO "anon";

GRANT ALL ON TABLE "public"."waitlist_onboarding_progress" TO "authenticated";

GRANT ALL ON TABLE "public"."waitlist_onboarding_progress" TO "service_role";

GRANT ALL ON TABLE "public"."waitlist_shares" TO "anon";

GRANT ALL ON TABLE "public"."waitlist_shares" TO "authenticated";

GRANT ALL ON TABLE "public"."waitlist_shares" TO "service_role";

GRANT ALL ON TABLE "public"."waitlist_with_rank" TO "anon";

GRANT ALL ON TABLE "public"."waitlist_with_rank" TO "authenticated";

GRANT ALL ON TABLE "public"."waitlist_with_rank" TO "service_role";

GRANT ALL ON TABLE "public"."webhook_events" TO "anon";

GRANT ALL ON TABLE "public"."webhook_events" TO "authenticated";

GRANT ALL ON TABLE "public"."webhook_events" TO "service_role";

GRANT ALL ON TABLE "public"."webhook_mirror_config" TO "anon";

GRANT ALL ON TABLE "public"."webhook_mirror_config" TO "authenticated";

GRANT ALL ON TABLE "public"."webhook_mirror_config" TO "service_role";

GRANT ALL ON TABLE "public"."workflow_batch_windows" TO "anon";

GRANT ALL ON TABLE "public"."workflow_batch_windows" TO "authenticated";

GRANT ALL ON TABLE "public"."workflow_batch_windows" TO "service_role";

GRANT ALL ON TABLE "public"."workflow_circuit_breakers" TO "anon";

GRANT ALL ON TABLE "public"."workflow_circuit_breakers" TO "authenticated";

GRANT ALL ON TABLE "public"."workflow_circuit_breakers" TO "service_role";

GRANT ALL ON TABLE "public"."workflow_contracts" TO "anon";

GRANT ALL ON TABLE "public"."workflow_contracts" TO "authenticated";

GRANT ALL ON TABLE "public"."workflow_contracts" TO "service_role";

GRANT ALL ON TABLE "public"."workflow_dead_letter_queue" TO "anon";

GRANT ALL ON TABLE "public"."workflow_dead_letter_queue" TO "authenticated";

GRANT ALL ON TABLE "public"."workflow_dead_letter_queue" TO "service_role";

GRANT ALL ON TABLE "public"."workflow_environment_promotions" TO "anon";

GRANT ALL ON TABLE "public"."workflow_environment_promotions" TO "authenticated";

GRANT ALL ON TABLE "public"."workflow_environment_promotions" TO "service_role";

GRANT ALL ON TABLE "public"."workflow_environments" TO "anon";

GRANT ALL ON TABLE "public"."workflow_environments" TO "authenticated";

GRANT ALL ON TABLE "public"."workflow_environments" TO "service_role";

GRANT ALL ON TABLE "public"."workflow_executions" TO "anon";

GRANT ALL ON TABLE "public"."workflow_executions" TO "authenticated";

GRANT ALL ON TABLE "public"."workflow_executions" TO "service_role";

GRANT ALL ON TABLE "public"."workflow_forms" TO "anon";

GRANT ALL ON TABLE "public"."workflow_forms" TO "authenticated";

GRANT ALL ON TABLE "public"."workflow_forms" TO "service_role";

GRANT ALL ON TABLE "public"."workflow_idempotency_keys" TO "anon";

GRANT ALL ON TABLE "public"."workflow_idempotency_keys" TO "authenticated";

GRANT ALL ON TABLE "public"."workflow_idempotency_keys" TO "service_role";

GRANT ALL ON TABLE "public"."workflow_mcp_logs" TO "anon";

GRANT ALL ON TABLE "public"."workflow_mcp_logs" TO "authenticated";

GRANT ALL ON TABLE "public"."workflow_mcp_logs" TO "service_role";

GRANT ALL ON TABLE "public"."workflow_rate_limits" TO "anon";

GRANT ALL ON TABLE "public"."workflow_rate_limits" TO "authenticated";

GRANT ALL ON TABLE "public"."workflow_rate_limits" TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";

ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";
